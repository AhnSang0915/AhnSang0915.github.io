<!DOCTYPE html>
<html>
<head>

    <!-- Document Settings -->
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />

    <!-- Base Meta -->
    <!-- dynamically fixing the title for tag/author pages -->



    <title>Search Result</title>
    <meta name="HandheldFriendly" content="True" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <!-- Styles'n'Scripts -->
    <link rel="stylesheet" type="text/css" href="/assets/built/screen.css" />
    <link rel="stylesheet" type="text/css" href="/assets/built/screen.edited.css" />
    <link rel="stylesheet" type="text/css" href="/assets/built/syntax.css" />

    <!--    costom.css-->
    <link rel="stylesheet" type="text/css" href="/assets/built/custom.css" />

    <!--    Font Awsome-->
    <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css">

    <!--    웹폰트 추가-->
    <link rel="stylesheet" href="https://fonts.googleapis.com/earlyaccess/nanumgothic.css">

    <!--    syntax.css-->
    <link rel="stylesheet" type="text/css" href="/assets/built/syntax.css" />


    <!-- highlight.js -->
    <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css">
    <style>.hljs { background: none; }</style>

    <!--[if IE]>
        <style>
            p, ol, ul{
                width: 100%;
            }
            blockquote{
                width: 100%;
            }
        </style>
    <![endif]-->
    
    <!-- This tag outputs SEO meta+structured data and other important settings -->
    <meta name="description" content="Learn Coding" />
    <link rel="shortcut icon" href="https://AhnSang0915.github.io/assets/built/images/favicon.png" type="image/png" />
    <link rel="canonical" href="https://AhnSang0915.github.io/search" />
    <meta name="referrer" content="no-referrer-when-downgrade" />

     <!--title below is coming from _includes/dynamic_title-->
    <meta property="og:site_name" content="My Coding Practice Gym" />
    <meta property="og:type" content="website" />
    <meta property="og:title" content="Search Result" />
    <meta property="og:description" content="Learn Coding" />
    <meta property="og:url" content="https://AhnSang0915.github.io/search" />
    <meta property="og:image" content="https://AhnSang0915.github.io/assets/built/images/blog-cover1.jpg" />
    <meta property="article:publisher" content="https://www.facebook.com/" />
    <meta name="twitter:card" content="summary_large_image" />
    <meta name="twitter:title" content="Search Result" />
    <meta name="twitter:description" content="Learn Coding" />
    <meta name="twitter:url" content="https://AhnSang0915.github.io/" />
    <meta name="twitter:image" content="https://AhnSang0915.github.io/assets/built/images/blog-cover1.jpg" />
    <meta name="twitter:label1" content="Written by" />
    <meta name="twitter:data1" content="My Coding Practice Gym" />
    <meta name="twitter:site" content="@" />
    <meta name="twitter:creator" content="@" />
    <meta property="og:image:width" content="2000" />
    <meta property="og:image:height" content="666" />

    <script type="application/ld+json">
{
    "@context": "https://schema.org",
    "@type": "Website",
    "publisher": {
        "@type": "Organization",
        "name": "My Coding Practice Gym",
        "logo": "https://AhnSang0915.github.io/"
    },
    "url": "https://AhnSang0915.github.io/search",
    "image": {
        "@type": "ImageObject",
        "url": "https://AhnSang0915.github.io/assets/built/images/blog-cover1.jpg",
        "width": 2000,
        "height": 666
    },
    "mainEntityOfPage": {
        "@type": "WebPage",
        "@id": "https://AhnSang0915.github.io/search"
    },
    "description": "Learn Coding"
}
    </script>

    <!-- <script type="text/javascript" src="https://demo.ghost.io/public/ghost-sdk.min.js?v=724281a32e"></script>
    <script type="text/javascript">
    ghost.init({
    	clientId: "ghost-frontend",
    	clientSecret: "f84a07a72b17"
    });
    </script> -->

    <meta name="generator" content="Jekyll 3.6.2" />
    <link rel="alternate" type="application/rss+xml" title="Search Result" href="/feed.xml" />


</head>
<body class="page-template">

    <div class="site-wrapper">
        <!-- All the main content gets inserted here, index.hbs, post.hbs, etc -->
        <!-- < default -->
<!-- The tag above means: insert everything in this file
into the {body} of the default.hbs template -->

<!-- The big featured header, it uses blog cover image as a BG if available -->
<header class="site-header outer">
    <div class="inner">
        <nav class="site-nav">
    <div class="site-nav-left">
        
            
                <a class="site-nav-logo" href="https://AhnSang0915.github.io/">My Coding Practice Gym</a>
            
        
        
            <ul class="nav" role="menu">
    <li class="nav-home" role="menuitem"><a href="/">Home</a></li>
    <li class="nav-about" role="menuitem"><a href="/about/">About</a></li>
    <li class="nav-javascript" role="menuitem"><a href="/tag/javascript/">Javascript</a></li>
    <li class="nav-python" role="menuitem"><a href="/tag/python/">Python</a></li>
    <li class="nav-archive" role="menuitem">
        <a href="/archive.html">All Posts</a>
    </li>
    <li class="nav-archive" role="menuitem">
        <a href="/author_archive.html">Tag별 Posts</a>
    </li>
</ul>
        
    </div>
    <div class="site-nav-right">
        <div class="social-links">
            
            
        </div>
        
            <a class="subscribe-button" href="#subscribe">Search</a>
        
    </div>
</nav>

    </div>
</header>

<!-- Everything inside the #post tags pulls data from the post -->
<!-- #post -->

<main id="site-main" class="site-main outer" role="main">
    <div class="inner">

        <article class="post-full  post page no-image">

            <header class="post-full-header">
                <h1 class="post-full-title">Search Result</h1>
            </header>

            

            <section class="post-full-content">
                <form action="/search" method="get" hidden="hidden">
    <label for="search-box"></label>
    <input type="text" id="search-box" name="query">
</form>

<ul class="mylist" id="search-results"></ul>

<script>
    window.store = {
    
    "javascript-basic15": {
        "title": "Javascript - JavaScript 함수지향 - arguments",
            "author": "AhnSang0915",
            "category": "",
            "content": "JavaScript 함수지향 - arguments1. arguments 소개arguments객체는 배열과 유사하다. arguments는 함수안에서 사용할 수 있도록 그 이름이나 특성이 약속되어 있는 일종의 배열이다. 몇개의 인자가 들어올지 모를떄 인자를 정의하지 않고 그함수 안에 arguments를 사용하여 결과를 알아내면 되겠다.아래의 예제는 매개변수가 없는 sum이라는 함수가 있다. javacsript는 관대한 언어이다. 매개변수가 없거나, 인자의 수와 매개변수의 수가 다르더라도 문제가 생기지 않는다.아래 for문에서의 arguments는 Javascript와 약속되어있는 특수한 이름의 변수명이다. arguments라는 배열이 담겨져 있다. 이 배열의 역할을 사용자가 전달한 인자(1,2,3,4)를 담는것이다. 그래서arguments.length는 4가되고 4만큼 for문이 반복되게된다.document.write(i+’ : ‘+arguments[i]+’’);는 0 : 1(인덱스0) 부터 차례로 표시하게되고, 그후 _sum의 변수에 +=(a+=1;는a=a+1;과 같다) arguments[i];를 담았다. 이말은 (1,2,3,4)의 값을 _sum = _sum + arguments[i]이다. 즉, sum_에 1234를 차례로 더한다는 것이다. _sum의 초기값은 0이기 때문에 10이된다.\tfunction sum(){    var i, _sum = 0;     // i 루프를 위한 변수 _sum 출력할 결과를 담아낼 변수    for(i = 0; i &lt; arguments.length; i++){       //arguments javascript와 약속되어있는 특수한 이름의 변수명        document.write(i+' : '+arguments[i]+'&lt;br /&gt;');        _sum += arguments[i];    }       return _sum;}document.write('result : ' + sum(1,2,3,4)); 2. 매개변수의 수 - function length함수명.length는 몇개의 매개변수를 갖고있는지 알려주고, arguments.length는 함수를 호출할때 몇개의 인자, 몇개의 arguments를 담고있는지의 정보를 담고있다.function zero(){    console.log(        'zero.length', zero.length,        'arguments', arguments.length    );}function one(arg1){    console.log(        'one.length', one.length,        'arguments', arguments.length    );}function two(arg1, arg2){    console.log(        'two.length', two.length,        'arguments', arguments.length    );}zero(); // zero.length 0 arguments 0 one('val1', 'val2');  // one.length 1 arguments 2 two('val1');  // two.length 2 arguments 1",
        "url": "/javascript-basic15"
    }
    ,
    
    "javascript-basic14": {
        "title": "Javascript - JavaScript 함수지향 - 클로저",
            "author": "AhnSang0915",
            "category": "",
            "content": "JavaScript 함수지향 - 클로저클로저(closure)는 내부함수가 외부함수의 맥락(context)에 접근할 수 있는 것을 가르킨다. 클로저는 자바스크립트를 이용한 고난이도의 테크닉을 구사하는데 필수적인 개념으로 활용된다.1. 내부함수, 외부함수내부함수아래 코드는 함수안에 또다른 함수를 선언한 것이다. 함수 outter은 외부함수가 되고 inner함수는 내부함수가 된다. inner함수는 var inner = fuction {} 과 같게된다.\tfunction outter(){    function inner(){        var title = 'coding everybody';         alert(title);    }    inner();}outter();아래 코드는 outter란 외부함수에 var title = ‘coding everyday’; 라는 지역변수를 만들었다. 그리고 내부함수로 inner을 만들었는데, 이때 이 내부함수 inner에 title이라는 변수를 사용하려고 하는데 이때 inner라는 함수에 지역변수가 존재하지 않는다면 Javascript는 이 inner라는 내부함수를 포함하고 있는 외부함수에서 title이라고하는 변수를 찾게된다. 즉, 내부함수에서 외부함수의 지역변수에 접근할 수 있다.이러한 것을 클로저(closure)라고 한다.function outter(){    var title = 'coding everybody';      function inner(){                alert(title);    }    inner();}outter();2. 클로저란?클로저(closure)는 내부함수와 밀접한 관계를 가지고 있는 주제다. 내부함수는 외부함수의 지역변수에 접근 할 수 있는데 외부함수의 실행이 끝나서 외부함수가 소멸된 이후에도 내부함수가 외부함수의 변수에 접근 할 수 있다. 이러한 메커니즘을 클로저라고 한다. 아래 예제는 이전의 예제를 조금 변형한 것이다. 내부함수inner를 outter함수내에서 호출하는 것이 아니라 반환하도록 했다. 함수 outter는 내부함수 inner를 반환하고 생을 마감했다. 즉, 함수 outter는 실행된 이후 실행이 종료되어 함수 ouuter의 변수 title또한 더이상 유효하지 않게되어 변수 title에 접근할수 없어 보인다. 그러나 아래 코드의 실행 결과는 경고창으로 coding everybody를 출력할 것이다. 이처럼 자신을 포함하고 있는 외부함수보다 내부함수가 더 오래 유지되는 경우, 외부함수 밖에서 내부함수가 호출되더라도 외부함수의 지역 변수에 접근할 수 있는데 이러한 함수를 클로저(closure)라고 부른다.function outter(){    var title = 'coding everybody';      return function(){                alert(title);    }}var inner = outter();inner();즉, 클로저는 반환된 내부함수가 자신이 선언됐을 때의 환경(Lexical environment)인 스코프를 기억하여 자신이 선언됐을 때의 환경(스코프) 밖에서 호출되어도 그 환경(스코프)에 접근할 수 있는 함수를 말한다. 이를 조금 더 간단히 말하면 클로저는 자신이 생성될 때의 환경(Lexical environment)을 기억하는 함수다라고 말할 수 있겠다.3. Private variable소프트웨어가 커지는 과정에서 어떠한 정보가 있을때 그 정보를 아무나 수정하는것을 방지하는 것을 Private variable이라 한다. 소프트웨어가 커지면 여러사람이 코드를 작성하게 된다. 그안에는 과거의 자기자신과 미래의 자기자신이 포함되게된다. 그런경우 많은 데이터가 소프트웨어 안에 존재하게 되는데 그 데이터가 누구나 고칠수있는 데이터가 된다는것은 그데이터가 망가질 가능성이 크다는 것이다. 그런 것을 방지하기 위해 접근하는 방법을 클로저를 사용하여 데이터를 가져오고 수정하는 것을 안전하게 하는것이다.아래는 factory_movie라는 외부함수가 get_title, set_title이라는 두 메소드에 함수를 지정한 객체를 담고있다. 이때 get_title, set_title은 내부 함수가 된다. get_title메소드를 호출하면 title이라는 값을 리턴하는데 그 title의 값은 factory_movie함수에 첫번째 인자이다. 첫번째 매개변수가 title이고 이 매개변수는 함수안에서 지역변수로 사용이 된다. 그렇기 때문에 factory_movie(title)은 지역변수이고 지역변수는 내부함수에서 접근이 가능하기 때문에 get_title을 호출하면 factory_movie의 첫번째 매개변수인 title이 값이 되기때문에 factory_movie함수의 (title)에 전달된 값을 리턴해준다. 그리고 set_title메소드는 첫번째 인자로 _title을 갖고 그리고 _title이라는 값은 다시 title이되고 그값은 내부변수를 의미하기때문에 factory_movie의 (title)을 변경하게 된다. 그다음 ghost와 matix라는 변수에 리턴값을 담았다. alert(ghost.get_title()); 는 ‘Ghost in the shell’을 출력하고, alert(matrix.get_title());는 ‘Matrix’를 출력한다. 이말은 ghost와 matix가 같은 객체를 담고 있지만 그 객체가 담고있는 get_title이라는 메소드가 접근하는 title이라고하는 외부변수에 담겨있는 값은 서로 다르다는 것이다. ghost.set_title(‘공각기동대’);는 ghost라는 변수 안에 set_title이라는 메소드를 호출하고 ‘공각기동대’ 를 인자로 사용하겠다는 말이다. ‘공각기동대는’ _title이되고 _title은 title이 되기 때문에 이 타이틀의 값은 factory_movie함수의 지역변수를 바꾸게 된다. alert(ghost.get_title());를 호출하게 되면 ‘공각기동대’를 출력하고, alert(matrix.get_title());를 호출하면 ‘Matrix’를 실행하게 된다. 즉, 우리가 factory_moviex통해 두개의 ghost와 matix변수를 만들었고, 그두개의 변수는 자신들이 실행된 그 시점에서의 외부함수의 지역변수에 접근할 수있었고 그지역변수의 값은 유지되고 있기때문에 ghost라는 함수에 set_title을 통해서 그내용을 ‘공각기동대’로 바꾼다 라는것은 ghost가 접근할수있는 title의 값만을 바꾸는것이지 matrix라는 변수가 접근할수 있는 title의 값에는 어떠한 영향도 미치지 않는다는 것이다.function factory_movie(title){    return {        get_title : function (){            return title;        },        set_title : function(_title){            title = _title        }    }}ghost = factory_movie('Ghost in the shell');matrix = factory_movie('Matrix'); alert(ghost.get_title());alert(matrix.get_title()); ghost.set_title('공각기동대'); alert(ghost.get_title());alert(matrix.get_title());이코드의 진짜 효용은 private variable이라는 것이다.  ghost와 matix변수에 객체를 담았다. 이객체의 get_title, set_title은 언제든지 접근할 수 있는 메소드이다. 누구나 접근할수 있다는 것이다. get_title, set_title이 내부적으로 사용하고 이있는 변수는 title이다. 이title은 외부 함수의 지역변수인 title이다.이지역변수인 title은 factory_movie라는 함수가 어떠한 값을 리턴했을때 factory_movie함수 자체는 실행이 끝났기 때문에 그지역변수인 title은 factory_movie의 내부함수인 get_title, set_title을 통해서만 접근할 수 있는 변수가 되는것이다. 즉, 우리가 title이라는 변수 값을 private variable로 만들고 그값을 수정할때는 set_titl을 통해서만 수정할 수 있고, 그변수의 값을 가져올때는 get_title를 통해서만 가져올 수 있게 하면 title이라는 변수가 안전하게 저장,수정될 수 있다는 것이다.4. 클로저의 응용클로저를 활용하는 것에서 실수하기 쉬운 예제를 보자. Javascript에서는 오로지 함수의 괄호 안에서만 지역변수로서 할당되고 그 외 모든 장소는 전역변수로 취급을 받는다. 우리가 예상하는 결과는 0,1,2,3,4 일것이다. 하지만 그렇지 않다. 첫번째 for문이 반복되는 동안 점점 증가되는 i의 값이 arr라는 배열에 저장될 것 같지만, 실제로 저장되는 것은 함수 그 자체이다. i는 반복이 끝난후 5라는 값이되고 return i 의 값은 5가된다. 그리고 다음 for in문에서 arr[index]는 해당 인덱스의 값으로서의 함수이고 ()를 붙였음으로 해당 함수가 호출된다. i 값은 첫번째 for문을 돌아 5가된 상태이기 때문에 5, 5, 5, 5, 5가 출력된다.var arr = []for(var i = 0; i &lt; 5; i++){    arr[i] = function(){        return i;    }}for(var index in arr) {    console.log(arr[index]());}그렇다면 정상출력 0, 1, 2, 3, 4을 얻기위해선 어떻게 해야할까? 위의 코드에서 달라진 점은 그전의 코드를 외부 함수로 감싸주어서 원래 함수는 내부 함수가 된다는 것아다. 그리고 외부 함수는 내부 함수를 값으로 반환하는데 그 자리에서 바로 그 외부 함수를 호출하기 때문에 내부 함수가 값으로서 반환되어 바로 변수에 할당이 된다.var arr = []for(var i = 0; i &lt; 5; i++){    arr[i] = function(id) {        return function(){            return id;        }    }(i);}for(var index in arr) {    console.log(arr[index]());}/* 결과01234*/위의 두 예제에서 첫번째 for문을 비교한 것이다.var arr = [];for(var i = 0; i &lt; 5; i++){  arr[i] = function(){    return i;  }}  arr[0] = function(){    return i;  }  arr[1] = function(){    return i;  }  arr[2] = function(){    return i;  }  arr[3] = function(){    return i;  }  arr[4] = function(){    return i;  }for(var i = 0 ; i &lt; 5; i++){  arr[i] = function(id){  //외부함수.    return function(){    //내부함수.      return id;    }  }(i);  //외부함수 호출}  arr[0] = function(){      return 0;  }  arr[1] = function(){      return 1;  }  arr[2] = function(){      return 2;  }  arr[3] = function(){      return 3;  }  arr[4] = function(){      return 4;  }",
        "url": "/javascript-basic14"
    }
    ,
    
    "javascript-basic13": {
        "title": "Javascript - JavaScript 함수지향 - 값으로서의 함수와 콜백",
            "author": "AhnSang0915",
            "category": "",
            "content": "JavaScript 함수지향 - 값으로서의 함수와 콜백1. 값으로서의 함수Javascript에서는 함수도 객체이다. 함수를 일단 값이라고 생각하자. 값의 특징은 어떠한 변수에 담을수 있다. var a = “value” a라는 변수에 값으로 value를 넣은것이다. 함수가 일종의 값이라는 것은 함수 역시 어떤 변수에 담을수 있다는 것이다. Javascript의 함수가 다른 언어의 함수와 다른 점은 함수가 값이 될 수 있다는 점이다. 예제를 보자.\tfunction a(){} // var a = function () {}위 예제에서 a라고하는 함수를 정의했다. 위처럼 함수를 정의하는 것은 a라고하는 변수에 담겨진 값이라는 것이다. 아래 예제에선 객체에 변수를 담았다. a라는 객체에 b라는 key와 function(){}이란 value를 담은것이다. 이처럼 객체 안에 함수를 담게되면 함수는 값이기 때문에 b는 객체안에서 변수와 같은 역할을 하고있다. 객체안에서 변수의 역할을 하는것을 속성(Property)라고 하고 그 속성에 저장된 값이 함수라면 그함수는 이러한 맥락에선 메소드(method)라고 한다.a = {    b:function(){    }};또한 함수는 값이기 때문에 다른 함수의 인자로 전달 될수도 있다. increase는 num이라는 매개변수에 +1을해 리턴, decrease는 -1알한 값을 리턴해준다. cal이라는 함수는 func, num이라는 매개변수를 갖고있고 func의 함수에 num이라는 값을 호출하고있다. alert(cal(increase, 1));을 하게되면 cal의 매개변수가 increase, 1이 인자가 된다. 즉, increase라는 함수에 1이라는 인자가 전달되기 때문에 2가된다.function cal(func, num){    return func(num)}function increase(num){    return num+1}function decrease(num){    return num-1}alert(cal(increase, 1));alert(cal(decrease, 1));2. 값으로서의 함수와 콜백 - 함수의 용도2함수는 함수의 리턴 값으로도 사용할 수 있다. 아래 코드를 보자. cal라는 함수를 호출할때 첫번째 인자로 ‘plus’ 라는값을 주면 객체를 담고있는 함수에 ‘plus’라는 인자가 들어가게 되고 function cal(‘plus’), return funcs(‘plus’)가 된다. alert(cal(‘plus’) (2, 1))에서 (cal(‘plus’)는 function(left, right){return left + right} 이부분이 되고, alert(cal(‘plus’) (2, 1)) 에서 (2, 1)은 함수를 호출하겠다는 말이고 인자로 2, 1을 전달하겠다는 것이다. 결과는 3이된다.function cal(mode){    var funcs = {        'plus' : function(left, right){return left + right},        'minus' : function(left, right){return left - right}    }    return funcs[mode];}alert(cal('plus')(2,1));alert(cal('minus')(2,1));당연히 배열의 값으로도 사용할 수 있다. process라는 배열을 정의했고 배열안의 요소 3개가 모두 함수이다. for반복문에서  i = 0 일때 process라는 배열의 index 0의 요소의 함수를 호출하고 첫번째 인자로 1을 전달한다. 이후 input의 값은 11이되고 index 다시 반복문으로 돌아와 1의 요소의 함수를 호출하게 된다. 이때 input의 값은 배열의 첫번쨰 요소에서 얻은 11이 된다. 값은 121이 되고 이 값은 다시 input의 값이 된다. 이후배열의 세번째 요소로 121의 값이 전달되고 60.5의 결과가 나온다.var process = [    function(input){ return input + 10;},    function(input){ return input * input;},    function(input){ return input / 2;}];var input = 1;for(var i = 0; i &lt; process.length; i++){    input = process[i](input);}alert(input);3. 값으로서의 함수와 콜백 - 콜백이란?콜백은 어떠한 함수가 수신하는 인자가 함수인 경우를 콜백이라고 한다. 처리의 위임값으로 사용될 수 있는 특성을 이용하면 함수의 인자로 함수로 전달할 수 있다. 값으로 전달된 함수는 호출될 수 있기 때문에 이를 이용하면 함수의 동작을 완전히 바꿀 수 있다. 인자로 전달된 함수 sortNumber의 구현에 따라서 sort의 동작방법이 완전히 바뀌게 된다.아래 예제에서 배열의 내용을 정렬하려면 numbers.sort();라는 명령을 내리는 것이다. 여기서 .앞의 numbers는 배열객체가 되고 우리가 아래처럼 [20, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1]를 작성해 Javascript에 제출을하면 배열객체를 만들어 numbers라고하는 변수에 담아준다. 그리고 배열객체에는 sort라고하는 함수가 정의되어 있기때문에 numbers.sort();를 통해서 배열이 가지고있는 명령어 sort를 호출하게 되는데 여기서 sort는 함수라고 하지않고 객체에 속해있기 때문에 메소드라고 한다. 이러한 numbers객체 또는 sort메소드는 Javascript에서 기본적으로 제공하는 기능이기 때문에 이러한 기능을 내장 객체 내장 메소드, 또는 빌트인 객체 빌트인 메소드라고 한다. 그리고 우리가 만드는 객체나 메소드, 함수같은 것들은 우리가 만드는 것이기 때문에 사용자정의 객체, 사용자정의 메소드 라고한다.&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;script src=\"//code.jquery.com/jquery-1.11.0.min.js\"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;script type=\"text/javascript\"&gt;    var numbers = [20, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1];    numbers.sort(); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;위의 코드를 실행하면 배열안의 내용을 정렬해주고 결과는 [1, 10, 2, 20, 3, 4, 5, 6, 7, 8, 9] 가 출력된다. 이유는 숫작의 크기로 비교한게 아니고 문자로 비교를 했기 때문이다. 앞의 숫자가 1인것들이 우선순위를 갖고 나머지를 정렬했기 때문이다. 우리가 원하는 결과를 얻기 위해선 아래의 방법을 이용해야 한다.&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;script src=\"//code.jquery.com/jquery-1.11.0.min.js\"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;script type=\"text/javascript\"&gt;    var numbers = [20, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1];    var sortfunc = function(a, b) {        console.log(a, b);        if(a &gt; b) {            return 1;        } else if (a&gt;b){            return -1;        } else {            return 0;        }    }    console.log(numbers.sort(sortfunc)); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;위의 코드를 단순하게 하면 아래처럼 된다. 아래의 함수에서 sortfunc가 콜백함수가 되고 콜백 함수 라는것은 콜백함수를 수신받는 sort메소드가 sortfunc를 인자로 전달받아 내부적으로 호출하는 것을 통해서 sort함수가 동작하는 기본적인 동작방법을 변경할수 있게 된다. 즉, 값으로서 함수를 사용할수 있기때문에 함수의 동작방법을 값을 전달하는 것을 통해 바꿀수 있는게 콜백 이다. 그리고 콜백이 가능한 것은 Javascript의 함수가 값이기 때문에 가능한 것이다.&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;script src=\"//code.jquery.com/jquery-1.11.0.min.js\"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;script type=\"text/javascript\"&gt;    var numbers = [20, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1];    var sortfunc = function(a, b) {        return a-b; // 역순 b-a     }    console.log(numbers.sort(sortfunc)); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;4. 비동기 콜백과  Ajax예를 들어 우리가 홈페이지를 운영하는데 만명정도의 구독자가 있다고 치자. 우리가 글을쓰면 만명에게 메일이 전송되게 되어있다. 한명에게 메일을 보내는데 1초가 걸리면 만명에게 보내는데에는 만초가 걸리게 된다. 글을 작성하고 이메일을 전송후 작성완료까지 3시간을 기다려야 한다면 이런 서비스를 사용하기는 힘들것이다.이렇게 순서대로 실행하는 것을 동기적 처리라고한다. 그런데 우리가 글작성을하고 이메일을 발송하지 않고 발송 예약후 작성완료를 하게 되면 시간이 훨씬 줄어들게 된다. 그리고 내부적으로 사용자에게 노출되지 않는 프로그램이 작동하면서 이메일 발송예약이 들어와 있는지 아닌지를 확인해 들어와있다면 프로그램이 만명에게 이메일 발송하는 작업을 3시간동안 백그라운드에서 진행하면 될것이다. 이렇게 처리하는 방식을 비동기적인 처리라고한다. 우리는 이 비동기적 처리를 Ajax(Asynchronous javascript and xml) 로 사용할 수 있다.우리가 아래와 같은 객체를 만든 파일을 만들었다고 가정하고 예제를 보자.{\"title\":\"JavaScript\",\"author\":\"egoing\"}생활코딩의 동영상을 보고 이해하는것이 좋겠다…(아직 이해못함.)&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;script src=\"//code.jquery.com/jquery-1.11.0.min.js\"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;script type=\"text/javascript\"&gt;    $.get('./datasource.json.js', function(result){ //$는 jquery가 제공하는 특수한 객체이다. 여기에 get이라는 메소드를 사용해 json타입 파일을 호출하는 것이다.        console.log(result);    }, 'json');&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;",
        "url": "/javascript-basic13"
    }
    ,
    
    "javascript-basic12": {
        "title": "Javascript - JavaScript 함수지향 - 유효범위",
            "author": "AhnSang0915",
            "category": "",
            "content": "JavaScript 함수지향 - 유효범위1. 전역변수와 지역변수유효범위(Scope)는 변수의 수명을 의미한다. 아래의 예제를 보자. vscope라는 변수에 global이라는 데이터를 할당했다. fscope라는 함수는 함수 안에 선언되어 있지 않은, 함수 바깥쪽에 선언되어있는 vscope에 접근할 수 있다. 결과는 global이다.var vscope = 'global';function fscope(){    alert(vscope);}fscope();아래를 실행하게 되면 결과는 ‘함수안 local’과 ‘함수밖 global’이 출력된다. fscope 함수안에 vscope라는 변수가 할당되어 있기 때문에 vscope는 자기자신과 가까이에 있는 vscope를 가르키기 때문에 ‘local’이라는 값을 출력하게 된다. 함수안의 fscope 함수안에 정의 되어 있는 vscope는 지역변수(local variables) 이고, 함수밖에  정의되어 있는 vscope변수는 전역변수(global variables)라고 한다.즉 지역변수의 유효범위는 함수 안이고, 전역변수의 유효범위는 에플리케이션 전역인데, 같은 이름의 지역변수와 전역변수가 동시에 정의되어 있다면 지역변수가 우선한다는 것을 알 수 있다.var vscope = 'global';function fscope(){    var vscope = 'local';    alert('함수안 '+vscope);}fscope();alert('함수밖 '+vscope);var을 쓴것과 쓰지않은것의 차이점을 알아보자. var을쓰면 전역변수를 호출하게되고 var을 쓰지않으면 vscope가 지역변수가 되어 global을 local로 변경하게된다. 즉,  var을 사용하지 않은 지역변수는 전역변수가 된다. fscope라는 함수에 var쓰고 변수를 지정하게 되면 fscope함수에 지역변수를 지정한것이다. 그렇기 때문에 전역 변수의 값이 local로 변경 된 것이다. 그렇기 때문에 출력은 local이 되게 된다.var vscope = 'global';function fscope(){    var vscope = 'local';   }fscope();alert(vscope);// var을 쓸때 global// var을 쓰지 않을때 local아래 예제는 어떻게 될까? 마찬가지로 global을 출력하게 된다. 이유는 이미 var vscope으로 인해 지역변수가 생성이되었다. 그렇기 때문에 vscope를 사용해도 지역변수가 되는것이지 전역변수가 변경되지는 않는다.var vscope = 'global';function fscope(){    var vscope = 'local';    vscope = 'local';   }fscope();alert(vscope);// global2. 유효범위의 효용아래 두개의 예제는 변수 i를 지역변수로 사용했을 때와 전역변수로 사용했을 때의 차이점을 보여준다. 전역변수는 각기 다른 로직에서 사용하는 같은 이름의 변수값을 변경시켜서 의도하지 않은 문제를 발생시킨다.같은 이름을 사용했지만 var을 사용하는것과 사용하지 않는것의 차이가 있다. for문 안에들어있는 i의 값이 선언된것은 어떤 함수에 소속되지 않은 것이다. 그렇기 때문에 전역변수이고 함수 a를 호출하게 되면 변수 i의 값을 0으로 바꿔주고 있다. 그런데 var을 붙이지 않은것은 전역변수를 의미하게 된다. a함수와 for문이 가르키고 있는 i가 같기때문에 a가 실행될때마다 i의값이 매번 0으로 초기화된다. 따라서 무한반복하는 현상이 나타나고 같은이름의 변수를 중복해서 사용했지만 각각의 취지가 다를 때 이런현상이 일어난다.function a (){    var i = 0; //결과 01234    // i=0; // 결과 무한반복}for(var i = 0; i &lt; 5; i++){    a();    document.write(i);}3. 전역변수를 사용하는 법불가피하게 전역변수를 사용해야 하는 경우는 하나의 객체를 전역변수로 만들고 객체의 속성으로 변수를 관리하는 방법을 사용한다.아래의 예제는 MYAPP이라는 전역변수 하나를 만들어서 속성을 지정해 만들었다. 이처럼 전역변수 하나만을 만들고 나머지 다른 전역변수들은 바로 그 전역변수의 소속에 해당되게 만들면 변수의 이름이 충돌할 가능성이 낮아진다.var MYAPP = {}MYAPP.calculator = { //calculator 속성    'left' : null,    'right' : null}MYAPP.coordinate = {    'left' : null,    'right' : null} MYAPP.calculator.left = 10;MYAPP.calculator.right = 20;function sum(){    return MYAPP.calculator.left + MYAPP.calculator.right;}document.write(sum());아래의 예제는 함수안에 변수를 지정해 함수의 지역변수로 만들었다. 함수를 정의하고 바로 호출하는 기법을 익명함수라고 한다. 이러한 기법을 이용해 전역변수가 하나도 존재하지않는 방식을 사용할 수도있다.(function(){    var MYAPP = {}    MYAPP.calculator = {        'left' : null,        'right' : null    }    MYAPP.coordinate = {        'left' : null,        'right' : null    }    MYAPP.calculator.left = 10;    MYAPP.calculator.right = 20;    function sum(){        return MYAPP.calculator.left + MYAPP.calculator.right;    }    document.write(sum());}())4. 유효범위의 대상Javascript는 함수에 대한 유효범위만을 제공한다. 다시말해 Javascript 에선 for문이나 if문에서 중괄호 안에서 선언된 변수는 지역변수로서의 의미를 갖지 않는다. 많은 언어들이 블록(대체로 {,})에 대한 유효범위를 제공하는 것과 다른 점이다. 아래 예제의 결과는 coding everybody이다.for(var i = 0; i &lt; 1; i++){    var name = 'coding everybody';}alert(name);자바에서는 아래의 코드는 허용되지 않는다. name은 지역변수로 for 문 안에서 선언 되었는데 이를 for문 밖에서 호출하고 있기 때문이다.for(int i = 0; i &lt; 10; i++){    String name = \"egoing\";}System.out.println(name);5. 정적 유효범위자바스크립트는 함수가 선언된 시점에서의 유효범위를 갖는다. 이러한 유효범위의 방식을 정적 유효범위(static scoping), 혹은 렉시컬(lexical scoping)이라고 한다. 이는 이후에 살펴볼 클로저와 연관되어 있다.전역변수 var i = 5가 정의되어 있고 a 함수는 var i = 10이라는 지역변수를 정의하고 있다. a라고 하는 함수를 호출했을 때 함수의 내부적으로 i의 값이 10이 된다. 그 상태에서 b를 호출하게 되면 i는 b 함수 안에 i라고 하는 지역변수가 존재하는지 찾게 된다. 없다면 전역변수를 찾게 되는데 b를 호출하고 있는 함수는 a이다.그렇다면 a 함수에 정의된 변수 a를 호출하게 될까? 아니다. 왜냐하면, 함수 b가 선언된 시점에서 i의 전역변수가 사용되는 것이지 b가 호출된 시점에서 b가 담겨있는 함수의 지역변수가 사용되는 것이 아니다. 즉, 사용될 때 가 아니고 정의 될 때의 전역변수가 사용되게 된다는 말이다. 이러한 것을 정적 유효범위 또는 렉시컬(lexical scoping)유효범위라고 한다.var i = 5; // 전역변수 function a(){    var i = 10; // 지역변수    b();} function b(){    document.write(i);} a(); // 5",
        "url": "/javascript-basic12"
    }
    ,
    
    "javascript-basic11": {
        "title": "Javascript - JavaScript 정규표현식",
            "author": "AhnSang0915",
            "category": "",
            "content": "JavaScript 정규표현식정규표현식(Reguler expression)은 문자열 안에서 어떠한 문자가 있는지 없는지, 그문자를 다른 문자로 치환하는 것들을 도와주는 방법이다. 정보와 관련된 언어에서는 정규표현식이 매우 중요하다. 정규표현식의 공부는 양이 많아 따로 해야한다 링크를 통해 공부하고 아래내용을 보는게 좋겠다.1. 패턴만들기정규 표현식은 두가지 사용방법으로 이루어진다. 하나는 컴파일(compile) 다른 하나는 실행(execution)이다. 우선 컴파일부터 알아보자. 우리가 문자열을 변수에 담을때 var str = “a”; 의 식으로 하게된다. 마찬가지로 우리가 정규표현식을 만들때 정규표현식 리터럴이라는것을 이용해 만든다.//정규표현식 리터럴var pattern = /a/;또하나의 방법은 정규표현식 객체 생성자를 사용하는 방법이다. 두방법 모두 정규표현식 객체를 pattern이라는 변수에 담은것이다. 우리가 찾고자하는 정보를 pattern이라는 변수에 저장을 한것이다.var pattern = new RegExp('a');2. RegExp객체의 사용우리가 어떤일을 할때 두가지 방법이 있다. 작업을 할 대상을 선택하고 그리고 그대상에 대하 어떤작업을 할지 정한다. 먼저 해야할 것은 작업할 대상을 찾는것이다. 이작업을 할수 있게 해주는게 정규표현식이다.정규표현식 메소드 실행정규표현식을 컴파일해서 객체를 만들었다면 이제 문자열에서 원하는 문자를 찾아내야 한다.RegExp.exec()문자열 a를 찾고싶다고할때 pattern변수안에 정규표현식 a를 지정하고 RegExp.exec()로 실행을 시킬수 있다.RegExp는 정규표현식을 의미하고 exec는 실행을 의미한다. 즉, 우리가 지정한 정규표현식을 실행하는데 그실행의 대상을 첫번째 인자로 전달하고, 그정보가 있는지 없는지 찾으려고 하는 정보가 (‘abcdef’) 이고 이것이 두번째 인자가 된다. 실행결과는 문자열 a를 값으로 하는 배열을 리턴한다.var pattern = /a/;console.log(pattern.exec('abcdef')); // [\"a\"]이번엔 변수에 정규표현식 a.을 담았다. 결과는 ab가되는데 이것은 정규표현식에서 .이 문자 1개를 의미하기 때문이다.var pattern = /a./;console.log(pattern.exec('abcdef')); // [\"ab\"]인자 ‘bcdef’에는 a가 없기 때문에 null을 리턴한다.var pattern = /a/;console.log(pattern.exec('bcdefg')); // nullRegExp.test()우리가 필요한 정보를 추출해내야 할때 사용한다. 우리가 찾는 어떤 정보가 있는지 없는지를 존재 유무를 테스트 한다.test는 인자 안에 패턴에 해당되는 문자열이 있으면 true, 없으면 false를 리턴한다var pattern = /a/;console.log(pattern.test('abcdef')); // truecnosole.log(pattern.test('bcdefg')); // false3. String과 정규표현식String.match()RegExp.exec()와 비슷하다.var pattern = /a/;console.log('abcdef'.match(pattern)); // [\"a\"]console.log('bcdefg'.match(pattern)); // nullString.replace()String.replace()는 문자열에서 패턴을 검색해서 이를 변경한 후에 변경된 값을 리턴한다.pattern a를 찾아 A로 치환해주었다.console.log('abcdef'.replace(pattern, 'A'));  // Abcdef4. 옵션(i, g)정규표현식 패턴을 만들 때 옵션을 설정할수있다. 찾고자하는 값 뒤에 옵션을 넣어주면 되고, 옵션에 따라 검출되는 데이터가 달라진다.i는 대소문자 구분을 없애주는 역할을 한다.var xi = /a/;console.log(\"Abcde\".match(xi)); // nullvar oi = /a/i;console.log(\"Abcde\".match(oi)); // [\"A\"];g는 문자열에 포함되어 있는 패턴에 해당되는 문자열들을 모두 리턴해준다.var xg = /a/;console.log(\"abcdea\".match(xg)); // [\"a\"]var og = /a/g;console.log(\"abcdea\".match(og)); // [\"a\",\"a\"]두가지 모두 사용도 가능하다.var og = /a/ig;console.log(\"AabcdAa\".match(ig)); // [\"A\",\"a\",\"A\",\"a\"]5. 캡쳐그룹을 지정하고 지정된 그룹을 가져와 사용하는 기능, 또는 사용할 수 있는 개념을 캡쳐라고 부른다.var pattern = /(\\w+)\\s(\\w+)/; // 문자열 공백 문자열var str = \"coding everybody\"; //coding$1 everybody$2var result = str.replace(pattern, \"$2, $1\"); //$2,(공백)$1로 치환.console.log(result);//everybody, coding6. 치환아래 코드는 본문 중의 URL을 링크 html 태그로 교체한다. \\b는 단어를 식별한다. ?:로 https를 캡쳐로 지정하지 않고 뒤에 ?로 https, http가 모두 해당되게 했다. 뒤에 //는 escape를 사용해 문자화 시켰고 그뒤의 a-z는 a부터 z까지 0-9 는 0에서 9까지 그리고 그뒤에 주소에 들어갈만한 특수문자들 까지 해당되게 해줬다. 그리고 replace라는 메소드가 실행될때 urlPattern해당되는 텍스트를 찾을때마다 두번째인자로 전달된 함수가 replace라는 메소드 내부로 호출된다. 호출될때 javascript는 호출된 시점에서 검색된 문자열을 첫번째 인자(url)로 전달되게 약속되어있다. 그리고 그 텍스트를 가공을하고 리턴을 해주면 우리가 변경하고싶은 내용으로 변경되게 된다.var urlPattern = /\\b(?:https?):\\/\\/[a-z0-9-+&amp;@#\\/%?=~_|!:,.;]*/gim;var content = '생활코딩 : http://opentutorials.org/course/1 입니다. 네이버 : http://naver.com 입니다. ';var result = content.replace(urlPattern, function(url){    return '&lt;a href=\"'+url+'\"&gt;'+url+'&lt;/a&gt;';});console.log(result);//생활코딩 : &lt;a href=\"http://opentutorials.org/course/1\"&gt;http://opentutorials.org/course/1&lt;/a&gt; 입니다. 네이버 : &lt;a href=\"http://naver.com\"&gt;http://naver.com&lt;/a&gt; 입니다.",
        "url": "/javascript-basic11"
    }
    ,
    
    "javascript-basic10": {
        "title": "Javascript - JavaScript UI와 API",
            "author": "AhnSang0915",
            "category": "",
            "content": "JavaScript UI와 API1. UI란?UI(User Interface)는 컴퓨터의 시스템과 사용자의 접점에 존재하며 중개자에 해당하는 것을 UI라고 한다. 사용자를 대면하는 접점을 하는 지점을 UI라고하고 물리적, 하드웨어적 UI가 있고 소프트웨어적 UI가 있다. 노트북이나 키보드에 있는 버튼이 하드웨어적 UI라 할수있고 브라우저의 각종 버튼이 소프트웨어적 UI라 할수 있겠다.2. API란?API란 Application Programming Interface의 약자로 프로그램이 동작하는 환경을 제어하기 위해서 환경에서 제공되는 조작 장치이다. 이 조작 장치는 프로그래밍 언어를 통해서 조작할 수 있다. 일반 사용자는 UI를 사용해 원하는 결과를 얻고 개발자는 API를 이용해 자신이 하고자하는 프로그래밍을 하게된다.Javascript의 APIJavascript의 API는 크게 Javascript 자체의 API와 Javascript가 동작하는 호스트 환경의 API로 구분된다. 현재 우리가 공부하는건 Javascript자체의 API이고 앞으로 나아가 더 공부를 하게되면 호스트 환경에서의 API도 공부해야한다.Javascript API 문서Javascript가 제공하는 기본적인 API를 볼수있는 사이트이다. 여기서 필요한 API를 찾아 사용하면 된다.  ECMAScript.  Javascript사전.  Javascript 레퍼런스 MDN.  jscript 레퍼런스.호스트 환경의 API 문서호스트 환경에서의 API를 볼수있는 사이트이다. 지금 우리는 기본적인 Javascript의 API를 공부하고 있어 당장은 필요하지 않지만 앞으로 심화과정에 들어가면 사용할 일이 있을것이다.  웹브라우저 API.  Node.js API.  Google Apps Script API.",
        "url": "/javascript-basic10"
    }
    ,
    
    "javascript-basic9": {
        "title": "Javascript - JavaScript 모듈",
            "author": "AhnSang0915",
            "category": "",
            "content": "JavaScript 모듈1. 모듈이란?프로그램은 작고 단순한 것에서 크고 복잡한 것으로 진화한다. 이과정에 필요한 것은 코드의 재활용성, 유지보수의 편의성등이 있다. 어떤 프로그램을 구성하고 있는 수만은 로직들을 재사용 할 수 있는 단위로 조각조각 나누어 구획화를 시켜 별도의 모듈이라는 형태로 떼어내 이것을 또다른 프로그램의 부품으로 사용하는 기법, 그런 부품들을 모듈이라 하고 이러한 기법을 모듈화 라고 한다. 아래는 모듈화를 통해 얻을 수 있는 효과이다.  자주 사용되는 코드를 별도의 파일로 만들어서 필요할 때마다 재활용할 수 있다.  코드를 개선하면 이를 사용하고 있는 모든 애플리케이션의 동작이 개선된다.  코드 수정 시에 필요한 로직을 빠르게 찾을 수 있다.  필요한 로직만을 로드해서 메모리의 낭비를 줄일 수 있다.  한번 다운로드된 모듈은 웹브라우저에 의해서 저장되기 때문에 동일한 로직을 로드 할 때 시간과 네트워크 트래픽을 절약 할 수 있다. (브라우저에서만 해당)Javascript에서는 모듈이라는 개념이 분명하게 존재하지 않는다. Javascript에서는 모듈이라는 기능 자체를 제공하지 않는다. 구동 환경(호스트 환경)에 따라서 Javascript로직 구성을 모듈형식으로 구성해 사용한다.2.모듈화모듈화를 알기 전에 모듈이 없다는 가정을 해보자. 그리고 funcion함수가 엄청 복잡하다고 가정하고, 함수 호출도 여러번하며 html파일이 아래 welcome이라는 함수를 여러 html에서 호출한다고 생각해보자. 그렇다면 welcome이라는 함수를 해당 페이지에 두는것은 덩치가 엄청 커질것이다. 이런경우 내가 필요한 코드와 그렇지 않은 코드를 분류하는게 힘들어 질 것이다. welcome이라는 함수를 별도의 파일로 빼고 그 별도의 파일을 읽어 오는것을 통해 welcome이라는 함수를 사용할 수 있다면 복잡한 코드가 한줄로 바뀔 수 있다.&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;    &lt;meta charset=\"utf-8\"/&gt;&lt;/head&gt;&lt;body&gt;    &lt;script&gt;        function welcome(){            return 'Hello world'        }        alert(welcome());    &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;아래 예제에서 별도의 파일로 js를 불러오는 형식을 알아보자. 아래 내용을 코드를 에디터를 활용해 실행해보자. greeting.js 라는 파일에 위 예제에서 사용한 function함수를 저장하고 불러오는 형식이다.&lt;script type=”text/javascript” src=”greeting.js”&gt;&lt;/script&gt; 그다음 welcom함수를 호출하면 greeting.js파일에서 불러오게 된다. 다른 html파일에서도 마찬가지로 위 코드로 불러와 함수를 사용할 수 있다.&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;    &lt;meta charset=\"utf-8\"/&gt;    &lt;script type=\"text/javascript\" src=\"greeting.js\"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;    &lt;script&gt;        alert(welcome());    &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;3.node.js의 모듈화모듈을 로드하는 방법은 호스트 환경에 따라서 달라진다. Node.js에서는 아래와 같은 방법으로 모듈을 로드한다.var PI = Math.PI;  exports.area = function (r) {return PI * r * r;};  exports.circumference = function (r) {return 2 * PI * r;};var circle = require('./node.circle.js');console.log( 'The area of a circle of radius 4 is '           + circle.area(4));4.라이브러리라이브러리는 자주 사용되는 로직을 재사용되기 편리하도록 잘 정리한 일련의 코드들의 집힘을 의미한다고 할 수 있다. 오픈 소스를 통해 만들어진 수많은 라이브러리가 있기 때문에 우리가 만들고자 하는 프로그래밍의 핵심적인 부분이 아니라면 공개되어있는 좋은 라이브러리를 선택하고 잘 사용하는 것은 프로그래밍의 핵심이라고 할 수 있다. Javascript로 웹 브라우저를 제어하는 방법은 기본적으로 웹 브라우저가 제공하는 기능, Javascript가 제공하는 기능을 이용해 모든 것을 다 할 수 있다. 다르게 말하면 웹 브라우저와 Javascript가 제공하지 않는 기능은 전혀 사용할 수 없다. 왜냐하면, 브라우저가 허용하는 기능만을 쓸 수 있기 때문이다. 브라우저의 기능이 너무 다양하고 파편화되어 있기 때문에 라이브러리를 사용한다. 라이브러리는 어떤 목적을 정해놓고 목적을 쉽게 달성할 수 있게 만들어놓은 프로그래밍의 집합이기 때문이다. 우리가 사용해볼 라이브러리는 query다.5. 라이브러리 사용하기jQuery를 이용한 예제와 사용방법을 알아볼 것이다. 하지만 jQuery에 대한 공부를 하는것 보다 어떻게 사용하는지에 대한 예제 이기 때문에 jQuery강의를 보고 공부를 해야한다. 아래 코드list에있는 empty를 한번에 coding paratice gym으로 바꾸는 예제이다. 아래의 상태에서&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt;    &lt;meta charset=\"UTF-8\"&gt;    &lt;meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\"&gt;    &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt;    &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt;    &lt;ul id=\"list\"&gt;        &lt;li&gt;empty&lt;/li&gt;        &lt;li&gt;empty&lt;/li&gt;        &lt;li&gt;empty&lt;/li&gt;        &lt;li&gt;empty&lt;/li&gt;    &lt;/ul&gt;&lt;/body&gt;&lt;/html&gt;아래 예제 처럼 변경해준다. 아래 jQuery를 사용한 3줄의 코드로 작업을 수행하게 되었다.&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt;    &lt;meta charset=\"UTF-8\"&gt;    &lt;meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\"&gt;    &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt;    &lt;title&gt;Document&lt;/title&gt;    &lt;script type=\"text/javascript\" src=\"./jquery.js\" &gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;    &lt;ul id=\"list\"&gt;        &lt;li&gt;empty&lt;/li&gt;        &lt;li&gt;empty&lt;/li&gt;        &lt;li&gt;empty&lt;/li&gt;        &lt;li&gt;empty&lt;/li&gt;    &lt;/ul&gt;    &lt;input type=\"button\" value=\"execute\" id=\"execute_btn\"/&gt;    &lt;script type=\"text/javascript\"&gt;        $('#execute_btn').click(function(){            $('#list li').text('coding practice gym');        });    &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;하지만 jQuery를 사용하지 않으면 아래 예제처럼 쉽지않은 프로그래밍을 해야한다.&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;body&gt;    &lt;ul id=\"list\"&gt;        &lt;li&gt;empty&lt;/li&gt;        &lt;li&gt;empty&lt;/li&gt;        &lt;li&gt;empty&lt;/li&gt;        &lt;li&gt;empty&lt;/li&gt;    &lt;/ul&gt;    &lt;input id=\"execute_btn\" type=\"button\" value=\"execute\" /&gt;    &lt;script type=\"text/javascript\"&gt;    function addEvent(target, eventType,eventHandler, useCapture) {        if (target.addEventListener) { // W3C DOM            target.addEventListener(eventType,eventHandler,useCapture?useCapture:false);        } else if (target.attachEvent) {  // IE DOM            var r = target.attachEvent(\"on\"+eventType, eventHandler);        }    }    function clickHandler(event) {        var nav = document.getElementById('list');        for(var i = 0; i &lt; nav.childNodes.length; i++) {            var child = nav.childNodes[i];            if(child.nodeType==3)                continue;            child.innerText = 'Coding everybody';        }    }    addEvent(document.getElementById('execute_btn'), 'click', clickHandler);    &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;이번 강의에선 라이브러리가 중요하다는 것을 알아야 한다. 세세하게 어떻게 하는지 알려고 하는 것보단 라이브러리의 장점과 편의성에 초점을 맞추고 이후 나오는 내용에서 자세히 알아볼 시간이 있을 것이다.",
        "url": "/javascript-basic9"
    }
    ,
    
    "javascript-basic8": {
        "title": "Javascript - JavaScript 객체(Object)",
            "author": "AhnSang0915",
            "category": "",
            "content": "JavaScript 객체(Object)1. 객체의 소개와 문법배열은 연관되어 있는 데이터들을 담아내기 위한 그릇이다. 마찬가지로 객체도 연관된 데이터를 담아내는 것에 있어서 유사하다. 하지만 똑같은 그릇이 있다고 쳤을 때 객체도 그릇에 담아내는 것은 같지만 index의 값으로 숫자나 문자를 쓸 수도 있고, 인덱스로 우리가 원하는 데이터를 지정할 수 있다는 것이 둘의 차이점이라고 할 수 있다. 다른 언어에서는 연관배열(associative array) 또는 맵(map), 딕셔너리(Dictionary)라는 데이터 타입이 객체에 해당한다.객체의 생성객체를 만드는 법을 알아보자. 배열은 대괄호로 시작해 대괄호로 끝나지만,객체는 중괄호로 시작해 중괄호로 끝나게 된다. 아래는 데이터값으로 숫자를 썻지만 문자나 다른 데이터를 할당하는 것도 가능하다. 아래 예제에서 ansang은 key(index)가 되고 10은 value(데이터 값)가 된다.var grades = {'ansang': 10, 'sanghyun': 6, 'ansanghyun': 80};            // key : value  key : value  key : value 위의 상태에서 객체를 대표하는 변수를 grades로 지정하고 grades를 호출하면 아래와 같은 값이 나오게 된다.gradesodject {ansang: 10, sanghyun: 6, ansanghyun: 80}아래는 객체를 만드는 다른 방법이다.var grades = {};grades['ansang'] = 10; //key는 ansang value는 10grades['sanghyun'] = 6; //key는 sanghyun value는 6grades['ansanghyun'] = 80; //key는 ansanghyun value는 80위에선 객체를 호출하는 방법은 아래와 같다. 아무래도 garade.ansang가 간편하지만, 프로그래밍 적인 기재가 불가능하다 이 경우 garade.’an’+’sang’로 호출하게 되면 SyntaxError가 나오게 된다. 즉 . 뒤의 내용을 프로그래밍 적으로 만들 수 없다. []안에 들어가는 값은 프로그래밍 적으로 생성이 가능하기 때문에 필요에 따라 대괄호 안에 작성하는 게 편리하거나 써야만 하는 상황이 있을 수 있다.grades['ansang'] //value 10garade.ansang //value 10grades['an'+'sang'] //value 102.객체와 반복문 for in객체에 저장된 데이터를 기준으로 반복하는 작업을 알아보자. 배열은 저장된 데이터들이 순서를 가지고 있다. 그래서 배열에선 순서 자체가 중요한 정보이다. 하지만 객체엔 순서가 없고, key와 value로 이루어져 있기 때문에 저장된 순서는 없기 때문에 저장된 값이 순서에 따라서 나오지 않을 것 이라는 걸 인지해야 한다.var grades = {'ansang' : 10, 'sanghyun' : 6, 'ansanghynu' : 80}for(key in grandes) {    document.write(\"key : \"+key+\" value : \" + grades[key] + \"&lt;br /&gt;\");}/*출력key : ansang value : 10key : snaghyun value : 6key : ansanghyun value : 80*/또는 key부분을 변수로 바꿔도 된다. 아래는 var name으로 바꿔보았다.var grades = {'ansang' : 10, 'sanghyun' : 6, 'ansanghynu' : 80}for(var name in grandes) {    document.write(\"key : \"+name+\" value : \" + grades[name] + \"&lt;br /&gt;\");}/*출력key : ansang value : 10key : snaghyun value : 6key : ansanghyun value : 80*/더 보기 편하게 리스트 형태로 만들어보자. html에서의 ul태그와 li태그를 사용해본다.  &lt;ul&gt;    &lt;script type=\"text/javascript\"&gt;        var grades = {'ansang': 10, 'sanghyun': 6, 'ansanghynu': 80};            for(var name in grades) {            document.write(\"&lt;li&gt;key : \"+name+\" value : \"+grades[name]+\"&lt;/li&gt;\");            }        &lt;/script&gt;  &lt;/ul&gt;        /* 출력        -key : ansang value : 10        -key : snaghyun value : 6        -key : ansanghyun value : 80        */배열도 for in문으로 사용할수 있다. 배열에선 var name으로 지정한 값이 index가 됨으로 console.log(name)에서 012라는 index가 추출되고 console.log(arr[name])에선 abc라는 데이터가 출력된다.var arr = ['a', 'b', 'c']for(var name in arr) {    console.log(name);}//출력 //0//1//2for(var name in arr) {    console.olg(arr[name]);}3. 객체 지향 프로그래밍객체 지향 프로그래밍이란 서로 연관되어있는 데이터와 처리형식을 하나의 그릇안에 그룹핑 해놓은 프로그래밍을 객체 지향 프로그래밍 이라한다.객체에 담길 수 있는 값이 무엇지에 대해 알아보자. 아래 예제는 객체 안에 객체와 함수를 담았다. list라는 key 값에 {‘ansang’ : 10, ‘sanghyun’ : 8, ‘ansanghyun’ : 80}라는 value를 넣었고 이 value는 객체이다. show라는 key값에 function(){ alert(‘Hello World’)}; 라는 value를 담았다. javascript에서는 함수도 일종의 값이고 함수도 변수에 저장될 수 있기 때문에 마찬가지로 값으로서의 함수도 객체 안에 저장될 수 있다(고하는데 아직 뭔 소린지 모르겠음).grades에 담긴var grades = {    'list' : {'ansang' : 10, 'sanghyun' : 8, 'ansanghyun' : 80},    'show' : function(){        alert('Hello World');    }}alert(grades['list']['ansang']); //ansang이라는 key가 갖고있는 10이라는 value에 접근alert(grades['show']); // 함수에 접근this라는 키워드를 알아보자. this라는 것은 javascript에서 약속되어있는 변수이다. this 변수는 함수가 속해있는 객체를 가르치는 변수이다. 함수가 소속되어있는 객체를 가르친다는 말이다.아래 예제는 grades라는 객체가 갖고있는 key 값 중 show를 호출해 show 함수가 가진 this변수로 list객체{‘ansang’ : 10, ‘sanghyun’ : 8, ‘ansanghyun’ : 80}를 출력하게 된다.var grades = {    'list' : {'ansang' : 10, 'sanghyun' : 8, 'ansanghyun' : 80},    'show' : function(){        alert(this.list);    }}grades['show']();이번엔 개발자 도구에서 console.log(name, this.list[name]);를 사용해 key와 value를 호출해보자. value를 호출하는 방법은 위에서 배웠듯,  grades[‘ansang’] , garade.ansang 두가지가 있다. for in 문을 사용했기 때문에 list[name]을 사용하면 value 값을 불러올 수 있다.var grades = {    'list' : {'ansang' : 10, 'sanghyun' : 8, 'ansanghyun' : 80},    'show' : function(){        for(var name in this.list){            console.log(name, this.list[name]); // ,를 쓰게되면 여러 값을 출력할 수 있다.        }    }}grades.show();",
        "url": "/javascript-basic8"
    }
    ,
    
    "javascript-basic7": {
        "title": "Javascript - JavaScript 배열",
            "author": "AhnSang0915",
            "category": "",
            "content": "JavaScript 배열1. 배열의 문법배열배열(array)이란 연관된 데이터를 모아서 통으로 관리하기 위해 사용하는 데이터의 형식이다. 변수는 하나의 데이터를 저장하기 위한 것이라면 배열은 여러 개의 데이터를 하나의 변수에 저장하기 위해 사용한다. 아래 코드는 name이라는 변수에 ‘Ahnsang’이라는 데이터를 할당한 것이다.var name = 'Ahnsang'alert(name);배열의 생성위에선 변수에 하나의 데이터를 할당 했다. 이제 배열로 여러개의 데이터를 변수에 할당하는 방법을 공부해 보자.여러개의 데이터를 할당 하려면 변수명 = 뒤에 [] 대괄호를 사용해 여러개의 데이터를 작성할 수 있다.var member = ['Ahnsang', 'SangHyun', 'AhnSangHyun']이 각각의 데이터를 요소,또는 원소(Element)라고 부르고 이제 이 원소들을 호출할것이다. 요소는 순서대로 0,1,2의 고유한 값,식별자를 가지게 된다. 색인 이라고도 하고 index라고도한다.var member = ['Ahnsang', 'SangHyun', 'AhnSangHyun']alert(member[0]);alert(member[1]);alert(member[2]);코드를 실행하면 차례대로 ‘Ahnsang’, ‘SangHyun’, ‘AhnSangHyun’ 세개의 데이터를 차례로 경고창에 출력해준다.2. 배열의 효용성배열이 없다면 변수에 하나의 데이터만 할당할수 있기 때문에 불편할 것이다. 아래의 예제를 보자.함수는 여러개의 입력값을 받을 수 있지만, 하나의 출력만 할 수 있다.function get_member1(){    return 'Ahnsang';}document.write(get_member1()); function get_member2(){    return 'SangHyun';}document.write(get_member2());  function get_member3(){    return 'AhnSangHyun';}위 코드처럼 배열을 사용하지 않으면 각각의 회원정보를 반환하는 함수로 표한해야한다. 배열을 사용해 코드를 만들어 보자. return 안에 배열을 사용해 각각의 색인으로 원하는 정보를 호출할 수 있다.function get_members() {    return ['Ahnsang', 'SangHyun', 'AhnSangHyun']}var members = get_members();document.write(members[0]);document.write(members[1]);document.write(members[2]);3. 배열의 사용 - 배열과 반복문우리가 배열을 사용해 index값을 호출할때 그 값을 일일히 기억해서 호출한다는것은 불가능하다. 배열이 몇백 몇천개가 사용될수도 있기 때문이다. 그렇기 때문에 배열이란 결국 배열에 담겨있는 값을 하나하나 꺼내서 그꺼내진 값을 가공하는게 배열의 핵심적인 요소라고 할수있다.아래 예제에서 출력값을 대문자로 출력하려고 .toUpperCase();라는 javascript내장함수를 사용해 출력했다.‘AHNSANG’,’SANGHYUN’,’AHNSANGHYUN’을 출력하게 될것이다.function get_members() {    return ['Ahnsang', 'SangHyun', 'AhnSangHyun']}var members = get_members();document.write(members[0].toUpperCase()+\"&lt;br /&gt;\");document.write(members[1].toUpperCase()+\"&lt;br /&gt;\");document.write(members[2].toUpperCase()+\"&lt;br /&gt;\");위 예제 처럼 우리가 직접 손으로 배열을 호출을 하기엔 무리가 있다. 이때 사용할 수 있는 방법이 배열과 반복문을 결합하는 것이다. 그전에 한가지 예제를 더 보자. 아래 예제는 배열의 값이 몇개인지 나타내 주는 함수이다. 경고창 내용은 3을 출력하게 된다.var a = ['Ahnsang', 'SangHyun', 'AhnSangHyun']alert (a.length);이제 배열과 반복문을 결합한 예제를 보자. i란변수를 지정하고 시작은 0에서 1씩 증가해 2로 끝나게 된다. 이렇게 나온 0, 1, 2는 index 값으로 사용하고, members[index값]에 i의 값이 어가게 되어 차례로 출력할 수 있게 된다.’AHNSANG’,’SANGHYUN’,’AHNSANGHYUN’을 출력하게 될것이다.function get_members() {    return ['Ahnsang', 'SangHyun', 'AhnSangHyun']}var members = get_members();for(var i = 0; i &lt; 3; i++) {    document.write(members[i].toUpperCase()+\"&lt;br /&gt;\");}그런데 여기서 배열의 갯수가 늘어난다면 우리는 반복문의 조건을 수정해야한다. 이것도 함수를 사용해 더 편리하게 만들어 보면, 우리는 members라는 변수에 get_members라는 함수를 호출했다. 그 함수안에 return의 배열이 들어있기 때문에 members.length함수를 사용하면 배열안의 요소의 갯수를 호출해 사용할 수 있다.function get_members() {    return ['Ahnsang', 'SangHyun', 'AhnSangHyun']}var members = get_members();for(var i = 0; i &lt; members.length; i++) {    document.write(members[i].toUpperCase()+\"&lt;br /&gt;\");}4. 배열의 제어배열은 복수의 데이터를 효율적으로 관리, 전달하기 위한 목적으로 고안된 데이터 타입이다. 따라서 데이터의 추가/수정/삭제와 같은 일을 편리하게 할 수 있도록 돕는 다양한 기능을 가지고 있다. 몇가지 중요한 기능들만 살펴보자.배열의 조작 - 추가 push배열의 끝에 원소를 추가하는 방법을 알아보자. push는 인자로 전달된 값을 배열에 추가하는 javascript 내장함수 이다. 아래 코드를 실행하면 “f”가 추가된 배열이 출력된다.var li = ['a', 'b', 'c', 'd', 'e'];li.push('f');alert(li);아래의 함수와 위의 함수는 같다.function numbering() {    var i = 0;    while(1 &lt; 10) {        document.write(i);        i += i;    }}아래 함수는 이름을 정하지도 않고 변수도 붙이지 않았다. 함수를 정의하고 함수를 괄호로 묶었다. 그다음에 호출할때 사용하는 기호 ();로 호출하게 되면 정의와 호출을 하나의 문장으로 같이하는 함수로 익명함수라고 한다. 일회 성으로 호출할때 이런 함수를 사용한다.(function(){    i = 0;    while(i &lt; 10){        document.write(i);        i += 1;    }   }) ();배열의 추가 concatconcat(concatenate)은 복수의 원소를 배열에 추가하는 방법이다. 추가한 출력은 [‘a’, ‘b’, ‘c’, ‘d’, ‘e’,’f’, ‘g’] 가된다.var li = ['a', 'b', 'c', 'd', 'e'];li = li.concat(['f', 'g']);alert(li);배열의 추가 unshiftunshift는 배열의 시작점에 원소를 추가하는 방법이다. 출력은 [‘z’,’a’, ‘b’, ‘c’, ‘d’, ‘e’] 가되고 index도 0~5로 변경된다.var li = ['a', 'b', 'c', 'd', 'e'];li.unshift('z');alert(li);배열의 추가 splicesplice는 배열의 특정구간을 추출하거나, 특정구간에 특정 배열을 추가하는 방법이다. 문법은 아래와 같고,array.splice(index, howmany, element1, ...., elementN);아래 표를 보면서 이해해보자.            인자명      데이터형      필수/옵션      설명                  index      number      필수      배열에 추가할 특정 배열의 위치를 가르키는 index              howmany      number      필수      index에서부터 제거될 원소들의 수. index부터 index+howmany에 해당하는 원소들은 삭제된다. 이 값이 0이면 어떠한 원소도 삭제되지 않는다.              element1,…,elementN      number      옵션      index와 index+howmany 사이에 추가될 값      아래와 같이 splice를 이용해 배열에 ‘x’,’y’를 추가하는 코드가 있다. splice뒤에 오는 1은 [a,b,c] 배열에서 ‘b’를 가르키고 0은 ‘b’를 제거하지 않고 index 1번 위치에 ‘x’,’y’를 추가하겠다는 말이다.이러면 배열은 [‘a’,’x’,’y’,’b’,’c’] 가된다.var a = ['a','b','c']a.splice(1,0,['x','y'])이번엔 기존 배열을 삭제하고 추가하는 예제를 보자. index 1번자리에 있는 ‘b’의 자리에서 2개의 원소를 삭제하고 [‘x’,’y’]를 순서대로 넣어주겠다는 말이다. 변경된 배열은 [‘a’ , ‘x’, ‘y’]가 된다.var a = ['a','b','c']a.splice(1,2,['x','y'])몇가지 예제를 더보자.var numbers = [1,2,3,4,5,6,7,8,9,10];alert(numbers.splice(2)); //2번 index를 포함 이후의 모든 요소를 제거한다.alert(numbers); // [1,2] var numbers = [1,2,3,4,5,6,7,8,9,10];alert(numbers.splice(2, 4)); // array, [3,4,5,6] var numbers = [1,2,3,4,5,6,7,8,9,10];alert(numbers.splice(2, 4, 'three', 'four', 'five', 'six')); // array, [3,4,5,6]alert(numbers); // array, [1,2,three,four,five,six,7,8,9,10]5. 배열의 조작 - 제거, 정렬제거 shiftshift는 배열의 첫번째 원소를 제거하는 방법이다. index 0번에 위치한 원소를 제거하고 나머지 값들을 한칸씩 앞으로 당겨온다. 만약 배열의 length가 0이면 undefined을 리턴한다. 아래 예제의 결과는 b, c, d, e다.var li = ['a', 'b', 'c', 'd', 'e'];li.shift();alert(li);제거 poppop은 배열의 마지막 원소를 제거하는 방법이다. 마지막 index에 위치한 원소를 제거하고 마찬가지로 빈 배열이라면 undefined을 리턴한다.var li = ['a', 'b', 'c', 'd', 'e'];li.pop();alert(li);정렬 sort배열을 이용하는 중요한 이유중 하나가 정렬이다. sort는 배열의 정렬을 하고싶을때 사용한다.var li = ['c', 'e', 'a', 'b', 'd'];li.sort();alert(li);하지만 만약 배열이 [‘1’, ‘10’, ‘6’] 인경우엔 정렬이 1, 10, 6이 된다. 데이터를 문자로 보기때문에 앞에 1이 온 10을더 작다고 보는것이다. 이것을 올바르게 정렬하려면 아래와 같은 예제를 사용한다.function sortNumber(a,b){    return a-b; //역순을 구한다면 b-a를 활용한다.}var numbers = [20, 10, 9,8,7,6,5,4,3,2,1];alert(numbers.sort(sortNumber)); // array, [1,2,3,4,5,6,7,8,9,10,20]위 함수 a-b; 부분을 이해하려 찾아보았다. 정확하게 javascript에서 어떤 알고리즘으로 작동하는지 모르지만 이런 식으로 작동할 것이라는 글을 보게 되었다.만약 5,4,6,1,3,2 라는 배열이 있다고 가정하자.a-b에서 양수면 위치를 바꾸고 음수면 유지한다.5-4는 양수로 위치를바꾼다.4,5,6,1,3,24-6은 음수로 유지.4,5,6,1,3,24-1은 양수로 변경.1,5,6,4,3,21-3,1-2도 음수로 자리를 유지하고 index0번위치에 1이 오게된다.이제 1,5,6,4,3,2에서 두번째 자리를 찾는다.5-6은 음수로 유지.1,5,6,4,3,25-4는 양수로 변경.1,4,6,5,3,24-3은 양수로 변경.1,3,6,5,4,23-2는 양수로 변경.1,2,6,5,4,3 두번째 자리를 찾았다.….…이런 식으로 반복해서 찾는다는 글을 봤는데 맞는진 모르겠지만 이렇게 이해하면 좋을 것 같다.정렬 reversereverse는 역순으로 정렬하고 싶을때 사용한다.var li = ['c', 'e', 'a', 'b', 'd'];li.reverse();alert(li);",
        "url": "/javascript-basic7"
    }
    ,
    
    "javascript-basic6": {
        "title": "Javascript - JavaScript 함수",
            "author": "AhnSang0915",
            "category": "",
            "content": "JavaScript 함수1. 함수란?함수(function)란 javascript에서 기본적인 구성 블록중 하나로, 작업을 수행하거나 값을 계산하는 문장 집합같은 절차이다. 함수는 하나의 로직을 재실행 할 수 있도록 하는것으로 코드의 재사용성을 높여준다.함수의 형식함수(function)의 형식은 아래와같다.function 함수명( [인자...[,인자]] ){   코드 내용   return 반환값}함수의 정의와 호출함수(function) 뒤에 함수의 이름이 오고, 소괄호가 따라온다. 우리가 변수를 호출하려면 변수를 정의하고 값을할당한후 그 변수를 호출해야한다. 함수도 마찬가지로 함수를 정의했으면 정의한 함수를 호출해야한다. 변수는 변수 이름만으로 호출하지만 함수는 함수명 뒤 (); 를 붙여줘야한다. ();를 붙이지 않으면 javascript는 변수로 인식하기 때문에 꼭 써줘야한다.function numbering() {    document.write(1);}numbering();다음 예제를 보자. 이 함수의 이름은 numbering이고, 내용은 0부터 9까지를 화면에 출력한다.function numbering(){    i = 0;    while(i &lt; 10){        document.write(i);        i += 1; // i = i + 1; 과 같다    }   }numbering();2. 함수의 효용성만약 함수가 없이 0~9까지의 코드를 출력하려고 하려고 하면 아래와 같이 하면 될것이다.var i = 0while(i &lt; 10&gt;){    document.write(i);    i +=1;}var i = 0while(i &lt; 10&gt;){    document.write(i);    i +=1;}var i = 0while(i &lt; 10&gt;){    document.write(i);    i +=1;}var i = 0while(i &lt; 10&gt;){    document.write(i);    i +=1;}var i = 0while(i &lt; 10&gt;){    document.write(i);    i +=1;}그런데 위의 코드를 0에서19까지로 바꿔야한다면 while(i &lt; 10&gt;) 부분을 while(i &lt; 20&gt;)으로 바꿔줘야 한다. 5번만 호출한다면 어렵지 않겠지만 많은 횟수를 호출하는 상황에선 어려운 작업이 될것이다. 이럴때 함수를 쓰면 1에서19까지를 1000번을 호출해도 아래와 같이 간단히 바꿀수 있다.funtion numbering() {    while(i &lt; 20&gt;){    document.write(i);    i +=1;}for(var i = 1; i &lt; 1000; i++){    numbering();}물론 함수를 사용하지 않고 for문과 while로도 호출이 가능하다.for(var i = 1; i &lt; 1000; i++){    var i = 0;    while(i &lt; 20&gt;){        document.write(i);        i +=1;    }}위의 두코드의 차이점은 반복문은 반복문 안에서만 실행이 되고 함수는 다른 여러곳에서도 호출하여 사용할 수 있다는 점이다. 핵심은 재사용성이고 이말은 이 함수를 사용하고 있는 여러곳 에서 이함수의 내용을 변경, 개선한다고 하면 함수만 변경하면 사용하는 여러곳 에서 변경이되기 때문에 유지보수가 용이하게 된다.3. 함수의 입력과 출력함수의 핵심은 입력과 출력이다. 입력된 값을 연산해서 출력하는 것이 함수의 기본적인 역할이다. 다음은 함수에서 입력과 출력의 역할을 하는 구문들에 대한 설명이다.함수의 출력return함수 내에서 사용한 return은 return 뒤에 따라오는 값을 함수의 결과로 반환한다. 동시에 함수를 종료시킨다. 아래 내용을 보자. 결과는 egoing과 k8805다.function get_member1(){    return 'egoing';} function get_member2(){    return 'k8805';} alert(get_member1());alert(get_member2());아래 함수를 실행시켜보면 ‘egoing’만 출력하고 함수가 종료된다. return뒤의 내용은 출력하지 않는다.function get_member(){    return 'egoing';    return 'k8805';    return 'sorialgi';}alert(get_member());인자인자(argument)는 함수로 유입되는 입력 값을 의미하는데, 어떤 값을 인자로 전달하느냐에 따라서 함수가 반환하는 값이나 메소드의 동작방법을 다르게 할 수 있다. 다음 예를보자.앞에서본 함수와는 다르게 함수명 뒤에 1과 2가 들어가있다. 이말은 get_argument라는 함수를 호출할때 숫자 1과2를 넣어준다는 말이 된다. 숫자가 들어가는 arg는 변수가된다. arg=1, arg=2라는 뜻이 되는것이다. return이지만 2번을 호출했기 떄문에 1000,2000 의 값이 출력 된다.function get_argument(arg){ //arg는 매개변수 또는 parameter라고 부른다.    return arg*1000;} alert(get_argument(1)); // 1과 2를 인자 argument라고 한다.alert(get_argument(2));복수의 인자인자를 여러개의 사용할수도 있다. 첫번째 두번째 인자가 차례로 arg1와 arg2로 들어가게 되고 30 , 50의 값이 출력 되게 된다.function get_arguments(arg1, arg2){    return arg1 + arg2} alert(get_arguments(10, 20));alert(get_arguments(20, 30));4. 다양한 함수 정의 방법함수를 정의하는 다른 방법을 알아보자.우리가 위에서 작성한 함수와는 조금 다르다. function내의 함수 내용이 numbering이라는 변수에 대입되어 변수가 함수를 가지게 된것이다.var numbering = function (){    i = 0;    while(i &lt; 10){        document.write(i);        i += 1;    }   }numbering();아래의 함수와 위의 함수는 같다.function numbering() {    var i = 0;    while(1 &lt; 10) {        document.write(i);        i += i;    }}아래 함수는 이름을 정하지도 않고 변수도 붙이지 않았다. 함수를 정의하고 함수를 괄호로 묶었다. 그다음에 호출할때 사용하는 기호 ();로 호출하게 되면 정의와 호출을 하나의 문장으로 같이하는 함수로 익명함수라고 한다. 일회 성으로 호출할때 이런 함수를 사용한다.(function(){    i = 0;    while(i &lt; 10){        document.write(i);        i += 1;    }   }) ();",
        "url": "/javascript-basic6"
    }
    ,
    
    "javascript-basic5": {
        "title": "Javascript - JavaScript 반복문",
            "author": "AhnSang0915",
            "category": "",
            "content": "JavaScript 반복문1. 반복문 기본문법-while반복문(Loop iterate)은 사람이 하기힘든 반복 작업을 하기위해 사용하고, 몇가지 문법이 있다.whilewhile의 형식은 아래와같다. 조건이 true인 동안에 { } 안의 데이터를 반복하게 된다.while (조건){    반복해서 실행할 코드}2. 반복조건반복조건이 없다면 반복문이 무한대로 실행이되게된다. 반복조건을 설정해 적당한 시기에 반복이 정지하도록 해줘야한다.아래 예제는 i의 시작값을 0으로 정했고 한번씩 반복 할때마다 ‘coding everybody ‘문장이 실행되고 i가 1씩 늘어나게 된다. i의 값이 9가되면 반복을 멈추게 된다.var i = 0;while(i &lt; 10){    document.write('coding everybody &lt;br /&gt;');    i++}3. for문for문의 형식은 아래와 같다. while 과 for문은 둘다 반복문이고 대체가능하다.for(초기화; 반복조건; 반복이 될 때마다 실행되는 코드){    반복해서 실행될 코드}for(var i = 0; i &lt; 10; i++){   // i = i + 1 과 i ++는 같다.    document.write('coding everybody'+i+'&lt;br /&gt;');}i++는 해당 구문을 실행할때마다 i값을 1씩 증가시킨다는 말이다. i=0이라고 시작하면 0부터 시작하게 된다.++i는 해당 구문을 실행할때부터 1을 증가시킨채 실행한다. i=0이라고하면 시작부터 1로 시작한다.4. 반복문의 효용성반복문이 없다면 코드를 복사해서 붙여넣기 하면 된다. 하지만 반복 횟수가 많아지면 많아질수록 힘들어질 것이다. 아래 예제의 두 코드는 같은 내용이다. 어떤 작업이 더 편할까?document.write('coding everybody');document.write('coding everybody');document.write('coding everybody');document.write('coding everybody');document.write('coding everybody');document.write('coding everybody');document.write('coding everybody');document.write('coding everybody');document.write('coding everybody');document.write('coding everybody');document.write('coding everybody');var i = 0;while(i &lt; 10){    document.write('coding everybody &lt;br /&gt;');    i++;}그런데 ‘coding everybody’뒤에 순서를 써야하고 그 양이 많다면 불가능해 질것이다. 반복문으로 코드를 작성하면 간단하다.var i = 0;while(i &lt; 10) {    document.write('coding everybody' + i + &lt;br/&gt;);}5. 반복문의 제어반복문을 강제 정지시키거나 정지후 재시작 하기위한 명령어를 알아보자.breakbreak는 반복문을 중간에 중단시키게 해준다. 아래 예제는 0~4까지 출력하고 중단하게 된다.for(var i = 0; i &lt; 10; i++){    if(i === 5) {        break;    }    document.write('coding everybody'+i+'&lt;br /&gt;');}continuecontinue는 지정된 부분에선 반복을 중단하고 반복을 재시작할 수 있게 해준다. 아래의 코드를 실행해보자.for(var i = 0; i &lt; 10; i++){    if(i === 5) {        continue;    }    document.write('coding everybody'+i+'&lt;br /&gt;');}i===5에서 continue를 하겠다고 했기때문에 i의 값이 5가되었을 때는 실행을 중단하고 다음 i값부터 다시 반복하게 된다.coding everybody 0coding everybody 1coding everybody 2coding everybody 3coding everybody 4coding everybody 6coding everybody 7coding everybody 8coding everybody 96. 반복문의 중첩사용과 디버거반복문안에 반복문을 중첩해 사용할수 있다. 아래 예제에선 i와j를 0~9까지 반복하고 그i와j는 숫자이고 숫자끼리 더해지게 되는데 아래 처럼 문자열과 숫자의 결합하는 경우 javascript는 숫자인 부분을 문자로 변환해 준다.for(var i = 0; i &lt; 10; i++){    for(var j = 0; j &lt; 10; j++ ) {    document.write('coding everybody' + i + j + '&lt;br /&gt;');    }}위코드를 실행해 보면 00~99까지의 i와j가 출력된다.디버거우리가 만든 코드의 버그를 확인하고 코드 실행 순서를 볼 수 있는 기능을 알아보자. F12키를 눌러 개발자도구를 열고 console로 들어가 보고자 하는 줄의 코드를 선택하고 F5를 눌러 새로고침한다.그리고 버튼을 활용해 실행 순서를 확인해 보자.",
        "url": "/javascript-basic5"
    }
    ,
    
    "javascript-basic4": {
        "title": "Javascript - JavaScript 조건문",
            "author": "AhnSang0915",
            "category": "",
            "content": "JavaScript 조건문1. 조건문이란?조건문(Conditional statement)은 if로 시작한다.if뒤에는 반드시 true나 false로 두개의 값중에 하나가 온다. 그뒤 중괄호안에 조건이 들어오게 된다.아래의 예제는 true를 출력할것이다. if뒤가로에 true가 오게되면 중괄호 안의 내용이 실행된다.if(true){    alert('result : true');이번엔 아무것도 출력하지 않는다. if뒤에 false가오면 중괄호 안의 내용을 실행하지 않는다.if(false){    alert('result : true');12345를 출력 할것이다.if(true){    alert(1);    alert(2);    alert(3);    alert(4);}alert(5);5만 출력한다. false기 때문에 중괄호 안의 내용은 실행하지 않는다.if(false){    alert(1);    alert(2);    alert(3);    alert(4);}alert(5);2. else, else ifif만으로는 조건문을 사용하는데에 제약이 있다. else와 else if는 더 다양하게 조건문을 응용할 수 있게 해준다.elseif뒤 true가 있다면 중괄호 안의 내용이 실행이 되고, else는 실행이 되지 않는다. 만약에 참 이라면 if중괄호가 실행후 else는 무시하고 결과는 1이된다.if(true){    alert(1);} else {    alert(2);}if뒤에 false가 있다면 중괄호 안의 내용이 실행이 안되고, 만약에 거짓이라면 else가 실행이 된고 결과는 2다.if(false){    alert(1);} else {    alert(2);}else if아래 코드에 대한 해석을 해보자. 1번에서 if뒤의 false로 2번alert(1)이 실행되지 않고 다음으로 넘어간다. 3번코드 else에선 1번에서 if가 false기 때문에 실행이 되고 else뒤의 if가 true이기 때문에 2라는 값이 출력된다. 4번이 실행 되었기 때문에 5와 7의 else가 실행될수 없다. 그대로 2만 출력 할 것이다.if(false){       //1    alert(1);    //2} else if(true){ //3    alert(2);    //4} else if(true){ //5    alert(3);    //6} else {         //7    alert(4);    //8}아래 코드도 해석해보면 3이 출력된다는 걸 알 수 있다.if(false){    alert(1);} else if(false){    alert(2);} else if(true){    alert(3);} else {    alert(4);}아래 코드도 해석해보면 4가 출력된다는 걸 알 수 있다.if(false){    alert(1);} else if(false){    alert(2);} else if(false){    alert(3);} else {    alert(4);}3. 조건문의 응용변수와 비교연산자if(true) {    alert(1);}위와 같은 코드는 javascript에서 쓸일이 없다. 무조건 1이 출력이 되기 때문이다. 조건문과 변수가 만나 상황에 따라 가변적인 요소가 되어야 조건문이라 할수 있다. prompt라는 구문을 사용해야 하는데 prompt는 사용자가 입력한 값을 가져와서 변수의 값으로 대입해준다. 예제를 통해 더 알아보자.&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;    &lt;meta charset=\"utf-8\"/&gt;&lt;/head&gt;&lt;body&gt;    &lt;script&gt;        id = prompt('아이디를 입력해주세요.') //prompt를 통해 사용자가 입력한 값을 id라는 변수에 적용        if(id=='Ahnsang'){            alert('아이디가 일치 합니다.')        } else {            alert('아이디가 일치하지 않습니다.')        }    &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;위의 예제를 응용해 아이디와 비밀번호 모두 사용하게 해보자. 아이디가 일치하면 비밀번호를 물어볼 필요가 없다. id 변수에 입력한 값이 if id의 조건문에서 아이디가 일치한다면 if password에서 prompt를 통해 비밀번호를 요구한다. 그렇게 되면 입력한 비밀번호가 password라는 변수에 담겨서 입력 값과 111111라는 password와 일치하면 로그인 하셨습니다. 다르다면 비밀번호가 다릅니다라는 메세지가 나오게 된다.&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;    &lt;meta charset=\"utf-8\"/&gt;&lt;/head&gt;&lt;body&gt;    &lt;script&gt;        id = prompt('아이디를 입력해주세요.');        if(id=='Ahnsang'){            password = prompt('비밀번호를 입력해주세요.');            if(password==='111111'){                alert('로그인 했습니다.');            } else {                alert('비밀번호를 확인해 주세요.');            }        } else {            alert('아이디를 확인해 주세요.');        }    &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;4. 논리 연산자논리 연산자는 조건문을 더 간결하고 다양하게 사용할수 있다.&amp;&amp;&amp;&amp;는 좌항과 우항이 모두 참(true)일때 참이된다. 아래 예제에선 1이라는 값이 출력된다. 이러한 연산자를 and연산자라고 한다.if(true &amp;&amp; true){    alert(1);}if(true &amp;&amp; false){    alert(2);}if(false &amp;&amp; true){    alert(3);}if(false &amp;&amp; false){    alert(4);}아래 예제에선 논리연산자 중 and연산자를 활용한 것 이다. 두 변수를 동시에 호출하기 위해 id와 password를 prompt로 호출해주고 &amp;&amp; 연산자로 둘의 값이 모두 참일때만 ‘인증했습니다.’라는 메세지를 출력 하게되고 하나라도 다르다면 ‘인증에 실패 했습니다.’ 라는 값을 출력하게 된다. and연산자는 2개 이상도 사용할 수 있다.&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;    &lt;meta charset=\"utf-8\"/&gt;&lt;/head&gt;&lt;body&gt;    &lt;script&gt;        id = prompt('아이디를 입력해주세요.');        password = prompt('비밀번호를 입력해주세요.');        if(id=='Ahnsang' &amp;&amp; password=='111111'){            alert('인증 했습니다.');        } else {            alert('인증에 실패 했습니다.');        }    &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;||||는 ||의 좌우항 하나라도 참이라면 참이 되고 둘다 거짓일때 거짓이 되는 연산자 이다. 예제는 1, 2, 3이 출력되고 ||는 or연산자 라고 한다.if(true || true){    alert(1);}if(true || false){    alert(2);}if(false || true){    alert(3);}if(false || false){ //둘다 false기 때문에 false    alert(4);}아래 예제는 Ahnsang, Ahnsang1, Ahnsang2 값중 하나라도 변수값에 들어오면 ‘인증 했습니다.’라는 값을 출력하게 될것이다.id = prompt('아이디를 입력해주세요.');if(id==='Ahnsang' || id==='Ahsang1' || id==='Ahnsang2'){    alert('인증 했습니다.');} else {    alert('인증에 실패 했습니다.');}다음예제는 or와 and를 사용하는 방법이다.id 비교를 할 때 괄호를 사용한 것은 사칙 연산을 할 때 괄호부터 계산하는 것과 같은 원리다. 세개의 id중 하나라도 맞고 password가 111111이면 로그인 했습니다 라는 값이 출력된다.id = prompt('아이디를 입력해 주세요')password = prompt('비밀번호를 입력해 주세요.')if(id === 'Ahnsang' || id === 'Ahnsang1' || id === 'Ahnsang2' &amp;&amp; password = '111111') {    alert('로그인 했습니다.')}   else {    alert('로그인 실패 했습니다.')}!!는 부정의 의미로 true나 false 앞에 !를 붙이면 값을 역전시킨다. not 연산자 라고 부른다. 아래 에제에서 !를 사용하면 어떻게 되는지 확인하자. 값은 4이다.if(!true &amp;&amp; !true){ //false false 이기 때문에 &amp;&amp;연산자 에선 실행되지 않는다.    alert(1);}if(!false &amp;&amp; !true){ //true false &amp;&amp;는 둘다 참이어야 실행한다.    alert(2);}if(!true &amp;&amp; !false){ //true false &amp;&amp;는 둘다 참이어야 실행한다.    alert(3);}if(!false &amp;&amp; !false){ //true true기 때문에 실행한다.    alert(4);}5.boolean의 대체제0과 1조건문에 사용될 수 있는 데이터 형이 꼭 불린만 되는 것은 아니다. 관습적인 이유로 0는 false 0이 아닌 값은 true로 간주된다. 아래의 예제는 2를 출력한다.if(0){    alert(1)}if(1){    alert(2)}그외의 false로 간주되는 데이터if(!''){    alert('빈 문자열')}if(!undefined){    alert('undefined');}var a;if(!a){    alert('값이 할당되지 않은 변수'); }if(!null){    alert('null');}if(!NaN){    alert('NaN');}",
        "url": "/javascript-basic4"
    }
    ,
    
    "javascript-basic3": {
        "title": "Javascript - JavaScript 변수, 비교",
            "author": "AhnSang0915",
            "category": "",
            "content": "JavaScript 변수, 비교변수1. 변수의 사용법변수(Variable)는 문자나 숫자같은 값을 담는 컨테이너로 값을 유지할 필요가 있을때 사용한다. 담겨진 값은 다른 값으로 바꿀수 있고 var로 변수를 선언할수 있다. 생략도 가능하지만 var의 의미를 명확하게 이해하기 전에는 var를 사용하는 것이 좋겠다. 예제를 보자.var a = 1;alert(a+1);  //2 var a = 2;alert(a+1);  //3var first = \"coding\";alert(first+\" everybody\"); //coding everyday//변수 a에 coding ,변수 b에 everybody를 활당하는 방법은 아래와 같다.var a = 'coding', b = 'everybody';alert(a);alert(b);2. 변수의 효용변수는 코드의 재활용성을 높여준다. 반복해서 100에서 10을 빼고 더하고 나누는 계산을 해야하는 코드가 있다고 가정해보고 변수가 없다면 100에관한 숫자 데이터를 모두 수정해야 할것이다. 여기서 변수를 적용하면 변수 값만 바꿔주면 된다.//변수를 쓰기 전alert(100+10);alert((100+10)/10);alert(((100+10)/10)-10);alert((((100+10)/10)-10)*10);// 변수 사용 후a = 100; //변할수 있는a = a + 10; //변하지 않는alert(a);a = a / 10;alert(a);a = a - 10;alert(a);a = a * 10;      alert(a);변수를 쓰지 않은 코드보다 쓴 코드가 더 길기때문에 비효율 적으로 보일수 있으나 코드가 천줄 만줄이라고 생각하면 변수를 쓰는게 좋을것이다.코딩을 할때 위의 주석처럼 구획을 나누어 놓는게 좋다. 변할수 있는 부분이 군데군데 들어가 있다면 그것을 찾아서 수정해야한다. 그럴경우 유지보수가 힘들어진다.비교1.연산자비교는 조건문을 쓸때 꼭 필요하다. 비교 기능 자체는 효용이 크지 않지만 조건문을 사용하기 위해 꼭 필요하다.연산자란 간단하게 말해 = 이다. 변수에 값을 대입할때 사용한다.a=1 //변수 대입연산자 값2. 비교 연산자 (==과===)비교 연산자는 말그대로 비교하고 판별할때 사용한다. 좌항과 우항중 뭐가 작고 큰지 또는 같은지 등을 판별한다. 비교연산자의 결과는 true나 false둘중 하나다. true와 false형식을 블린 데이터라고 부르고 역시 조건문에서 중요하게 사용한다.== ==는 동등연산자로 좌항과 우항의 값이 같다면 true 다르다면 false가 된다.=와 ==는 전혀 다르기 때문에 주의해야한다.alert(A==B)             //falsealert(A==A)             //truealert(\"one\"==\"two\")     //false alert(\"one\"==\"one\")     //true=== === 일치 연산자라고 하고 좌항과 우항이 정확하게 같을때 같다면 true 다르다면 false가 된다. 여기서 정확하게는 아래 코드처럼 형식까지 일치해야 한다는 말이다. 1과 ‘1’은 숫자와 숫자를 문자화시킨 데이터이다. 결론은 ==보다 ===를 쓰는것이 좋겠다.alert(1=='1');              //truealert(1==='1');             //false3.===를 사용하자null과 undefined는 값이 없다는 의미의 데이터 형이다. var a; 라는 코드를 쓰고 alert(a); 를 하면 undefined라는 경고창이 나온다. 값이 정의되지 않았다는 뜻이다. 그리고 var a=null; alert(a);를 하면null이라는 경고창이 나온다. 이말은 작성한사람이 의도적으로 값이 없다는것을 지정한것이다.이말은 프로그래밍에서 의도한것과 의도하지 않은것은 전혀 다른것이다.alert(null == undefined);       //truealert(null === undefined);      //falsealert(true == 1);               //truealert(true === 1);              //falsealert(true == '1');             //truealert(true === '1');            //false alert(0 === -0);                //truealert(NaN === NaN);             //false NaN(Not-a-Number)은 이값은 숫자가 아님을 의미한다.                   //그래서 NaN생성의 가능성이 있는 코드는 비교 연산을 실행하면 안되겠다.4.부정과 부등호!=!는 부정을 의미한다. 1==2는 false다 하지만 1!=2는 true가 된다. 같지 않은게 사실이기 때문이다.alert(1!=2);            //truealert(1!=1);            //falsealert(\"one\"!=\"two\");    //truealert(\"one\"!=\"one\");    //false!==!==는 ===에 부정을 부여한 것으로 정확하게 같지 않다는 의미이다.&gt;좌항과 우항을 비교해주는 연산자로 좌항이 더 크다는것을 의미한다. 더크면 true 작으면 false이다.&lt;는 반대의 의미이다.alert(10&gt;20);   //falsealert(10&gt;1);    //truealert(10&gt;10);   //false&gt;=좌항이 우항보다 크거나 같다는 의미이다. &lt;=는 반대의 의미이고 =&gt;, =&lt;식의 표현은 불가하다.alert(10&gt;=20);      //falsealert(10&gt;=1);       //truealert(10&gt;=10);      //true",
        "url": "/javascript-basic3"
    }
    ,
    
    "javascript-basic2": {
        "title": "Javascript - JavaScript 숫자와 문자",
            "author": "AhnSang0915",
            "category": "",
            "content": "JavaScript 숫자와 문자1. 수의 표현 javascript는 큰따옴표나 작은 따옴표가 붙지 않은 숫자는 숫자로 인식한다.정수, 자연수, 실수 모두 사용가능하고 모두 숫자로 인식한다.javascript에선 포괄적으로 number라고 부르고 다른 프로그래밍 언어들 보다 덜 엄격한 편이다.수식으로는 더하기는 + 빼기는 - 나누기는 / 곱셈은 * 으로 표현한다.2. 수의 연산javascript는 계산 기능이 있는데 우리가 흔히 쓰는 수식과는 조금 다르기 때문에 그 방법을 알아두는게 좋겠다.아래 코드에 아직 배우지 않은 부분이 있는데 뒤에서 자세히 배워볼 예정이다.Math.pow(3,2);       // 9,   3의 2승 Math.round(10.6);    // 11,  10.6을 반올림Math.ceil(10.2);     // 11,  10.2를 올림Math.floor(10.6);    // 10,  10.6을 내림Math.sqrt(9);        // 3,   3의 제곱근Math.random();       // 0부터 1.0 사이의 랜덤한 숫자3. 문자””,’‘내에 들어가는 내용은 javascript가 문자로 인식한다.데이터를 입력하면 javascript는 문자와 숫자를 인식하게 된다.숫자를 “A”나 ‘A’로 감싸면 문자로 인식하게 된다.우리가 작성한 데이터 값은 typeof 라는 명령을 사용하면 데이터의 형식을 알수있다.문자는 string 숫자는 number라는 결과가 나온다.alert(typeof \"1\") //결과 : string \"내용' 이런식의 기입은 할수 없음을 알아두자.여러줄로 표시하기 위해서는 \\n을 사용할 수 있다.alert(\"왔냐.\\n 코딩 연습장이다\")또한 데이터를 입력하다 보면 ‘이나 “ ex)alert(‘egoing’s coding everyday’) 등을 사용 해야할 때가 이있는데 이럴땐 \\뒤에 해당 기호를 넣어 문자로 인식하게 할수 있다.alert(\"egoing's coding everyday\") // \"\"사이에 '가 들어 있기 때문에 사용 가능하다.arlert('egoing\\'s coding everyday')// 역슬래쉬 \\뒤의 어떠한 기호는 문자로 해석된다. escape라고 한다.4. 문자의 연산1+1은 2이다 하지만 “1”+”1”은 “11”이된다. 숫자와 문자의 연산은 전혀 다르다.문자를 더하는 표현은 아래와 같다.alert(\"Ahns\"+\" Coding Gym\") //결과 : Ahns Coding Gym문자의 길이를 구할때는 문자 뒤에 .length를 붙여준다.alert(\"Ahns Coding Gym\".length) //결과 : 15 ",
        "url": "/javascript-basic2"
    }
    ,
    
    "javascript-basic": {
        "title": "Javascript - JavaScript 기본",
            "author": "AhnSang0915",
            "category": "",
            "content": "JavaScript 기본1. 주석 (Comment)주석은 JavaScript Code외의 우리가 쓰는 문자로 사용되는 내용을 말한다.코드 내용에대한 부연설명이나 함수에 대한 기능을 작성할수 있고 불필요한 코드의 실행을 막을수 있다.JavaScript주석의 코드 사용 방법한줄 주석의 경우 - // 내용여러 줄의 경우 - /* 내용 */ 로 사용한다// 한줄 주석 사용시/*     여러줄     주석     사용시*/2. 줄바꿈과 여백JavaScript의 경우 명령이 끝났다는걸 알려주기 위해 ;를 표시해준다 줄바꿈을 할 경우엔 JavaScript에서 자동으로 명령이 끝났다고 판단하지만 한줄에 여러 명령을 쓸 경우가 있어 명령어 뒤엔 ;를 붙여주는게 좋다.    &lt;script type=\"text/javascript\"&gt;        var a = 1; //;을 안넣어도 줄이 바뀌면 명령이 끝났다고 인식한다        alert(a);    &lt;/script&gt;위 코드에서 ;기호를 없애도 줄바꿈을 했기 때문에 명령이 끝났다고 인식할 것 이다.하지만    &lt;script type=\"text/javascript\"&gt;        var a = 1; alert(a); //;가 없다면 var a = 1alert(a) 가 될것이다.            &lt;/script&gt;이런 경우엔 ;가 없다면 하나의 명령이 될 것이다.( var 뒤 띄어쓰기를 해야 하고 =양쪽엔 하지 않아도 된다.)그리고 코드를 썼는데 코드가 다닥다닥 붙어 있다면 코드를 보기 힘들 것이다. 가독성이 좋지 않다는 말이다. Tap키를 명령어와 함수 사이에 적절히 사용해 좀 더 보기 좋게 하는 게 좋을 것이다.",
        "url": "/javascript-basic"
    }
    ,
    
    "python-st": {
        "title": "Python 강좌(1) - Python 기본",
            "author": "AhnSang0915",
            "category": "",
            "content": "Python Practice    Python 첫번쨰    Python 두번째이글은 Python basic입니다.!!# Jekyll configurationmarkdown: kramdown# kramdown : markdown의 개조판.# markdown에서 불편한 사항을 개선한 형태.# MyDataowner:  name:           SangHyun Ahn  avatar:         photo.jpg  bio:            &quot;Junior&quot;  email:          tmqjf4921@gmail.com  # Social networking links used in footer. Update and remove as you like.  twitter:  facebook:  github: https://github.com/AhnSang0915  stackexchange:  linkedin:  instagram:  flickr:  tumblr:  # google plus id, include the &#39;+&#39;, eg +mmistakes  google_plus:highlighter: rouge# text highlighter로 rouge이용# 2016.02월 이후로 syntax highlighter는 rouge만 지원.# Pygments 사용불가.paginate: 20# 작성한 모든 post를 하나의 페이지에 열거할 수 없으니# pagination이 필요하고 몇개의 post를 하나의 page에서# 보여줄 건지를 설정.language: &#39;en-uk&#39;# 언어 설정url: https://AhnSang0915.github.io# Google Search Console에서 사용하는 sitemap.xml 생성시# 이 url key값이 존재하지 않으면 sitemap.xml이# 정상적으로 생성되지 않는다.# 또한 disqus(댓글시스템)를 이용하기 위해서도 필요.# 자신의 github page url을 입력# ( https://your_github_id.github.io 형식 )baseurl: /# Website infotitle: My Coding Practice Gym# 자신의 blog title.description: Learn Coding# blog home에 표시될 blog에 대한 전반적인 설명.cover: assets/built/images/blog-cover1.jpg# blog home에 표시될 blog cover image.logo:logo_dark:favicon: assets/built/images/favicon.png# favicon으로 사용할 imageproduction_url: https://AhnSang0915.github.io# 최종적으로 blog가 운영될 urlsource_url: # blogmaker(jekyll source folder)에 대한 github repository# Social infonavigation: True# Navigation bar link를 보여줄건지 여부subscribers: True# subscriber 기능을 사용할건지의 여부# 저는 약간의 수정을 통해 subscriber 기능대신# lunr.js를 이용한 검색 기능으로 대체 사용했습니다.# 검색기능으로 대체하기 위해서# `_includes/subscribe-form.html` 파일의 수정이 필요합니다.twitter:facebook:# 만약 twitter와 facebook을 이용하면 username을 입력# Disqusdisqus: Truedisqus_shortname: xxxxxxxx# disqus는 온라인 댓글 시스템. 댓글 기능을 사용하기 위해# disqus를 이용할 것인지 여부와 만약 사용하면# disqus shortname을 입력 ( disqus username이 아님 )# Google Analyticsgoogle_analytics: UA-xxxxxxxx-x # replace with your GA tracking identifier# Google Analytics을 사용할 경우 GA tracking identifier를 입력# Permalinkspermalink: /:title# permalink: /author/:author# permalink: /tag/:title# 각각의 post에 고정주소를 어떤 방식으로 할당할 것인지를 결정# 이 값을 바꾸면 작성한 포스트의 저장위치나 파일이름이 변경된다.# gems and other configsplugins: [jekyll-paginate, jekyll-feed, jekyll-gist]feed:  path: feed.xml# Travis-CI 설정입니다.safe: Falselsi: Falseusername: moon9342repo: GitHubPageMaker# username : travis-ci와 연동하는 github의 username# repo: travis-ci와 연동하는 github의 repository이름# https://github.com/&lt;username&gt;/&lt;repository&gt;branch: master# 사용할 branch명relative_source:destination: ../[GitHubPage]/# compile된 결과가 생성되는 폴더# 이 폴더안의 내용이 우리가 운영하는 블로그 내용이 컴파일되서 들어간다.# 이 폴더안의 내용을 github repository(https://username.github.io)에 push# 만약 Travis-CI를 이용할 예정이면 이 부분을 git submodule로# github repository(https://username.github.io)에 연결해야 한다.# exclude는 Jekyll컴파일 시 destination에 포함될 필요가# 없는것들을 명시한다. (node_modules와 필요없는 것들은 제외)exclude:  - README.md  - Rakefile  - Gemfile  - Gemfile.lock  - changelog.md  - &quot;*.Rmd&quot;  - vendor  - .travis.yml  - node_modules  - assets/css  - assets/images  - _posts/angular  - _posts/et-cetera#  - _posts/python  - _posts/typescript#  - _posts/jekyll  - _posts/iot  - _posts/r  - _posts/economy",
        "url": "/python-st"
    }
    ,
    
    "python-basic": {
        "title": "Python 강좌(1) - Python 기본",
            "author": "AhnSang0915",
            "category": "",
            "content": "Python Practice    Python 첫번쨰    Python 두번째이글은 Python basic입니다.function syntaxHighlight(code) {   var foo = 'Hello World';   var bar = 100;}",
        "url": "/python-basic"
    }
    ,
    
    "gettysburg-address": {
        "title": "Gettysburg Address",
            "author": "abraham",
            "category": "",
            "content": "Fourscore and seven years ago our fathers brought forth on this continent, a new nation, conceived in Liberty, and dedicated to the proposition that all men are created equal.Now we are engaged in a great civil war, testing whether that nation, or any nation so conceived and so dedicated, can long endure. We are met on a great battle-field of that war. We have come to dedicate a portion of that field, as a final resting place for those who here gave their lives that that nation might live. It is altogether fitting and proper that we should do this.But, in a larger sense, we can not dedicate-we can not consecrate-we can not hallow-this ground. The brave men, living and dead, who struggled here, have consecrated it, far above our poor power to add or detract. The world will little note, nor long remember what we say here, but it can never forget what they did here. It is for us the living, rather, to be dedicated here to the unfinished work which they who fought here have thus far so nobly advanced. It is rather for us to be here dedicated to the great task remaining before us-that from these honored dead we take increased devotion to that cause for which they gave the last full measure of devotion-that we here highly resolve that these dead shall not have died in vain-that this nation, under God, shall have a new birth of freedom-and that government of the people, by the people, for the people shall not perish from the earth.",
        "url": "/gettysburg-address"
    }
    
    
    };
</script>
<script src="assets/js/lunr.js"></script>
<script src="assets/js/search.js"></script>
            </section>

        </article>

    </div>
</main>

<!-- /post -->

<!-- The #contentFor helper here will send everything inside it up to the matching #block helper found in default.hbs -->
<script>
$(function() {
    var $postContent = $(".post-full-content");
    $postContent.fitVids();
});
</script>



        <!-- Previous/next page links - displayed on every page -->
        

        <!-- The footer at the very bottom of the screen -->
        <footer class="site-footer outer">
            <div class="site-footer-content inner">
                <section class="copyright"><a href="https://AhnSang0915.github.io/">My Coding Practice Gym</a> &copy; 2022</section>
                <section class="poweredby">Proudly published with <a href="https://jekyllrb.com/">Jekyll</a> &
                    <a href="https://pages.github.com/" target="_blank" rel="noopener">GitHub Pages</a> using
                    <a href="https://github.com/jekyllt/jasper2" target="_blank" rel="noopener">Jasper2</a></section>
                <nav class="site-footer-nav">
                    <a href="/">Latest Posts</a>
                    
                    
                    <a href="https://ghost.org" target="_blank" rel="noopener">Ghost</a>
                </nav>
            </div>
        </footer>

    </div>

    <!-- The big email subscribe modal content -->
    
    <div id="subscribe" class="subscribe-overlay">
        <a class="subscribe-overlay-close" href="#"></a>
            <div class="subscribe-overlay-content">
                
                <h1 class="subscribe-overlay-title">Search My Coding Practice Gym</h1>
                <p class="subscribe-overlay-description">
                블로그 포스팅 검색 </p>
                <span id="searchform" method="post" action="/subscribe/" class="">
    <input class="confirm" type="hidden" name="confirm"  />
    <input class="location" type="hidden" name="location"  />
    <input class="referrer" type="hidden" name="referrer"  />

    <div class="form-group">
        <input class="subscribe-email" onkeyup="myFunc()" 
               id="searchtext" type="text" name="searchtext"  
               placeholder="Search..." />
    </div>
    <script type="text/javascript">
        function myFunc() {
            if(event.keyCode == 13) {
                var url = encodeURIComponent($("#searchtext").val());
                location.href = "/search.html?query=" + url;
            }
        }
    </script>
</span>
            </div>
    </div>
    

    <!-- highlight.js -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.10.0/components/prism-abap.min.js"></script>
    <script>$(document).ready(function() {
      $('pre code').each(function(i, block) {
        hljs.highlightBlock(block);
      });
    });</script>

    <!-- jQuery + Fitvids, which makes all video embeds responsive -->
    <script
        src="https://code.jquery.com/jquery-3.2.1.min.js"
        integrity="sha256-hwg4gsxgFZhOsEEamdOYGBf13FyQuiTwlAQgxVSNgt4="
        crossorigin="anonymous">
    </script>
    <script type="text/javascript" src="/assets/js/jquery.fitvids.js"></script>
    <script type="text/javascript" src="https://demo.ghost.io/assets/js/jquery.fitvids.js?v=724281a32e"></script>


    <!-- Paginator increased to "infinit" in _config.yml -->
    <!-- if paginator.posts  -->
    <!-- <script>
        var maxPages = parseInt('');
    </script>
    <script src="/assets/js/infinitescroll.js"></script> -->
    <!-- /endif -->

    


    <!-- Add Google Analytics  -->
    <!-- Google Analytics Tracking code -->
 <script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-xxxxxxxx-x', 'auto');
  ga('send', 'pageview');

 </script>


    <!-- The #block helper will pull in data from the #contentFor other template files. In this case, there's some JavaScript which we only want to use in post.hbs, but it needs to be included down here, after jQuery has already loaded. -->
    
        <script>
$(function() {
    var $postContent = $(".post-full-content");
    $postContent.fitVids();
});
</script>

    

    <!-- Ghost outputs important scripts and data with this tag - it should always be the very last thing before the closing body tag -->
    <!-- ghost_foot -->

</body>
</html>
