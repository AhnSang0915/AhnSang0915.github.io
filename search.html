<!DOCTYPE html>
<html>
<head>

    <!-- Document Settings -->
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />

    <!-- Base Meta -->
    <!-- dynamically fixing the title for tag/author pages -->



    <title>Search Result</title>
    <meta name="HandheldFriendly" content="True" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <!-- Styles'n'Scripts -->
    <link rel="stylesheet" type="text/css" href="/assets/built/screen.css" />
    <link rel="stylesheet" type="text/css" href="/assets/built/screen.edited.css" />
    <link rel="stylesheet" type="text/css" href="/assets/built/syntax.css" />

    <!--    costom.css-->
    <link rel="stylesheet" type="text/css" href="/assets/built/custom.css" />

    <!--    Font Awsome-->
    <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css">

    <!--    웹폰트 추가-->
    <link rel="stylesheet" href="https://fonts.googleapis.com/earlyaccess/nanumgothic.css">

    <!--    syntax.css-->
    <link rel="stylesheet" type="text/css" href="/assets/built/syntax.css" />


    <!-- highlight.js -->
    <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css">
    <style>.hljs { background: none; }</style>

    <!--[if IE]>
        <style>
            p, ol, ul{
                width: 100%;
            }
            blockquote{
                width: 100%;
            }
        </style>
    <![endif]-->
    
    <!-- This tag outputs SEO meta+structured data and other important settings -->
    <meta name="description" content="Learn Coding" />
    <link rel="shortcut icon" href="https://AhnSang0915.github.io/assets/built/images/favicon.png" type="image/png" />
    <link rel="canonical" href="https://AhnSang0915.github.io/search" />
    <meta name="referrer" content="no-referrer-when-downgrade" />

     <!--title below is coming from _includes/dynamic_title-->
    <meta property="og:site_name" content="My Coding Practice Gym" />
    <meta property="og:type" content="website" />
    <meta property="og:title" content="Search Result" />
    <meta property="og:description" content="Learn Coding" />
    <meta property="og:url" content="https://AhnSang0915.github.io/search" />
    <meta property="og:image" content="https://AhnSang0915.github.io/assets/built/images/blog-cover1.jpg" />
    <meta property="article:publisher" content="https://www.facebook.com/" />
    <meta name="twitter:card" content="summary_large_image" />
    <meta name="twitter:title" content="Search Result" />
    <meta name="twitter:description" content="Learn Coding" />
    <meta name="twitter:url" content="https://AhnSang0915.github.io/" />
    <meta name="twitter:image" content="https://AhnSang0915.github.io/assets/built/images/blog-cover1.jpg" />
    <meta name="twitter:label1" content="Written by" />
    <meta name="twitter:data1" content="My Coding Practice Gym" />
    <meta name="twitter:site" content="@" />
    <meta name="twitter:creator" content="@" />
    <meta property="og:image:width" content="2000" />
    <meta property="og:image:height" content="666" />

    <script type="application/ld+json">
{
    "@context": "https://schema.org",
    "@type": "Website",
    "publisher": {
        "@type": "Organization",
        "name": "My Coding Practice Gym",
        "logo": "https://AhnSang0915.github.io/"
    },
    "url": "https://AhnSang0915.github.io/search",
    "image": {
        "@type": "ImageObject",
        "url": "https://AhnSang0915.github.io/assets/built/images/blog-cover1.jpg",
        "width": 2000,
        "height": 666
    },
    "mainEntityOfPage": {
        "@type": "WebPage",
        "@id": "https://AhnSang0915.github.io/search"
    },
    "description": "Learn Coding"
}
    </script>

    <!-- <script type="text/javascript" src="https://demo.ghost.io/public/ghost-sdk.min.js?v=724281a32e"></script>
    <script type="text/javascript">
    ghost.init({
    	clientId: "ghost-frontend",
    	clientSecret: "f84a07a72b17"
    });
    </script> -->

    <meta name="generator" content="Jekyll 3.6.2" />
    <link rel="alternate" type="application/rss+xml" title="Search Result" href="/feed.xml" />


</head>
<body class="page-template">

    <div class="site-wrapper">
        <!-- All the main content gets inserted here, index.hbs, post.hbs, etc -->
        <!-- < default -->
<!-- The tag above means: insert everything in this file
into the {body} of the default.hbs template -->

<!-- The big featured header, it uses blog cover image as a BG if available -->
<header class="site-header outer">
    <div class="inner">
        <nav class="site-nav">
    <div class="site-nav-left">
        
            
                <a class="site-nav-logo" href="https://AhnSang0915.github.io/">My Coding Practice Gym</a>
            
        
        
            <ul class="nav" role="menu">
    <li class="nav-home" role="menuitem"><a href="/">Home</a></li>
    <li class="nav-about" role="menuitem"><a href="/about/">About</a></li>
    <li class="nav-javascript" role="menuitem"><a href="/tag/javascript/">Javascript</a></li>
    <li class="nav-python" role="menuitem"><a href="/tag/python/">Python</a></li>
    <li class="nav-archive" role="menuitem">
        <a href="/archive.html">All Posts</a>
    </li>
    <li class="nav-archive" role="menuitem">
        <a href="/author_archive.html">Tag별 Posts</a>
    </li>
</ul>
        
    </div>
    <div class="site-nav-right">
        <div class="social-links">
            
            
        </div>
        
            <a class="subscribe-button" href="#subscribe">Search</a>
        
    </div>
</nav>

    </div>
</header>

<!-- Everything inside the #post tags pulls data from the post -->
<!-- #post -->

<main id="site-main" class="site-main outer" role="main">
    <div class="inner">

        <article class="post-full  post page no-image">

            <header class="post-full-header">
                <h1 class="post-full-title">Search Result</h1>
            </header>

            

            <section class="post-full-content">
                <form action="/search" method="get" hidden="hidden">
    <label for="search-box"></label>
    <input type="text" id="search-box" name="query">
</form>

<ul class="mylist" id="search-results"></ul>

<script>
    window.store = {
    
    "python-basic23": {
        "title": "Python - Python 딕셔너리 응용하기",
            "author": "AhnSang0915",
            "category": "",
            "content": "Python    Python 기본    Python 숫자 계산하기    Python 변수 만들기    Python 출력 방법    Python 불과 비교, 논리 연산자    Python 문자열 사용하기    Python 리스트와 튜플 사용하기    Python 시퀀스 자료형 활용하기    Python 딕셔너리 사용하기    Python if 조건문으로 특정 조건일 때 코드 실행하기    Python else를 사용하여 두 방향으로 분기하기    Python elif를 사용하여 두 방향으로 분기하기    Python for 반복문    Python while 반복문    Python break, continue로 반복문 제어하기    Python 중첩루프    Python FizzBuzz 문제    Python 터틀 그래픽스로 그림 그리기    Python 리스트와 튜플 응용하기    Python 리스트와 튜플 응용하기 - 2    Python 2차원 리스트 사용하기    Python 문자열 응용하기    Python 딕셔너리 응용하기딕셔너리 응용하기딕셔너리의 키-값 쌍을 조작하는 메서드 정보를 조회하는 메서드를 사용해보자. 그리고 for 반복문을 사용하여 키와 값에 접근하는 방법, 딕셔너리 표현식, 중첩 딕셔너리를 알아보자.1. 딕셔너리 조작하기딕셔너리를 조작하는 메서드와 정보를 얻는 메서드를 알아보자.딕셔너리에 키-값 쌍 추가하기딕셔너리의 중요한 기능중 하나는 키-값 쌍 추가이다. 두가지 메서드를 사용하는 방법으로 키-값 쌍을 추가할 수 있다.  setdefault: 키-값 쌍 추가  update: 키의 값 수정, 키가 없으면 키-값 쌍 추가딕셔너리에 키와 기본값 저장하기setdefault(키)는 딕셔너리에 키-값 쌍을 추가한다. setdefault에 키만 지정하면 값에 None을 저장한다. 키 ‘e’를 추가하고 값에 None을 저장하는 코드다.x = {'a': 10, 'b': 20, 'c': 30, 'd': 40}x.setdefault('e')x{'a': 10, 'b': 20, 'c': 30, 'd': 40, 'e': None}키 ‘f’를 추가하고 값에 100을 저장한뒤 100을 반환한다.x = {'a': 10, 'b': 20, 'c': 30, 'd': 40}x.setdefault('f',100)100x{'a': 10, 'b': 20, 'c': 30, 'd': 40, 'f': 100}딕셔너리에서 키의 값 수정하기update(키=값)는 키-값 쌍을 수정하는 메서드이다. 예를 들어 x = {‘a’ : 10}이라면 x.update(a=90)과 같이 키에서 작은 따옴표 또는 큰따옴표를 빼고 키 이름과 값을 지정한다.x = {'a': 10, 'b': 20, 'c': 30, 'd': 40}x.update(a=90)x{'a': 90, 'b': 20, 'c': 30, 'd': 40}만약 딕셔너리에 키가 없으면 키-값 쌍을 추가한다. 딕셔너리 x에는 키 ‘e’가 없기떄문에 x.update(e=50)을 실행하면 ‘e’ : 50을 추가한다.x = {'a': 10, 'b': 20, 'c': 30, 'd': 40}x.update(e=50)x{'a': 90, 'b': 20, 'c': 30, 'd': 40, 'e': 50}키-값 쌍 여러 개를 콤마로 구분해서 넣어주면 값을 한꺼번에 수정할 수 있다. 이때도 키가 있으면 해당 키의 값을 수정하고 없으면 키-값 쌍을 추가한다. 다음은 키 ‘a’의 값을 900으로 수정하고 ‘f’:60을 추가한다.x = {'a': 10, 'b': 20, 'c': 30, 'd': 40}x.update(a=900, f=60)x{'a': 900, 'b': 20, 'c': 30, 'd': 40, 'e': 50, 'f': 60}update(키=값)은 키가 문자열일 때만 사용할 수 있다. 만약 키가 숫자일 경우에는 update(딕셔너리)처럼 딕셔너리를 넣어서 값을 수정할 수 있다.y = {1: 'one', 2: 'two'}y.update({1: 'ONE', 3: 'THREE'})y{1: 'ONE', 2: 'two', 3: 'THREE'}다른 방법으로는 리슽트와 튜플을 이용하는 방법도 있다. update(리스트), update(튜플)은 리스트와 튜플로 값을 수정한다. 여기서 리스트는 [[키1, 값1]], [[키2, 값2]] 형식으로 키와 값을 리스트로 만들고 이 리스트를 다시 리스트 안에 넣어서 키-값 쌍을 나열해준다.y = {1: 'ONE', 2: 'two', 3: 'THREE'}y.update([[2, 'TWO'], [4, 'FOUR']])y{1: 'ONE', 2: 'TWO', 3: 'THREE', 4: 'FOUR'}특히 update(반복가능한객체)는 키-값 쌍으로 된 반복 가능한 객체로 값을 수정한다. 즉, 다음과 같이 키 리스트와 값 리스트를 묶은 zip 객체로 값을 수정할 수 있다.y = {1: 'ONE', 2: 'TWO', 3: 'THREE', 4: 'FOUR'}y.update(zip([1, 2], ['one', 'two']))y{1: 'one', 2: 'two', 3: 'THREE', 4: 'FOUR'}setdefault와 update의 차이setdefault는 키-값 쌍 추가만 할 수 있고, 이미 들어있는 키의 값은 수정할 수 없다. 하지만 update는 키-값 쌍 추가와 값 수정이 모두 가능하다. 다음과 같이 setdefault로 이미 들어있는 키’a’를 90으로 저장해도 ‘a’의 값은 바뀌지 않는다.x = {'a': 10, 'b': 20, 'c': 30, 'd': 40}x.setdefault('a', 90)10x{'a': 10, 'b': 20, 'c': 30, 'd': 40} # a의 값이 바뀌지 않음딕셔너리에서 키-값 쌍 삭제하기pop(키)는 딕셔너리에서 특정 키-값 쌍을 삭제한 뒤 삭제한 값을 반환한다. 다음은 딕셔러니 x에서 키’a’를 삭제한 뒤 10을 반환한다.x = {'a': 10, 'b': 20, 'c': 30, 'd': 40}x.pop('a')10x{'b': 20, 'c': 30, 'd': 40}pop(키, 기본값)처럼 기본값을 지정하면 딕셔너리에 키가 있을 때는 해당 키-값 쌍을 삭제한뒤 삭제한 값을 반환하지만 키가 없을 때는 기본값만 반환한다. 딕셔러니 x에는 키’z’가 없으므로 기본값으로 지정한 0을 반환한다.x.pop('z', 0)0pop 대신 del로 특정 키-값 쌍을 삭제할 수도 있다. 이때는 [ ]에 키를 지정하여 del을 사용한다. 다음은 딕셔너리 x의 키 ‘a’를 삭제한다.x = {'a': 10, 'b': 20, 'c': 30, 'd': 40}del x['a']x{'b': 20, 'c': 30, 'd': 40}딕셔너리에서 임의의 키-값 쌍 삭제하기popitem()은 딕셔너리에서 &lt;임의의 키-값 쌍을 삭제한 뒤 삭제한 키-값 쌍을 튜플로 반환한다. 이 메서드는 파이썬 버전에 따라 동작이 달라지는데, 파이썬 3.6 이상에서는 마지막 키-값 쌍을 삭제하며 3.5 이하에서는 임의의 키-값 쌍을 삭제한다. 아래 코드는 3.6이상 기준이다.x = {'a': 10, 'b': 20, 'c': 30, 'd': 40}x.popitem()('d', 40)x{'a': 10, 'b': 20, 'c': 30}딕셔너리의 모든 키-값 쌍을 삭제하기clear()는 딕셔너리의 모든 키-값 쌍을 삭제한다.x = {'a': 10, 'b': 20, 'c': 30, 'd': 40}x.clear() #모두 삭제x{}딕셔너리에서 키의 값을 가져오기get(키)는 딕셔너리의 특정 키 값을 가져온다.x = {'a': 10, 'b': 20, 'c': 30, 'd': 40}x.get('a') # 키 'a'의 값을 가져온다. 10get(키, 기본값)처럼 기본값을 지정하면 딕셔너리에 키가 있을 때는 해당 키의 값을 반환하지만 키가 없을때는 기본값을 반환한다.x = {'a': 10, 'b': 20, 'c': 30, 'd': 40}x.get('z', 0) # x딕셔너리에 없는 키'z'와 기본값 0을 지정0 # 기본값 반환.딕셔너리에서 키-값 쌍을 모두 가져오기딕셔너리는 기와 값을 가져오는 다양한 메서드를 제공한다.  items: 키-값 쌍을 모두 가져옴  keys: 키를 모두 가져옴  values: 값을 모두 가져옴items()는 딕셔너리의 키-값 쌍을 모두 가져온다.x = {'a': 10, 'b': 20, 'c': 30, 'd': 40}x.items()dict_items([('a', 10), ('b', 20), ('c', 30), ('d', 40)])keys()는 키를 모두 가져옵니다.x = {'a': 10, 'b': 20, 'c': 30, 'd': 40}x.keys()dict_keys(['a', 'b', 'c', 'd']) # 모든 키values()는 값을 모두 가져옵니다.x = {'a': 10, 'b': 20, 'c': 30, 'd': 40}x.values()dict_values([10, 20, 30, 40]) # 모든 값리스트와 튜플로 딕셔너리 만들기이번에는 리스트(튜플)로 딕셔너리를 만들어 보자.keys = [‘a’, ‘b’, ‘c’, ‘d’]처럼 키가 들어있는 리스트를 준비한다(튜플도 가능). 그리고 dict.fromkeys에 키가 들어있는 리스트를 넣으면 딕셔너리를 생성한다.dict.fromkeys(키리스트)는 키 리스트로 딕셔너리를 생성하며 값은 모두 None으로 저장한다.keys = ['a', 'b', 'c', 'd']x = dict.fromkeys(keys)x{'a': None, 'b': None, 'c': None, 'd': None} # 키 리스트로 딕셔너리 생성후 값을 모두 None으로 저장.dict.fromkeys(키리스트, 값)처럼 키 리스트와 값을 지정하면 해당 값이 키의 값으로 저장된다.keys = ['a', 'b', 'c', 'd']x = dict.fromkeys(keys)x{'a': None, 'b': None, 'c': None, 'd': None}y = dict.fromkeys(keys, 100) # 키리스트에 값 100을 지정y{'a': 100, 'b': 100, 'c': 100, 'd': 100}defaultdict 사용하기딕셔너리(dict)는 없는 키에 접근했을 경우 에러가 발생한다.x = {'a': 0, 'b': 0, 'c': 0, 'd': 0}x['z']    # 키 'z'는 없음Traceback (most recent call last):  File \"&lt;pyshell#5&gt;\", line 1, in &lt;module&gt;    x['z']KeyError: 'z'defaultdict(기본값생성함수)를 사용하면 없는 키에 접근하더라도 에러가 발생하지 않고 기본값을 반환한다. defaultdict는 collections 모듈에 들어있으며 기본값 생성 함수를 넣는다. 아래와 같이 기본 값에 int를 지정하게 되면 0이 나오는데 int()를 하고 호출하면 0이 나오기 때문이다.from collections import defaultdicty = {'a': 0, 'b': 0, 'c': 0, 'd': 0}y = defaultdict(int)int() #int()호출0y['z'] # 없는 키를 에 접근했지만 기본값을 int로 지정해놨다.00이 아닌 다른 값을 기본 값으로 설정할 수도 있다.from collections import defaultdictz = defaultdict(lambda: 'python')z['a']'python'z[0]'python'2. 반복문으로 딕셔너리의 키-값 쌍을 모두 출력하기딕셔너리와 for반복문을 사용해 간단하게 모든 키-값 쌍을 출력해 보자. for i in x 처럼 for 반복문에 딕셔너리를 지정한 뒤에 print로 변수 i를 출력해보면 값을 출력되지 않고 키만 출력된다.x = {'a': 10, 'b': 20, 'c': 30, 'd': 40}for i in x:     print(i, end=' ')a b c d키와 값을 모두 출력하려면 for in 뒤에 딕셔너리를 지정하고 items(키-값 쌍을 모두 가져옴)를 사용해야 한다.for 키, 값 in 딕셔너리.items():     반복할 코드다음은 for로 리스트 a의 모든 키와 값을 출력한다.x = {'a': 10, 'b': 20, 'c': 30, 'd': 40}for key, value in x.items():    print(key, value)    a 10b 20c 30d 40딕셔너리의 키만 출력하기for 반복문에서 keys로 키를 가져오면서 반복해보자.  items: 키-값 쌍을 모두 가져옴  keys: 키를 모두 가져옴  values: 값을 모두 가져옴x = {'a': 10, 'b': 20, 'c': 30, 'd': 40}for key in x.keys(): #딕셔너리 x에 있는 key를 모두 가져와 key에 대입한다.    print(key, end = ' ')    a b c d 딕셔너리의 값만 출력하기for 반복문에서 values를 사용해 값만 가져오며 반복한다.x = {'a': 10, 'b': 20, 'c': 30, 'd': 40}for value in x.values():    print(value, end = ' ')    10 20 30 40 3.딕셔너리 표현식 사용하기리스트와 마찬가지로 딕셔너리도 for 반복문과 if 조건문을 사용해 딕셔너리를 생성할 수 있다. 다음과 같이 딕셔너리 안에 키와 값, for 반복문을 지정하면 된다.  {키: 값 for 키, 값 in 딕셔너리}  dict({키: 값 for 키, 값 in 딕셔너리})딕셔너리 표현식을 사용할 때는 for in 다음에 딕셔너리를 지정하고 items를 사용한다. 그리고 키, 값을 가져온뒤에는 키 : 값 형식으로 변수나 값을 배치하여 딕셔너리를 생성한다.keys = ['a', 'b', 'c', 'd']x = {key : value for key, value in dict.fromkeys(keys).items()} # 키리스트로 딕셔너리를 생성하고 값은 모두 None으로 저장한 키와 값모두를 가져와 변수 key, value에 지정하고 그걸 다시 key : value 에 대입해 딕셔너리로 만든다.x{'a': None, 'b': None, 'c': None, 'd': None}다음과 같이 keys로 킴만 가져온 뒤 특정 값을 넣거나, values로 값을 가져온뒤 값을 키로 사용할 수도 있다. 또는, 키와 값의 자리를 바꾸는 등 여러 가지로 응용할 수 있다.keys = ['a', 'b', 'c', 'd']y = {key: 0 for key in dict.fromkeys(['a', 'b', 'c', 'd']).keys()} # 키리스트로 딕셔너리를 생성하고 키만 가져온후 변수key에 대입후 key: 0 에 키를 대입해 딕셔너리로 만든다. 값을 0으로 지정했다.y{'a': 0, 'b': 0, 'c': 0, 'd': 0}keys = ['a', 'b', 'c', 'd']z = {value: 0 for value in {'a': 10, 'b': 20, 'c': 30, 'd': 40}.values()} # 딕셔너리의 값만 추출해 value에 대입후 value: 0를 값을 키로 만들고 값을 0으로 지정한다.z{10: 0, 20: 0, 30: 0, 40: 0}keys = ['a', 'b', 'c', 'd']t = {value: key for key, value in {'a': 10, 'b': 20, 'c': 30, 'd': 40}.items()} t{10: 'a', 20: 'b', 30: 'c', 40: 'd'}딕셔너리 표현식에서 if 조건문 사용하기표현식이 복잡하고 dict.fromkeys함수만 사용한 결과와 큰차이점이 없어 보이지만 딕셔너리에서 특정값을 찾아 삭제할때 유용하다. 딕셔너리는 특정키를 삭제하는 pop 메서드만 제공할 뿐 특정 값을 삭제하는 메서드는 제공하지 않는다. for 반복문으로 반복하면서 del로 삭제하는 방식은 딕셔너리의 크기가 바뀌어 에러가 발생한다.x = {'a': 10, 'b': 20, 'c': 30, 'd': 40} for key, value in x.items():    if value == 20:    # 값이 20이면        del x[key]     # 키-값 쌍 삭제 print(x)#결과Traceback (most recent call last):  File \"C:\\project\\dict_del_by_value_error.py\", line 3, in &lt;module&gt;    for key, value in x.items():RuntimeError: dictionary changed size during iteration 특정 값을 삭제하려면 딕셔너리 표현식에 if조건문을 사용해 삭제할 값을 제외해야한다. 표현식에 if value != 20과 같이 if 조건문을 지정하면 값이 20이 아닌 키-값 쌍으로 다시 딕셔너리를 만든다. 직접 키-값 쌍을 삭제하는 방식이 아니라 삭제할 키-값 쌍을 제외하고 남은 키-값 쌍으로 딕셔너리를 새로 만드는 것이다.x = {'a': 10, 'b': 20, 'c': 30, 'd': 40}x = {key: value for key, value in x.items() if value != 20}x{'a': 10, 'c': 30, 'd': 40}4.딕셔너리 안에서 딕셔너리 사용하기이번에는 딕셔너리 안에서 딕셔너리를 사용하는 중첩 딕셔너리를 알아보자. 다음과 같이 딕셔너리는 값 부분에 다시 딕셔너리가 계속 들어갈 수 있다.  딕셔너리 = {키1: {키A: 값A}, 키2: {키B: 값B}}아래는 지구형 행성의 반지름, 질량, 공전주기를 딕셔너리로 표현한 것이다.terrestrial_planet = {    'Mercury': {        'mean_radius': 2439.7,        'mass': 3.3022E+23,        'orbital_period': 87.969    },    'Venus': {        'mean_radius': 6051.8,        'mass': 4.8676E+24,        'orbital_period': 224.70069,    },    'Earth': {        'mean_radius': 6371.0,        'mass': 5.97219E+24,        'orbital_period': 365.25641,    },    'Mars': {        'mean_radius': 3389.5,        'mass': 6.4185E+23,        'orbital_period': 686.9600,    }} print(terrestrial_planet['Venus']['mean_radius'])    # 6051.8딕셔너리 terrestrial_planet에 키 ‘Mercury’, ‘Venus’, ‘Earth’, ‘Mars’가 들어있고, 이 키들은 다시 값 부분에 딕셔너리를 가지고 있다. 즉, 중첩 딕셔너리는 계층형 데이터를 지정할 때 유용하다.딕셔너리 안에 들어있는 딕셔너리에 접근하려면 딕셔너리 뒤에 []를 단계만큼 붙이고 키를 지정해주면 된다.  딕셔너리[키][키]  딕셔너리[키][키] = 값딕셔너리 terrestrial_planet는 딕셔너리가 두 단계로 구성되어 있으므로 대괄호를 두 번 사용한다. 금성(Venus)의 반지름(mean radius)를 출력하려면 다음과 같이 먼저 ‘Venus’를 찾아가고 다시 ‘mean_radius’의 값을 가져오면 된다.print(terrestrial_planet['Venus']['mean_radius'])    # 6051.85.딕셔너리의 할당과 복사리스트와 마찬가지로 딕셔너리도 할당과 복사는 큰차이점이 있다. 먼저 딕셔너리를 만든 뒤 변수에 할당한다. y = x와 같이 딕셔너리를 다른 변수에 할당하면 딕셔너리는 두 개가 될 것 같지만 실제로는 딕셔너리가 한개이다. x와 y를 is연산자로 비교하면 True가 나온다. 즉, 변수 이름만 다를 뿐 딕셔너리 x와 y는 같은 객체이다.x is yTruex와 y는 같으므로 y[‘a’]=99와 같이 키’a’의 값을 변경하면 딕셔너리 x와 y모두 반영된다.y['a'] = 99x{'a': 99, 'b': 0, 'c': 0, 'd': 0}y{'a': 99, 'b': 0, 'c': 0, 'd': 0}딕셔너리 x와 y를 완전이 분리한 두개의 딕셔너리로 만드려면 copy메서드로 모든 키-값 쌍을 복사해야한다. 복사후 x와 y를 is 연산자로 비교해보면 False가 나온다. 즉, 두 딕셔너리는 이제 다른 객체이다. 그러나 복사한 키-값 쌍은 같음으로 ==로 비교하면 True가 나온다. 딕셔너리 x와 y는 별개 이므로 한쪽의 값을 변경해도 다른 딕셔너리에 영향을 미치지 않는다. 다음과 같이 딕셔너리 y에서 키 ‘a’의 값을 변경하면 딕셔너리 x는 그대로이고 딕셔너리 y만 바뀐다.x = {'a': 0, 'b': 0, 'c': 0, 'd': 0}y = x.copy()x is yFalsex == yTruey['a'] = 99x{'a': 0, 'b': 0, 'c': 0, 'd': 0}y{'a': 99, 'b': 0, 'c': 0, 'd': 0}중첩 딕셔너리의 할당과 복사 알아보기딕셔너리 안에 딕셔너리가 들어있는 중첩 딕셔너리는 copy메서드를 사용할 경우 값을 복사하면 두 딕셔너리의 값이 모두 바뀌게된다.x = {'a': {'python': '2.7'}, 'b': {'python': '3.6'}}y = x.copy() # 중첩 딕셔너리를 copy메서드로 복사y['a']['python'] = '2.7.15' # 딕셔너리 y의 a키의 값 python키 의 값 변경x{'a': {'python': '2.7.15'}, 'b': {'python': '3.6'}}y{'a': {'python': '2.7.15'}, 'b': {'python': '3.6'}} # 두 딕셔너리 모두 값이 변경됨.중첩 딕셔너리를 완전히 복사하려면 copy메서드 대신 deepcopy 함수를 사용해야한다. 이제 딕셔너리y의 값을 변경해도 딕셔너리 x에 영향을 미치지 않는다. copy.deepcopy 함수는 중첩된 딕셔너리에 들어있는 모든 딕셔너리를 복사하는 깊은 복사(deep copy)를 해준다.x = {'a': {'python': '2.7'}, 'b': {'python': '3.6'}}import copy             # copy 모듈을 가져옴y = copy.deepcopy(x)    # copy.deepcopy 함수를 사용하여 깊은 복사y['a']['python'] = '2.7.15'x{'a': {'python': '2.7'}, 'b': {'python': '3.6'}}y{'a': {'python': '2.7.15'}, 'b': {'python': '3.6'}}   '예제표준 입력으로 문자열 여러 개와 숫자 여러 개가 두 줄로 입력되고, 첫 번째 줄은 키, 두 번째 줄은 값으로 하여 딕셔너리를 생성합니다. 다음 코드를 완성하여 딕셔너리에서 키가 ‘delta’인 키-값 쌍과 값이 30인 키-값 쌍을 삭제하도록 만드세요.keys = input().split()values = map(int, input().split()) x = dict(zip(keys, values))____________________________________________________print(x)#입력alpha bravo charlie delta10 20 30 40#결과{'alpha': 10, 'bravo': 20}#입력alpha bravo charlie delta echo foxtrot golf30 40 50 60 70 80 90#결과{'bravo': 40, 'charlie': 50, 'echo': 70, 'foxtrot': 80, 'golf': 90}답x = {key: value for key, value in x.items() if value != 30 and key != 'delta'}",
        "url": "/python-basic23"
    }
    ,
    
    "python-basic22": {
        "title": "Python - Python 문자열 응용하기",
            "author": "AhnSang0915",
            "category": "",
            "content": "Python    Python 기본    Python 숫자 계산하기    Python 변수 만들기    Python 출력 방법    Python 불과 비교, 논리 연산자    Python 문자열 사용하기    Python 리스트와 튜플 사용하기    Python 시퀀스 자료형 활용하기    Python 딕셔너리 사용하기    Python if 조건문으로 특정 조건일 때 코드 실행하기    Python else를 사용하여 두 방향으로 분기하기    Python elif를 사용하여 두 방향으로 분기하기    Python for 반복문    Python while 반복문    Python break, continue로 반복문 제어하기    Python 중첩루프    Python FizzBuzz 문제    Python 터틀 그래픽스로 그림 그리기    Python 리스트와 튜플 응용하기    Python 리스트와 튜플 응용하기 - 2    Python 2차원 리스트 사용하기    Python 문자열 응용하기    Python 딕셔너리 응용하기문자열 응용하기—1. 문자열 조작하기문자열은 문자열을 조작하거나 정보를 얻는 다양한 메서드(method)를 제공한다. 파이썬에서 제공하는 문자열 메서드중 자주 쓰는 메서드를 알아보자.문자열 바꾸기문자열을 다른 문자열로 바꾸는 메서드를 알아보자. 다음 문자열 Hello, world!’에서 ‘world’를 ‘Python’으로 바꾸는 코드이다. 바뀐 결과를 유지하고 싶다면 문자열이 저장된 변수에 replace를 사용한 뒤 다시 변수에 할당한다.  replace(‘바꿀문자열’, ‘새문자열’)'Hello, world!'.replace('world', 'Python')#결과'Hello, Python!#결과를 유지하고 싶을때.s = 'Hello, world!'s = s.replace('world!', 'Python')s'Hello, Python'문자 바꾸기문자열 안의 문자를 다른 문자로 바꾸는 메서드를 알아보자. 먼저 str.maketrans(‘바꿀문자’, ‘새문자’)로 변환 테이블을 만든다. 그다음에 translate(테이블)을 사용하면 문자를 바꾼 뒤 결과를 반환한다.table = str.maketrans('aeiou', '12345')'apple'.translate(table)'1ppl2'splite(‘기준이되는문자열’)과 같이 기준이되는 문자열을 지정하면 기준 문자열로 문자열을 분리한다.문자열에서 각 단어가,(콤마)와 공백으로 구분되어 있을때’, ‘으로 문자열을 분리하면 단어만 따로 리스트로 처리된다.'apple, pear, grape, pineapple, orange'.split(', ') #기준이 되는 문자열에 split(', ')['apple', 'pear', 'grape', 'pineapple', 'orange']구분자 문자열과 문자열 리스트 연결하기join(리스트)를 사용하면 구분자 문자열과 문자열 리스트의 요소를 연결하여 문자열로 만든다. 다음은 공백 ‘ ‘에 join을 사용하여 각 문자열 사이에 공백이 들어가게 만든다. 공백이 아닌 다른 문자를 사용하면 사용된 문자가 문자열 사이에 들어가게 된다.['apple', 'pear', 'grape', 'pineapple', 'orange']' '.join(['apple', 'pear', 'grape', 'pineapple', 'orange'])         'apple pear grape pineapple orange'# - 를 넣었을때.'-'.join(['apple', 'pear', 'grape', 'pineapple', 'orange'])'apple-pear-grape-pineapple-orange'소문자를 대문자로 바꾸기바꾸고싶은 문자열.upper()은 바꾸고싶은 문자열을 모두 대문자로 바꿔준다. 문자열에 이미 대문자가 있는경우 그대로 유지된다.'python'.upper()'PYTHON'대문자를 소문자로 바꾸기바꾸고싶은 문자열.lower()은 바꾸고싶은 문자열을 모두 소문자로 바꿔준다. 문자열에 이미 소문자가 있는경우 그대로 유지된다.'PYTHON'.lower()'python'왼쪽 공백 삭제하기lstrip, rstrip, strip 메서드는 공백을 삭제해야 할 경우가 사용된다. lstrip()은 문자열에서 왼쪽에 있는 연속된 모든 공백을 삭제한니다(l은 왼쪽(left)을 의미).'   Python   '.strip() #양쪽에 있는 모든 연속된 공백 삭제         'Python''   Python   '.lstrip() #왼쪽 공백 삭제'Python   ''   Python   '.rstrip() #오른쪽 공백 삭제         '   Python'왼쪽의 특정 문자 삭제하기lstrip(‘삭제할문자들’), rstrip(‘삭제할문자들’), strip(‘삭제할문자들’)을 사용하면 해당 방향의 ‘삭제할 문자들에’ 들어있는 문자열을 삭제한다.', python.'.lstrip(',.') #왼쪽에 있는 ',.'문자열 삭제' python.'', python.'.rstrip(',.') #오른쪽에 있는 ',.'문자열 삭제', python' '', python.'.strip(',.') #양쪽의 ',.'문자열 삭제' python'구두점을 간단하게 삭제하기punctuation을 사용하면 문자열의 양쪽 모든 구두점을 삭제할 수 있다.import string', python.'.strip(string.punctuation)' python'string.punctuation'!\"#$%&amp;\\'()*+,-./:;&lt;=&gt;?@[\\\\]^_`{|}~'공백까지 삭제하고자 한다면 string.punctuation에 공백 ‘ ‘을 연결해서 넣어주면 된다.', python.'.strip(string.punctuation + ' ')'python'문자열을 왼쪽 정렬하기ljust(길이)는 문자열을 지정된 길이로 만든 뒤 왼쪽으로 정렬하며 남는 공간을 공백으로 채운다.rjust(길이)는 문자열을 지정된 길이로 만든 뒤 오른쪽으로 정렬하며 남는 공간을 공백으로 채운다.center(길이)는 문자열을 지정된 길이로 만든 뒤 가운데로 정렬하며 남는 공간을 공백으로 채운다.만약 남는 공간이 홀수이면 왼쪽에 공백이 한칸 더 들어간다.'python'.ljust(10) #python을 왼쪽으로 정렬하고 남는 공간을 공백처리'python    ''python'.rjust(10) #python을 오른으로 정렬하고 남는 공간을 공백처리'    python''python'.center(10) ##python을 가운데 정렬하고 양쪽의 남는 공간을 공백처리'  python  '메서드 체이닝메서드 체이닝은 메서드를 줄줄이 연결 한다고 해서 메서드 체이닝(method chaining)이라 부른다. 메서드를 계속 연결해 호출하는 메서드 체이닝을 알아보자. input().split()도 input()이 반환한 문자열에 split을 호출하는 메서드 체이닝이다. 아래 코드는 문자열을 지정된 길이인 10개로 만들고 오른쪽정렬과 대문자 처리를 해줬다.'python'.rjust(10).upper()'    PYTHON'문자열 왼쪽에 0 채우기zfill(길이)를 사용하면 지정된 길이에 맞춰 문자열의 왼쪽에 0을 채운다( zero fill을 의미). 문자열의 길이가 지정된 길이보자 작다면 아무것도 채우지 않는다. 보통 zfill은 숫자를 일정 자릿수로 맞추고 앞자리는 0으로 채울 때 사용한다.'35'.zfill(4)        # 숫자 앞에 0을 채움'0035''3.5'.zfill(6)       # 숫자 앞에 0을 채움'0003.5''hello'.zfill(10)    # 문자열 앞에 0을 채울 수도 있음'00000hello'문자열 위치 찾기find(‘찾을문자열’)은 문자열에서 특정 문자열을 찾아서 인덱스를 반환하고, 문자열이 없으면 -1을 반환한다. find는 왼쪽부터 문자열을 찾고, 같은 문자열이 여러개일 경우 처음 찾은 문자열의 인덱스를 반환한다. 아래에서는 ‘pl’이 2개 있지만 왼쪽에서 처음 찾은 ‘pl’의 인덱스 2를 반환한다.rfind(‘찾을문자열’)은 오른쪽에서부터 특정 문자열을 찾아서 인덱스를 반환하고, 문자열이 없으면 -1을 반환한다. 같은 문자열이 여러개일 경우 처음 찾은 문자열의 인덱스를 반환한다. 아래에서는 ‘pl’이 2개 있지만 오른쪽에서 처음 찾은 ‘pl’의 인덱스 12를 반환한다.'apple pineapple'.find('pl') #찾는 문자열이 인덱스 2번위치부터 위치한다.2'apple pineapple'.find('xy') #찾는 문자열이 없기때문에 -1을 반환-1'apple pineapple'.rfind('pl') #찾는 문자열이 인덱스 12번위치부터 위치한다.12'apple pineapple'.rfind('xy') #찾는 문자열이 없기때문에 -1을 반환-1문자열 위치 찾기find, rfind 이외에도 index, rindex로 문자열의 위치를 찾을 수 있다.index(‘찾을문자열’)은 왼쪽에서부터 특정 문자열을 찾아서 인덱스를 반환한다. 단, 문자열이 없으면 에러를 발생시킨다. index도 같은 문자열이 여러 개일 경우 처음 찾은 문자열의 인덱스를 반환한다. rindex(‘찾을문자열’)은 오른쪽에서부터 특정 문자열을 찾아서 인덱스를 반환한다(r은 오른쪽(right)을 의미). 마찬가지로 문자열이 없으면 에러를 발생시키며 같은 문자열이 여러 개일 경우 처음 찾은 문자열의 인덱스를 반환한다.'apple pineapple'.index('pl')2'apple pineapple'.rindex('pl')12문자열 개수 세기count(‘문자열’)은 현재 문자열에서 특정 문자열이 몇 번 나오는지 알아낸다. 여기서는 ‘pl’이 2번 나오므로 2가 반환된다.'apple pineapple'.count('pl')22. 문자열 서식 지정자와 포매팅 사용하기서식 지정자(format specifier)로 문자열을 만드는 방법과 format 메서드로 문자열을 만드는 문자열 포매팅(string formatting)에 대해 알아보자.예를들어 학생의 이름과 평균 점수를 출력한다고하자. 두 문자열에서 ‘의 평균 점수는’, ‘점입니다.’는 같지만 이름과 점수가 다르다. 이렇게 문자열 안에서 특정 부분을 원하는 값으로 바꿀 때 서식 지정자 또는 문자열 포매팅을 사용한다.제임스의 평균 점수는 85.3점입니다.학생이 바뀌면 이름과 점수 부분도 바뀌게 된다.마리아의 평균 점수는 98.7점입니다.서식 지정자로 문자열 넣기서식 지정자(format specifier)로 문자열 중간에 다른 문자열을 넣어보자.  ‘%s’ % ‘문자열’서식 지정자는 %로 시작하고 자료형을 뜻하는 문자가 붙는다. %s는 문자열이라는 뜻이고 string의 s이다. 문자열 안에 %s를 넣고 그 뒤에 %를 붙인 뒤 ‘james’를 지정해주면 %s부분이 ‘james’로 바뀐다. 문자열이 아닌 변수를 지정할 수도 있다.'I am %s.' % 'james''I am james.'name = 'maria''I am %s.' % name'I am maria.'서식 지정자로 숫자 넣기서식 지정자로 숫자형을 넣는 방식이다.  ‘%d’ % 숫자숫자는 %d를 넣고 % 뒤에 숫자를 지정하면 된다. %d는 10진 정수 decimal integer의 d이다.'I am %d years old.' % 20'I am 20 years old.'서식 지정자로 소수점 표현하기서식 지정자로 실수를 넣는 방법이다.  ‘%f’ % 숫자실수를 넣을 때는 %f를 사용하며 고정 소수점 fixed point의 f이다. %f는 기본적으로 소수점 이하 6자리까지 표시하므로 2.3은 2.300000으로 표시된다. 소수점 이하 자릿수를 지정하고 싶다면 다음과 같이 f 앞에 .(점)과 자릿수를 지정해주면 된다.  ’%.자릿수f’ % 숫자'%f' % 2.3'2.300000''%.2f' % 2.3 #소숫점 이하 2자리까지 표시'2.30''%.3f' % 2.3 #소숫점 이하 3자리까지 표시'2.300'서식 지정자로 문자열 정렬하기서식 지정자와 숫자를 조합하여 문자열을 정렬하는 방법이다. 다음과 같이 % 뒤에 숫자를 붙이면 문자열을 지정된 길이로 만든 뒤 오른쪽으로 정렬하고 남는 공간을 공백으로 채운다. %10s는 문자열의 길이를 10으로 만든 뒤 지정된 문자열을 넣고 오른쪽으로 정렬한다. 따라서 문자열 ‘python’은 길이가 6이므로 왼쪽 공간을 공백 4칸으로 채운다.  %길이s'%10s' % 'python''    python'왼쪽 정렬은 아래와 같다. %-10s는 문자열의 길이를 10으로 만든 뒤 지정된 문자열을 넣고 왼쪽으로 정렬한다. 따라서 문자열 ‘python’은 길이가 6이므로 오른쪽 공간을 공백 4칸으로 채운다.  %-길이s'%-10s' % 'python''python    '자릿수가 다른 숫자 출력하기문자열 오른쪽 정렬은 자릿수가 다른 숫자를 출력할 때 유용하다. %d와 %f도 숫자와 조합하여 오른쪽으로 정렬할 수 있다.  %길이d'%10d' % 150'       150''%10d' % 15000'     15000'  길이.자릿수f'%10.2f' % 2.3'      2.30''%10.2f' % 2000.3'   2000.30'서식 지정자로 문자열 안에 값 여러 개 넣기서식지정자로 문자열 안에 값을 여러개 넣는 방법이다.  ‘%d %s’ % (숫자, ‘문자열’)문자열 안에 값을 두개 이상 넣으려면 %를 붙이고 괄호 안에 값또는 변수를 콤마로 구분해서 넣어주면 된다. 특히 값을 괄호로 묶지 않으면 에러가 발생하니 주의해야 한다. 이처럼 서식 지정자가 여러 개면 괄호 안의 값(변수) 개수도 서식 지정자 개수와 똑같이 맞춰주어야 한다.'Today is %d %s.' % (3, 'April')'Today is 3 April.'format 메서드 사용하기파이썬은 문자열을 만들 때 서식 지정자 방식보다 더 간단한 문자열 포매팅(string formatting)을 제공한다. 문자열 포매팅은 { }(중괄호) 안에 포매팅을 지정하고 format 메서드로 값을 넣는다.  ‘{인덱스}’.format(값)'Hello, {0}'.format('world!')'Hello, world!''Hello, {0}'.format(100)'Hello, 100'format 메서드로 값을 여러 개 넣기값을 여러개 넣으려면 인덱스 값을 지정하고 format에는 인덱스가 증가하는 순서대로 값을 넣으면 된다.  ‘{인덱스}’.format(값)                                0       1       2'Hello, {0} {2} {1}'.format('Python', 'Script', 3.6)'Hello, Python 3.6 Script'format 메서드로 같은 값을 여러 개 넣기특히 같은 인덱스가 지정된 { }를 여러 개 넣으면 같은 값이 여러 개 들어간다. 다음은 문자열에 ‘Python’이 두 개, ‘Script’가 두 개 들어간다.'{0} {0} {1} {1}'.format('Python', 'Script')'Python Python Script Script'format 메서드에서 인덱스 생략하기만약 { }에서 인덱스를 생략하면 format에 지정한 순서대로 값이 들어간다.'Hello, {} {} {}'.format('Python', 'Script', 3.6)'Hello, Python Script 3.6'format 메서드에서 인덱스 대신 이름 지정하기{ }에 인덱스 대신 이름을 지정해 값을 할당할 수 있다.'Hello, {language} {version}'.format(language='Python', version=3.6)'Hello, Python 3.6'문자열 포매팅에 변수를 그대로 사용하기파이썬 3.6부터는 변수에 값을 넣고 { }에 변수 이름을 지정해 변수를 그대로 사용할 수 있다. 이때 문자열 앞에 포매팅(formatting)이라는 뜻으로 f를 붙인다.language = 'Python'version = 3.6f'Hello, {language} {version}''Hello, Python 3.6'# 중괄호 출력하기'{\\{ {0} }\\}'.format('Python')'{ Python }'format 메서드로 문자열 정렬하기문자열 포매팅도 문자열을 정렬할 수 있다. 다음과 같이 인덱스 뒤에 :(콜론)을 붙이고 정렬할 방향과 길이를지정해준다.  ‘{인덱스:&lt;길이}’.format(값)‘{0:&lt;10}’은 부등호 방향이 왼쪽을 가리키고있다. 따라서 문자열을 지정된 길이로 만든 뒤 왼쪽으로 정렬하고 남는 공간을 공백으로 채운다.'{0:&lt;10}'.format('python')'python    '다음과 같이 &gt;을 넣어서 오른쪽을 가리키도록 만들면 문자열을 지정된 길이로 만든 뒤 오른쪽으로 정렬하고 남는 공간을 공백으로 채운다.  ‘{인덱스:&gt;길이}’.format(값)'{0:&gt;10}'.format('python')'    python'인덱스를 사용하지 않는다면 :(콜론)과 정렬 방법만 지정해도 된다.'{:&gt;10}'.format('python')'    python'숫자 개수 맞추기d는 다음과 같이 %와 d 사이에 0과 숫자 개수를 넣어주면 자릿수에 맞춰서 앞에 0이 들어간다. 즉, %03d로 지정하면 1은 ‘001’, 35는 ‘035’가 된다. { }를 사용할 때는 인덱스나 이름 뒤에 :(콜론)를 붙이고 03d처럼 0과 숫자 개수를 지정하면 된다.  ‘%0개수d’ % 숫자  ‘{인덱스:0개수d’}’.format(숫자)'%03d' % 1'001''{0:03d}'.format(35)'035'실수도 숫자 개수를 맞출 수 있다. 특히 소수점 이하 자릿수를 지정하고 싶으면 %08.2f처럼 .(점) 뒤에 자릿수를 지정헤준다. 여기서 주의할 점은 ‘%08.2f’ % 3.6을 출력했을 때 ‘00003.60’이 나온다는 점이다. 실수는 숫자 개수에 정수 부분, 소수점, 소수점 이하 자릿수가 모두 포함된다. 따라서 ‘00003’ 5개, ‘.’ 1개, ‘60’ 2개 총 8개가된다.  ‘%0개수.자릿수f’ % 숫자  ‘{인덱스:0개수.자릿수f’}.format(숫자)'%08.2f' % 3.6'00003.60''{0:08.2f}'.format(150.37)'00150.37'채우기와 정렬을 조합해서 사용하기문자열 포매팅은 채우기와 정렬을 조합해서 사용할 수 있다. 다음과 같이 { }에 인덱스, 채우기, 정렬, 길이, 자릿수, 자료형 순으로 지정해 준다. 길이를 10으로 만들고 왼쪽, 오른쪽으로 정렬하고 남는 공간은 0으로 채워보자.  ‘{인덱스:[[채우기]정렬][길이][.자릿수][자료형]}’'{0:0&lt;10}'.format(15)    # 길이 10, 왼쪽으로 정렬하고 남는 공간은 0으로 채움'1500000000''{0:0&gt;10}'.format(15)    # 길이 10, 오른쪽으로 정렬하고 남는 공간은 0으로 채움'0000000015'실수로 만들고 싶다면 다음과 같이 소수점 자릿수와 실수 자료형 f를 지정해주면 된다.'{0:0&gt;10.2f}'.format(15)    # 길이 10, 오른쪽으로 정렬하고 소수점 자릿수는 2자리'0000015.00'채우기 부분에 0이 아닌 다른 문자를 넣어도 된다. 공백을 넣어도 되고, 문자를 넣어도 된다. 채우기 부분을 생략하면 공백이 들어가게된다.'{0: &gt;10}'.format(15)    # 남는 공간을 공백으로 채움'        15''{0:&gt;10}'.format(15)     # 채우기 부분을 생략하면 공백이 들어감'        15''{0:x&gt;10}'.format(15)    # 남는 공간을 문자 x로 채움'xxxxxxxx15'금액에서 천단위로 콤마 넣기숫자 중에서 금액은 천단위로 콤마를 넣는다. 파이썬에서 간단하게 천단위로 콤마를 넣을수 있다. \\ format 내장 함수를 사용하는 방법입니다. 다음과 같이 format 함수에 숫자와 ‘,’를 넣어준다.  format(숫자, ‘,’)format(1493500, ',')'1,493,500'format 함수는 서식 지정자와 함께 사용할 수 있습니다. 다음은 콤마를 넣은 숫자를 오른쪽 정렬한다.'%20s' % format(1493500, ',')    # 길이 20, 오른쪽으로 정렬'           1,493,500'포매팅에서 콤마를 넣으려면 다음과 같이 :(콜론)뒤에 ,(콤마)를 지정하면 된다.'{0:,}'.format(1493500)'1,493,500'만약 정렬을 하고 싶다면 정렬 방향과 길이 뒤에 콤마를 지정해준다. '{0:&gt;20,}'.format(1493500)     # 길이 20, 오른쪽으로 정렬'           1,493,500''{0:0&gt;20,}'.format(1493500)    # 길이 20, 오른쪽으로 정렬하고 남는 공간은 0으로 채움'000000000001,493,500'예제1표준 입력으로 문자열이 입력됩니다. 입력된 문자열에서 ‘the’의 개수를 출력하는 프로그램을 만드세요(input에서 안내 문자열은 출력하지 않아야 합니다). 단, 모든 문자가 소문자인 ‘the’만 찾으면 되며 ‘them’, ‘there’, ‘their’ 등은 포함하지 않아야 합니다.# 입력the grown-ups' response, this time, was to advise me to lay aside my drawings of boa constrictors, whether from the inside or the outside, and devote myself instead to geography, history, arithmetic, and grammar. That is why, at the, age of six, I gave up what might have been a magnificent career as a painter. I had been disheartened by the failure of my Drawing Number One and my Drawing Number Two. Grown-ups never understand anything by themselves, and it is tiresome for children to be always and forever explaining things to the.#결과6내가 쓴답paragraph = str(input())words = paragraph.split()count = 0for i in words:    if i.strip(\",.'\") == 'the':         count += 1         print(count)예제2표준 입력으로 물품 가격 여러 개가 문자열 한 줄로 입력되고, 각 가격은 ;(세미콜론)으로 구분되어 있습니다. 입력된 가격을 높은 가격순으로 출력하는 프로그램을 만드세요(input에서 안내 문자열은 출력하지 않아야 합니다). 이때 가격은 길이를 9로 만든 뒤 오른쪽으로 정렬하고 천단위로 ,(콤마)를 넣으세요.# 입력51900;83000;158000;367500;250000;59200;128500;1304000#결과1,304,000  367,500  250,000  158,000  128,500   83,000   59,200   51,900내가 쓴 답. 지저분하다.price = str(input())x = price.replace(';',' ')x = x.split()x = list(map(int, x))x = sorted(x, reverse = True)for i in x:    print('{0:&gt;9,}'.format(i))다른 방식price = list(map(int,input().split(';')))price.sort(reverse=True) # 기존 리스트의 값들을 역순으로 정렬해준다for i in price:    print('{0:&gt;9,}'.format(i))",
        "url": "/python-basic22"
    }
    ,
    
    "python-basic21": {
        "title": "Python - Python 2차원 리스트 사용하기",
            "author": "AhnSang0915",
            "category": "",
            "content": "Python    Python 기본    Python 숫자 계산하기    Python 변수 만들기    Python 출력 방법    Python 불과 비교, 논리 연산자    Python 문자열 사용하기    Python 리스트와 튜플 사용하기    Python 시퀀스 자료형 활용하기    Python 딕셔너리 사용하기    Python if 조건문으로 특정 조건일 때 코드 실행하기    Python else를 사용하여 두 방향으로 분기하기    Python elif를 사용하여 두 방향으로 분기하기    Python for 반복문    Python while 반복문    Python break, continue로 반복문 제어하기    Python 중첩루프    Python FizzBuzz 문제    Python 터틀 그래픽스로 그림 그리기    Python 리스트와 튜플 응용하기    Python 리스트와 튜플 응용하기 - 2    Python 2차원 리스트 사용하기    Python 문자열 응용하기    Python 딕셔너리 응용하기2차원 리스트 사용하기—1. 2차원 리스트 사용하기평면 구조의 2차원 리스트 만드는 법을 알아보자. 2차원 리스트는 가로X세로 형태로 이루어져 있으며 행 열 모두 0부터 시작한다.2차원 리스트를 만들고 요소에 접근하기평면 구조의 2차원 리스트 만드는 법을 알아보자. 2차원 리스트는 가로X세로 형태로 이루어져 있으며 행 열 모두 0부터 시작한다.a = [[10, 20], [30, 40], [50, 60]]a[[10, 20], [30, 40], [50, 60]]가로 2 세로 3의 2차원리스트가 만들어졌다. 리스트 입력시 알아보기 쉽게 아래 처럼 입력할 수도 있다.a = [[10, 20],     [30, 40],     [50, 60] ]2차원 리스트의 요소에 접근하기2차원 리스트의 요소에 접근하거나 값을 할당할 때는 리스트 뒤에 []를 두번 사용하며 []안에 세로 인덱스와 가로 인덱스를 지정해주면 된다.  리스트[세로인덱스][가로인덱스]  리스트[세로인덱스][가로인덱스]a = [[10, 20], [30, 40], [50, 60]]a[0] [0]            # 세로 인덱스 0, 가로 인덱스 0인 요소 출력10a[1][1]           # 세로 인덱스 1, 가로 인덱스 1인 요소 출력40a[2][1]           # 세로 인덱스 2, 가로 인덱스 0인 요소 출력60a[0][1] = 1000    # 세로 인덱스 0, 가로 인덱스 1인 요소에 값 할당a[0][1]10002차원 튜플다음과 같이 튜플 안에 튜플을 넣는 방식, 튜플 안에 리스트를 넣는 방식, 리스트 안에 튜플을 넣는 방식 등이 가능하다. 튜플은 내용을 변경할 수 없으므로 a는 안쪽과 바깥쪽 모두 요소를 변경할 수 없다. b는 안쪽 리스트만 요소를 변경할 수 있고, c는 바깥쪽 리스트만 요소를 변경할 수 있다.  튜플 = ((값, 값), (값, 값), (값, 값))  튜플 = ([값, 값], [값, 값], [값, 값])  리스트 = [(값, 값), (값, 값), (값, 값)]a = ((10, 20), (30, 40), (50, 60))    # 튜플 안에 튜플을 넣은 2차원 튜플b = ([10, 20], [30, 40], [50, 60])    # 튜플 안에 리스트를 넣음c = [(10, 20), (30, 40), (50, 60)]    # 리스트 안에 튜플을 넣음a[0][0] = 500        # 안쪽 튜플은 변경할 수 없음. TypeError 발생a[0] = (500, 600)    # 바깥쪽 튜플은 변경할 수 없음. TypeError 발생b[0][0] = 500        # 안쪽 리스트는 변경할 수 있음b[0] = (500, 600)    # 바깥쪽 튜플은 변경할 수 없음. TypeError 발생c[0][0] = 500        # 안쪽 튜플은 변경할 수 없음. TypeError 발생c[0] = (500, 600)    # 바깥쪽 리스트는 변경할 수 있음사람이 알아보기 쉽게 출력하기2차원 리스트의 사각형 구조를 유지하도록 출력하려면 pprint 모듈의 pprint함수를 사용한다. indent는 들여쓰기 칸 수, width는 가로 폭이다.from pprint import pprintpprint(a, indent=4, width=20)[   [10, 20],    [30, 40],    [50, 60]]2. 반복문으로 2차원 리스트의 요소를 모두 출력하기반복문을 사용해 2차원리스트의 요소를 출력하는 방법을 알아보자.for 반복문을 한 번만 사용하기for반복문을 한번만 사용하는 방식이다. 2차원 리스트에 for을 사용하면 가로 한 줄씩 반복하게 된다. 전체 리스트를 기준으로 보면 안쪽 리스트가 통째로 반복된다. for x, y in a:와 같이 in 앞에 변수를 두 개 지정해 안쪽 리스트에서 요소 두개를 꺼내온다. 당연히 in 앞에 변수의 개수는 2차원 리스트에서 가로 크기(안쪽 리스트의 요소 개수)와 일치해야 하고 특히, for반복문을 한번만 사용하는 방식은 2차원 리스트의 가로 크기가 크지 않을때 유용하다.a = [[10, 20], [30, 40], [50, 60]]for x, y in a:    # 리스트의 가로 한 줄(안쪽 리스트)에서 요소 두 개를 꺼냄     print(x, y)10 2030 4050 60for 반복문을 두 번 사용하기이번에는 for반복문을 두 번 사용해서 2차원 리스트의 요소를 출력해보자. 첫번쨰 for문에서 a리스트 안의 요소묶음을 i에 대입하고, 두번째 for문에서 대입한 요소묶음의 값 하나하나를 꺼내 j에 대입한다. 그리고 j의 두 값 사이를 공백으로 처리하여 출려하고 다음 프린트문에서 줄바꿈을 해준다.a = [[10, 20], [30, 40], [50, 60]]for i in a:    for j in i:        print(j,end = ' ')    print()    10 20 30 40 50 60 for와 range 사용하기이번에는 for range에 세로 크기와 가로 크기를 지정해 2차원 리스트의 요소를 인덱스로 접근해보자.for range에 세로크기와 가로 크기를 넣르면 인덱스로 사용할 수 있다. 첫번째 for문에서 리스트의 길이는 3으로 세로 열이 3줄이 되고, 두번째 for문에서 리스트 안의 리스트는 길이가2로 인덱스 0,1을 가져올 수 있다. a[i][j] 리스트의 세로 i, 가로 j 인덱스의 값을 출력한다.a = [[10, 20], [30, 40], [50, 60]] for i in range(len(a)):            # 세로 크기 #012    for j in range(len(a[i])):     # 가로 크기 #01        print(a[i][j], end=' ')    print()#for i in range(len(a)):            # 세로 크기    for j in range(len(a[i])):     # 가로 크기while 반복문을 한 번 사용하기이번에는 while 반복문을 사용하여 2차원 리스트의 요소를 출력해보자. len(a)의 값은 3이고 012까지의 수를 i와 비교한다. 리스트에 인덱스를 지정하여 값을 꺼내 올 때는 다음과 같이 변수 두 개를 지정해주면 가로 한 줄 에서 요소 두개를 한꺼번에 가져올 수 있다. 리스트 a의 인덱스 0의값 [10. 20]을 출력하고 나머지 값도 차례로 출력한다.a = [[10, 20], [30, 40], [50, 60]] i = 0while i &lt; len(a):    # 반복할 때 리스트의 크기 활용(세로 크기)    x, y = a[i]      # 요소 두 개를 한꺼번에 가져오기    print(x, y)    i += 1           # 인덱스를 1 증가시킴10 2030 4050 60while 반복문을 두 번 사용하기while 반복문을 2번 사용할때는 for 문을 두번 사용할때와 비슷하다. i로 세로의 인덱스 값을 불러오고 j 로 가로의 인덱스 값을 불러온다.a = [[10, 20], [30, 40], [50, 60]] i = 0while i &lt; len(a):           # 세로 크기    j = 0    while j &lt; len(a[i]):    # 가로 크기        print(a[i][j], end=' ')        j += 1              # 가로 인덱스를 1 증가시킴    print()    i += 1                  # 세로 인덱스를 1 증가시킴10 2030 4050 60아래와 같이 두번째 while에서 i를 증가시키게 되면 두번쨰 while문이 도는동안 증가된 i의 값이 출력되기 때문에 주의해야한다.# 틀린 코드i = 0while i &lt; len(a):    j = 0    while j &lt; len(a[i]):        print(a[i][j], end=' ')        j += 1        i += 1    # 안쪽 while에서 i를 증가시키면 안 됨. 잘못된 방법    print()3. 반복문으로 리스트 만들기for 반복문과 append를 활용하여 리스트를 만드는 방법을 알아보자.for 반복문으로 1차원 리스트 만들기요소 10개가 일렬로 늘어서 있는 1차원 리스트를 만들어보자. 지금까지 사용했던 일반적인 리스트 이다.range(10)은 0~9까지의 값을 i에 대입하고 그럴때마다 리스트 a에 요소 0을 추가한다. 총 10개의 0요소를 가진 리스트가 생성된다.a = []    # 빈 리스트 생성 for i in range(10):    a.append(0)    # append로 요소 추가 print(a)for 반복문으로 2차원 리스트 만들기for 반복문을 통해 2차원 리스트를 만들어 보자. 빈리스트 a가 밖의 리스트가 되고 안쪽의 line이 행렬을 나타내는 리스트가 된다. 두번째 for 문이 range(3)만큼 반복되어 리스트 a의 요소로 추가된다. 0,0을 총 3번 반복하게 되어 [[0, 0], [0, 0], [0, 0]]이 출력된다.a = []    # 빈 리스트 생성 for i in range(3):    line = []              # 안쪽 리스트로 사용할 빈 리스트 생성    for j in range(2):        line.append(0)     # 안쪽 리스트에 0 추가    a.append(line)         # 전체 리스트에 안쪽 리스트를 추가 print(a)# [[0, 0], [0, 0], [0, 0]]리스트 표현식으로 2차원 리스트 만들기리스트 표현식을 사용해 2차원 리스트를 만들어 보자. 0 for j in range(2) 로 [0, 0]의 요소를 만들고 for i in range(3) 로 3번 반복하여 리스트에 담아준다.  [[0, 0], [0, 0], [0, 0]]a = [[0 for j in range(2)] for i in range(3)]a[[0, 0], [0, 0], [0, 0]]# 만약 for 반복문을 한 번만 사용하고 싶다면 다음과 같이 식 부분에서 리스트 자체를 곱한다.a = [[0] * 2 for i in range(3)]a[[0, 0], [0, 0], [0, 0]]톱니형 리스트 만들기가로 크기가 불규칙한 톱니형 리스트를 만들어 보자. 가로 크기를 알고 있다고 가정하고 리스트 a에 톱니형 리스트의 가로 크기를 미리 저장해 놓았다. 이 리스트를 a를 for로 반복하면 가로 크기를 꺼내면서 5번 반복한다.a = [3, 1, 3, 2, 5]    # 가로 크기를 저장한 리스트b = []    # 빈 리스트 생성 for i in a:      # 가로 크기를 저장한 리스트로 반복    line = []    # 안쪽 리스트로 사용할 빈 리스트 생성    for j in range(i):    # 리스트 a에 저장된 가로 크기만큼 반복        line.append(0)    b.append(line)        # 리스트 b에 안쪽 리스트를 추가 print(b)#[[0, 0, 0], # [0], # [0, 0, 0], # [0, 0], # [0, 0, 0, 0, 0]]리스트 표현식을 활용하면 간단하게 만들수 있다. 가로 크기가 들어있는 리스트 [3, 1, 3, 2, 5]에서 꺼낸 숫자만큼 리스트 [0]을 곱해서 톱니형 리스트를 만들었다.a = [[0] * i for i in [3, 1, 3, 2, 5]]a[[0, 0, 0], [0], [0, 0, 0], [0, 0], [0, 0, 0, 0, 0]]]sorted로 2차원 리스트 정렬하기2차원 리스트를 정렬할 때는 sorted함수를 사용한다.  sorted(반복가능한객체, key=정렬함수, reverse=True 또는 False)sorted의 key에 정렬 함수를 지정하여 안쪽 리스트의 요소를 기준으로 정렬했다. student[1]은 안쪽 리스트의 인덱스 1을 뜻하며 ‘A’, ‘B’, ‘C’ 순으로 정렬한다. 마찬가지로 student[2]는 안쪽 리스트의 인덱스 2를 뜻하며 7, 19, 25 순으로 정렬한다students = [    ['john', 'C', 19],    ['maria', 'A', 25],    ['andrew', 'B', 7]] print(sorted(students, key=lambda student: student[1]))  # 안쪽 리스트의 인덱스 1을 기준으로 정렬print(sorted(students, key=lambda student: student[2]))  # 안쪽 리스트의 인덱스 2를 기준으로 정렬# 결과 [['maria', 'A', 25], ['andrew', 'B', 7], ['john', 'C', 19]][['andrew', 'B', 7], ['john', 'C', 19], ['maria', 'A', 25]]4. 2차원 리스트의 할당과 복사 알아보기2차원 리스트의 할당과 복사를 알아보자. 다음과 같이 2차원 리스트를 만든 뒤 다른 변수에 할당하고, 요소를 변경해보면 두 리스트에 모두 반영된다. b[0][0] = 500은 인덱스 세로 0, 가로 0에 500을 할당한다.a = [[10, 20], [30, 40]]b = ab[0][0] = 500a[[500, 20], [30, 40]]b[[500, 20], [30, 40]]리스트 a를 copy 메서드로 b에 복사한 뒤 b의 요소를 변경해보면 리스트 a와 b에 모두 반영된다.a = [[10, 20], [30, 40]]b = a.copy()b[0][0] = 500a[[500, 20], [30, 40]]b[[500, 20], [30, 40]]2차원 이상의 다차원 리스트는 리스트를 완전히 복사하려면 copy 메서드 대신 copy 모듈의 deepcopy 함수를 사용해야 한다. 이렇게 하면 b의 요소를 변경해도 a리스트에는 영향을 미치지 않는다. copy.deepcopy 함수는 중첩된 리스트(튜플)에 들어있는 모든 리스트(튜플)를 복사하는 깊은 복사(deep copy)를 해준다.a = [[10, 20], [30, 40]]import copy             # copy 모듈을 가져옴b = copy.deepcopy(a)    # copy.deepcopy 함수를 사용하여 깊은 복사b[0][0] = 500a[[10, 20], [30, 40]]b[[500, 20], [30, 40]]23.7 심사문제: 지뢰찾기표준 입력으로 2차원 리스트의 가로(col)와 세로(row)가 입력되고 그 다음 줄부터 리스트의 요소로 들어갈 문자가 입력됩니다. 이때 2차원 리스트 안에서 *는 지뢰이고 .은 지뢰가 아닙니다. 지뢰가 아닌 요소에는 인접한 지뢰의 개수를 출력하는 프로그램을 만드세요(input에서 안내 문자열은 출력하지 않아야 합니다).여러 줄을 입력 받으려면 다음과 같이 for 반복문에서 input을 호출한 뒤 append로 각 줄을 추가하면 됩니다(list 안에 문자열을 넣으면 문자열이 문자 리스트로 변환됩니다).matrix = []for i in range(row):    matrix.append(list(input()))입력3 3.***...*.출력2***432*1입력5 5..*.....*..*....***.*.*..출력01*21123*12*5323***1*4*31col, row = map(int, input().split())matrix = []    for i in range(row):    matrix.append(list(input()))  # 입력한 값을 리스트로 만들어준다.for i in range(col): # 0 ~ 2    for j in range(row): # 0 ~ 2        if matrix[i][j]=='*': #2차원 리스트의 각 인덱스 값을 *와 비교.            print('*',end='') #*와 비교해 같으면 *을 출력.                    else:            count=0 # 초기값            for k in range(i-1,i+2): # 위for문의 i 값을 가져와 대입                for l in range(j-1,j+2): #  위for문의 j 값을 가져와 대입                    if k&lt;0 or k&gt;=col or l&lt;0 or l&gt;=row: # 지뢰 찾기 주변 8칸중 첫칸, 끝칸의 주변 값을 확일할때 인덱스 범위를 넘어가면 continue로 다시 반복하게 함.                        continue                    elif matrix[k][l]=='*':                        count+=1 # 값이 * 과일치하면 count의 값을 1씩 더해준다.            print(count,end='')    print()",
        "url": "/python-basic21"
    }
    ,
    
    "python-basic20": {
        "title": "Python - Python 리스트와 튜플 응용하기 - 2",
            "author": "AhnSang0915",
            "category": "",
            "content": "Python    Python 기본    Python 숫자 계산하기    Python 변수 만들기    Python 출력 방법    Python 불과 비교, 논리 연산자    Python 문자열 사용하기    Python 리스트와 튜플 사용하기    Python 시퀀스 자료형 활용하기    Python 딕셔너리 사용하기    Python if 조건문으로 특정 조건일 때 코드 실행하기    Python else를 사용하여 두 방향으로 분기하기    Python elif를 사용하여 두 방향으로 분기하기    Python for 반복문    Python while 반복문    Python break, continue로 반복문 제어하기    Python 중첩루프    Python FizzBuzz 문제    Python 터틀 그래픽스로 그림 그리기    Python 리스트와 튜플 응용하기    Python 리스트와 튜플 응용하기 - 2    Python 2차원 리스트 사용하기    Python 문자열 응용하기    Python 딕셔너리 응용하기리스트와 튜플 응용하기 - 2—4. 리스트의 가장 작은 수, 가장 큰 수, 합계 구하기리스트에 저장된 값 중 가장 작은 수, 가장 큰 수, 요소의 합계를 구해보자.가장 작은 수와 가장 큰 수 구하기반복문을 통해 요소를 모두 반복하면서 숫자를 찾아보자. 리스트 a의 요소를 하나씩 꺼내 i에 대입해 준다. 그다음 i가 a[0]의 값인 38보다 작으면  smallest에 대입해주고 차례로 리스트a의 값을 꺼내면서 작은 값을 i에 대입하게 된다. 제일작은 수인 19를 smallest에 대입하고 종료된다. 큰 수를 찾고싶다면 부등호만 바꿔주면 된다.a = [38, 21, 53, 62, 19]smallest = a[0]for i in a:     if i &lt; smallest:         smallest = ismallest19# 리스트 a의 값중 가장 큰 값 찾기a = [38, 21, 53, 62, 19]largest = a[0]for i in a:     if i &gt; largest:         largest = ilargest62sort메서드를 사용하여 요소들을 정렬한뒤 가장 작은값과 큰값을 찾아보자.a = [38, 21, 53, 62, 19]a.sort()a[0]19#가장 큰값은 정렬을 반대로한 첫번쨰 요소a.sort(reverse=True)a[0]62파이썬에서 제공하는 min, max함수를 사용하면 더 간단하다.a = [38, 21, 53, 62, 19]min(a)19max(a)62요소의 합계 구하기이번에는 리스트에서 요소의 합계를 구해보자. 함계를 구할 때도 반복문을 사용할 수 있다. 리스트 a의 요소를 하나씩 꺼내 i에 대입하고 i의 값을 반복해 꺼내 더해준다. 이때 x의 값은 0부터 시작해야한다. x에 다른 값을 할당하면 초기에 x의 값이 추가된채 더해지기 때문에 원하는 값을 얻을 수 없다.a = [10, 10, 10, 10, 10]x = 0for i in a:     x += i # x = x + ix50파이썬에서 제공하는 sum함수를 사용하면 더 간단한다.a = [10, 10, 10, 10, 10]sum(a)50여기서 설명한 min, max, sum에는 리스트뿐만 아니라 모든 반복 가능한 객체(iterable)를 넣을 수 있다. 반복 가능한 객체는 리스트, 튜플, 딕셔너리, 세트, range등 여러 가지가 있다.5. 리스트 표현식 사용하기파이썬의 리스트가 특이한 점은 리스트 안에 for 반복문과 if 조건문을 사용할 수 있다는 점이다. 이렇게 리스트 안에 식, for 반복문, if 조건문 등을 지정하여 리스트를 생성하는 것을 리스트 컴프리헨션(list comprehension)이라고 한다. 컴프리헨션은 능력, 이해력, 시험 등의 뜻도 있지만, 어떤 것을 잡아서 담아둔다는 뜻이 있다. 즉, 식으로 지정해서 생성된 것을 리스트로 잡아두는 것이 리스트 컴프리헨션이다. 개념적으로 보면 “리스트 표현식”이라고 할 수 있다.리스트 표현식은 다음과 같이 리스트 안에 식, for반복문을 지정한다.  [식 for 변수 in 리스트]  list(식 for 변수 in 리스트)a = [i for i in range(10)]        # 0부터 9까지 숫자를 생성하여 리스트 생성a[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]b = list(i for i in range(10))    # 0부터 9까지 숫자를 생성하여 리스트 생성b[0, 1, 2, 3, 4, 5, 6, 7, 8, 9][i for i in range(10)]는 변수 i를 그대로 사용하지만, 다음과 같이 식 부분에서 i를 다른 값과 연산하면 각 연산의 결과를 리스트로 생성한다. 아래와 같이 i+5와 i * 2를 식에 넣으면 i의 값에 연산을 하고 리스트에 담아준다.c = [i + 5 for i in range(10)]    # 0부터 9까지 숫자를 생성하면서 값에 5를 더하여 리스트 생성c[5, 6, 7, 8, 9, 10, 11, 12, 13, 14]d = [i * 2 for i in range(10)]    # 0부터 9까지 숫자를 생성하면서 값에 2를 곱하여 리스트 생성d[0, 2, 4, 6, 8, 10, 12, 14, 16, 18]리스트 표현식에서 if 조건문 사용하기이번에는 리스트 표현식에서 if조건문을 사용해 보자. 다음과 같이 if 조건문은 for 반복문 뒤에 지정한다.  [식 for 변수 in 리스트 if 조건식]  list(식 for 변수 in 리스트 if 조건식)[i for i in range(10) if i % 2 == 0]는 0부터 9까지 숫자를 생성하여 2의 배수인 숫자(짝수)로만 리스트를 생성한다. 즉, 다음과 같이 for 반복문 뒤에 if 조건문을 지정하면 숫자를 생성한 뒤 if 조건문에서 특정 숫자만 뽑아내서 리스트를 생성한다.a = [i for i in range(10) if i % 2 == 0]    # 0~9 숫자 중 2의 배수인 숫자(짝수)로 리스트 생성a[0, 2, 4, 6, 8]마찬가지로 식에 연산을 추가해 리스트를 만들 수 있다.b = [i + 5 for i in range(10) if i % 2 == 1]    # 0~9 숫자 중 홀수에 5를 더하여 리스트 생성b[6, 8, 10, 12, 14]for 반복문과 if 조건문을 여러 번 사용하기리스트 표현식은 for과 if를 여러번 사용할 수도 있다.[식 for 변수1 in 리스트1 if 조건식1     for 변수2 in 리스트2 if 조건식2     ...     for 변수n in 리스트n if 조건식n] list(식 for 변수1 in 리스트1 if 조건식1         for 변수2 in 리스트2 if 조건식2         ...         for 변수n in 리스트n if 조건식n)아래는 i와 j에 각각 range로 값을 대입해 구구단을 만들었다.a = [i * j for j in range(2, 10) for i in range(1, 10)]a[2, 4, 6, 8, 10, 12, 14, 16, 18, 3, 6, 9, 12, 15, 18, 21, 24, 27, 4, 8, 12, 16, 20, 24, 28, 32, 36, 5, 10, 15, 20, 25, 30, 35, 40, 45, 6, 12, 18, 24, 30, 36, 42, 48, 54, 7, 14, 21, 28, 35, 42, 49, 56, 63, 8, 16, 24, 32, 40, 48, 56, 64, 72, 9, 18, 27, 36, 45, 54, 63, 72, 81]# 들여쓰기를 해주는 게좋다.a = [i * j for j in range(2, 10)            for i in range(1, 10)]6. 리스트에 map 사용하기리스트와 반복문을 사용해 모든 요소를 출력해 보자.for 반복문으로 요소 출력하기리스트에 map을 사용해보자. map은 리스트의 요소를 지정된 함수로 처리해주는 함수이다.(map은 원본 리스트를 변경하지 않고 새 리스트를 생성한다.)  list(map(함수, 리스트))  tuple(map(함수, 튜플))실수가 저장된 리스트가 있을때 리스트의 모든 요소를 정수로 변환해 주자. 먼저 for반복문으로 변환하는 방법이다. len(a)로 리스트의 길이를 구하고 range로 인덱스 값을 i에 대입해 줬다. 요소를 하나씩 꺼내 int (정수)로 변환해 다시 저장했다.a = [1.2, 2.5, 3.7, 4.6]for i in range(len(a)):     a[i] = int(a[i])a[1, 2, 3, 4]이번에는 map을 사용하여 변환해보자. a = list(map(int, a))한 줄로 변환 할 수 있다. map에 리스트와 int를 넣으면 리스트의 모든 요소를 int를 사용해서 변환한다. 다음에 list를 사용해서 map의 결과를 다시 리스트로 만들어준다.a = [1.2, 2.5, 3.7, 4.6]a = list(map(int, a))a[1, 2, 3, 4]range를 사용해 숫자를 만든 뒤 문자열로 변환하는것도 가능하다.a = list(map(str, range(10)))a['0', '1', '2', '3', '4', '5', '6', '7', '8', '9']input().split()과 map지금까지 input().split()으로 값을 여러 개 입력받고 정수, 실수로 변환할 때도 map을 사용했었다. 그렇게 쓰일수 있는 이유는 input().split()의 결과가 문자열 리스트라서 map을 사용할 수 있었던 것이다. 10 20을 입력하면 [‘10’, ‘20’]처럼 문자열 두 개가 들어있는 리스트가 만들어진다.a = input().split()10 20 (입력)a['10', '20']이제 map을 사용해 정수로 변환해 보자. 10 20을 입력하면 맵 객체(map object)가 만들어지는데 이 상태로는 안에 들어있는 값을 볼 수 없다. list를 사용해서 리스트로 출력하고 리스트를 보면 [10, 20]처럼 정수 두 개가 들어있는걸 확인할 수 있다.a = map(int, input().split())10 20 (입력)a&lt;map object at 0x03DFB0D0&gt;list(a)[10, 20]이 리스트 [10, 20]을 변수 두 개에 저장하면 지금까지 사용한 a, b = map(int, input().split())와 같은 동작이 된다.a, b = [10, 20]a10b20사실 map이 반환하는 맵 객체는 이터레이터라서 변수 여러 개에 저장하는 언패킹(unpacking)이 가능하다. 그래서 a, b = map(int, input().split())처럼 list를 생략한 것이다a, b = map(int, input().split())을 풀어서 쓰면 다음과 같은 코드가 된다.x = input().split()    # input().split()의 결과는 문자열 리스트m = map(int, x)        # 리스트의 요소를 int로 변환, 결과는 맵 객체a, b = m               # 맵 객체는 변수 여러 개에 저장할 수 있음7. 튜플 응용하기이번에는 튜플의 메서드와 다양한 사용 방법을 알아보자. 튜플은 리스트와 달리 내용을 변경할  수 없다. 따라서 내용을 변경하는 append같은 메서드는 사용할 수 없고, 요소의 정보를 구하는 메서드만 사용할 수 있다.튜플에서 특정 값의 인덱스 구하기index(튜플요소의 값) 은 튜플에서 특정 값의 인덱스 값을 구할 수 있다. 같은 값이 여러 개일 경우 처음 찾은 인덱스를 구한다.a = (38, 21, 53, 62, 19, 53)a.index(53)2특정 값의 개수 구하기count(튜플요소의 값)은 튜플에서 특정 값의 개수를 구한다. 다음은 튜플(10, 20, 30, 15, 20, 40)에서 20의 개수를 구한다.a = (10, 20, 30, 15, 20, 40)a.count(20)2for 반복문으로 요소 출력하기for 반복문으로 튜플의 요소를 출력한다.a = (38, 21, 53, 62, 19)for i in a:     print(i, end = ' ')38 21 53 62 19튜플 표현식 사용하기튜플을 리스트 표현식처럼 생성할 떄는 다음과 같이 tuple안에 for반복문과 if 조건문을 지정한다.  tuple(식 for 변수 in 리스트 if 조건식)a = tuple(i for i in range(10) if i % 2 == 0)a(0, 2, 4, 6, 8)참고로 ( )(괄호) 안에 표현식을 넣으면 튜플이 아니라 제너레이터 표현식이된다.(뒤에 배울 내용)tuple에 map 사용하기튜플에 map을 사용하는 방법도 리스트와 같다.a = (1.2, 2.5, 3.7, 4.6)a = tuple(map(int, a))a(1, 2, 3, 4)튜플에서 가장 작은 수, 가장 큰 수, 합계 구하기튜플도 min, max 함수로 가장 작은 수와 가장 큰 수를 구하고, sum 함수로 요소의 합계를 구할 수 있다.a = (38, 21, 53, 62, 19)min(a)19max(a)62sum(a)193",
        "url": "/python-basic20"
    }
    ,
    
    "python-basic19": {
        "title": "Python - Python 리스트와 튜플 응용하기 - 1",
            "author": "AhnSang0915",
            "category": "",
            "content": "Python    Python 기본    Python 숫자 계산하기    Python 변수 만들기    Python 출력 방법    Python 불과 비교, 논리 연산자    Python 문자열 사용하기    Python 리스트와 튜플 사용하기    Python 시퀀스 자료형 활용하기    Python 딕셔너리 사용하기    Python if 조건문으로 특정 조건일 때 코드 실행하기    Python else를 사용하여 두 방향으로 분기하기    Python elif를 사용하여 두 방향으로 분기하기    Python for 반복문    Python while 반복문    Python break, continue로 반복문 제어하기    Python 중첩루프    Python FizzBuzz 문제    Python 터틀 그래픽스로 그림 그리기    Python 리스트와 튜플 응용하기    Python 리스트와 튜플 응용하기 - 2    Python 2차원 리스트 사용하기    Python 문자열 응용하기    Python 딕셔너리 응용하기리스트와 튜플 응용하기파이썬 리스트의 여러 기능들을 알아보자. 요소를 추가/삭제 하는 메소드와 정보를 조회하는 메서드 등이 있다. for문과 결합한 연속적이고 반복적인 값도 쉽게 처리할 수 있다.1. 리스트 조작하기리스트에 요소 추가하기  append: 요소 하나를 추가  extend: 리스트를 연결하여 확장  insert: 특정 인덱스에 요소 추가리스트에 요소 하나 추가하기append를 사용해 리스트 끝에 요소 하나를 추가해보자. 리스트 [10, 20, 30]에 500을 추가하여 리스트는 [10, 20, 30, 500]이 된다. 리스트에 요소를 추가하는 것 이지 새로운 리스트가 생성되는 것은 아니다.a = [10, 20, 30]a.append(500)a[10, 20, 30, 500]len(a)4비어있는 리스트에도 값을추가할 수 있다.a = []a.append(10)a[10]리스트 안에 리스트 추가하기append는 append(리스트)처럼 리스트를 넣으면 리스트 안에 리스트가 들어간다. 다음은 리스트 a안에 [500, 600]이 들어가서 중첩 리스트가 만들어진다. 요소 하나를 리스트 a의 끝에 추가해 주기 때문에 리스트의 길이가 5가 아닌 4가된다. 즉, append는 항상 리스트의 길이가 1씩 증가한다.a = [10, 20, 30]a.append([500, 600])a[10, 20, 30, [500, 600]]len(a)4리스트 확장하기리스트에 요소를 여러개 추가할 수도 있다. extend(리스트)를 사용하여 끝에 다른 리스트를 연결해 준다. 다음은 리스트 [10, 20, 30]에 다른 리스트 [500, 600]을 연결하여 [10, 20, 30, 500, 600]이 된다. 리스트를 연결 했음으로 리스트의 길이는 5가 된다.a = [10, 20, 30]a.extend([500 ,600])a[10, 20, 30, 500, 600]len(a)5리스트의 특정 인덱스에 요소 추가하기insert는 리스트의 특정 인덱스에 요소 하나를 추가한다. insert(인덱스, 요소)로 사용하고 아래는 [10, 20, 30]의 인덱스 2에 500을 추가하여 [10, 20, 500, 30]이 된다.a = [10, 20, 30]a.insert(2, 500) # index 2 위치에 500요소 추가a[10, 20, 500, 30]len(a)4insert에서 자주 사용하는 패턴은 2가지이다.  insert(0, 요소): 리스트의 맨 처음에 요소를 추가  insert(len(리스트), 요소): 리스트 끝에 요소를 추가리스트의 0번 인덱스에 500추가a = [10, 20, 30]a.insert(0, 500)a[500, 10, 20, 30]insert를 하고 리스트의 마지막 인덱스보다 큰 값을 지정하면 리스트 끝에 요소 하나를 추가할 수 있다.a = [10, 20, 30]a.insert(len(a), 500)a[10, 20, 30, 500]len(리스트)는 마지막 인덱스보다 1이 더 크기 때문에 리스트 끝에 값을 추가할때 자주 사용한다. 이방법은 a.append(500)과 같다. insert는 요소 하나를 추가하므로 insert에 리스트를 넣으면 append처럼 리스트 안에 리스트가 들어간다. 다음은 리스트 [10, 20, 30]의 인덱스 1에 리스트 [500, 600]을 추가하여 중첩 리스트가 된다.a = [10, 20, 30]a.insert(1, [500, 600])a[10, [500, 600], 20, 30]만약 리스트 중간에 요소 여러개를 추가하고 싶다면 슬라이스 요소 할당하기를 활용하면 된다. 다음은 리스트 [10, 20, 30]의 인덱스 1부터 500, 600을 추가하여 [10, 500, 600, 20, 30]이 된다.a = [10, 20, 30]a[1:1] = [500, 600] #인덱스 1의위치에 500, 600요소 추가a[10, 500, 600, 20, 30]리스트에서 요소 삭제하기리스트에서 요소를 삭제하는 방법이다.  pop: 마지막 요소 또는 특정 인덱스의 요소를 삭제  remove: 특정 값을 찾아서 삭제리스트에서 특정 인덱스의 요소를 삭제하기pop()은 리스트의 마지막 요소를 삭제한 뒤 삭제한 요소를 반환한다. 다음은 리스트 [10, 20, 30]에서 pop으로 마지막 요소를 삭제한 뒤 30을 반환합니다. 따라서 리스트는 [10, 20]이 된다.a = [10, 20, 30]a.pop() #마지막 요소인 30을 삭제하고 반환한다.30a[10, 20]원하는 인덱스의 요소를 삭제하려면 pop에 인덱스를 지정하면 된다.a = [10, 20, 30]a.pop(1) #인덱스 1의 위치의 요소(20)를 삭제하고 반환한다.20a[10, 30]]# 또는a = [10, 20, 30]del a[1] #인덱스 1의 위치의 요소를 삭제하지만 반환하지는 않는다.a[10, 30]리스트에서 특정 값을 찾아서 삭제하기pop과 del은 인덱스로 요소를 삭제한다. 리스트에서 원하는 값을 찾아 삭제하고 싶을때는 remove를 사용한다. remove(값)은 리스트에서 특정 값을 찾아서 삭제한다. 다음은 리스트 [10, 20, 30]에서 20을 삭제하여 [10, 30]이 된다.a = [10, 20, 30]a.remove(20)a[10, 30]만약 리스트에 같은 값이 여러 개 있을 경우 처음 찾은 값을 삭제한다.a = [10, 20, 30, 20]a.remove(20)a[10, 30, 20]리스트로 스택과 큐 만들기리스트 메서드로 스택(stack)과 큐(queue)를 만들 수 있다. 스택이란 한쪽으로만 들어오고 나가는 구조이다. ABC가들어오면 CBA순서로 나갈 수 있다. 큐라는 구조는 들어오는 곳과 나가는 곳이 따로 있는 구조이다. ABC가 들어가면 A가 먼저 삭제되고 나머지가 삭제되는 밀어내기 구조이다. append와 pop을 호출하는 그림을 90도 돌리면 스택의 모습이 된다.여기서 pop() 대신 pop(0)을 사용하면 큐가 된다.물론 append(), pop(0)이 아닌 insert(0, 요소), pop()을 사용해서 추가/삭제 방향을 반대로 해도 큐가 된다.파이썬에서 스택은 리스트를 그대로 활용해도 되지만, 큐는 좀 더 효율적으로 사용할 수 있도록 덱(deque, double ended queue)이라는 자료형을 제공한다. 덱은 양쪽 끝에서 추가/삭제가 가능한 자료 구조다.  deque(반복가능한객체)from collections import deque    # collections 모듈에서 deque를 가져옴a = deque([10, 20, 30])adeque([10, 20, 30])a.append(500)    # 덱의 오른쪽에 500 추가adeque([10, 20, 30, 500])a.popleft()     # 덱의 왼쪽 요소 하나 삭제10adeque([20, 30, 500])리스트에서 특정 값의 인덱스 구하기index(값)은 리스트에서 특정 값의 인덱스를 구한다. 이때 같은 값이 여러 개일 경우 처음 찾은 인덱스를 구한다(가장 작은 인덱스). 다음은 20이 두 번째에 있으므로 인덱스 1이 나온다.a = [10, 20, 30, 15, 20, 40]a.index(20)1특정 값의 개수 구하기count(값)은 리스트에서 특정 값의 개수를 구한다. 다음은 리스트 a에서 20의 개수를 구합니다.a = [10, 20, 30, 15, 20, 40]a.count(20)2특정 값의 개수 구하기reverse()는 리스트에서 요소의 순서를 반대로 뒤집는다.a = [10, 20, 30, 15, 20, 40]a.reverse()a[40, 20, 15, 30, 20, 10]리스트의 요소를 정렬하기sort()는 리스트의 요소을 작은 순서대로 정렬힌다(오름차순).  sort() 또는 sort(reverse=False): 리스트의 값을 작은 순서대로 정렬(오름차순)  sort(reverse=True): 리스트의 값을 큰 순서대로 정렬(내림차순)  sorted함수는 정렬된 새 리스트를 생성a = [10, 20, 30, 15, 20, 40]a.sort()    # a의 내용을 변경하여 정렬a[10, 15, 20, 20, 30, 40]b = [10, 20, 30, 15, 20, 40]sorted(b)    # 정렬된 새 리스트를 생성[10, 15, 20, 20, 30, 40]리스트의 모든 요소를 삭제하기clear()는 리스트의 모든 요소를 삭제한다.a = [10, 20, 30]a.clear()a[]# clear대신 del a[:]로 리스트 전체를 지정해 모든 요소를 삭제할 수도 있다.a = [10, 20, 30]del a[:]a[]리스트를 슬라이스로 조작하기리스트는 메서드를 사용하지 않고, 슬라이스로 조작할 수도 있다. 다음은 리스트 끝에 값이 한개 들어있는 리스트를 추가한다. a[len(a):] = [500]과 같이 값이 한 개 들어있는 리스트를 할당하면 리스트 a 끝에 값을 한 개 추가하며 a.append(500)과 같다.a = [10, 20, 30]a[len(a):] = [500]a[10, 20, 30, 500]a[len(a):] = [500, 600]과 같이 요소가 여러 개 들어있는 리스트를 할당하면 리스트 a 끝에 다른 리스트를 연결하며 a.extend([500, 600])과 같다.a = [10, 20, 30]a[len(a):] = [500, 600]a[10, 20, 30, 500, 600]리스트를 슬라이스로 조작하기리스트(시퀀스 객체)가 비어있는지 확인 하려면 if조건문을 사용하면 된다.if not len(seq):    # 리스트가 비어 있으면 Trueif len(seq):        # 리스트에 요소가 있으면 True위와같이 판단할 수도 있지만 리스트(시퀀스 객체)를 바로 if조건문으로 판단하는 방법이 좋다.if not seq:    # 리스트가 비어 있으면 Trueif seq:        # 리스트에 요소가 있으면 True리스트가 비어있는 지확인하는 방법은 리스트의 마지막 요소에 접근할 때 유용하게 사용할 수 있다.리스트가 비어있는 경우에 인덱스를 -1로 지정하면 에러가 발생한다. 이때는 if 조건문을 활용해 리스트에 요소가 있을 때 만 마지막 요소를 가져오면 된다.seq = []if seq:               # 리스트에 요소가 있는지 확인    print(seq[-1])    # 요소가 있을 때만 마지막 요소를 가져옴2. 리스트의 할당과 복사 알아보기 할당과 복사는 비슷한것 같지만 큰 차이가 있다. 아래와 같이 b = a로 리스트를 다른 변수에 할당하면 리스트는 두 개가 될 것 같지만 실제로는 리스트가 한개이다.a = [0, 0, 0, 0, 0]b = aa와 b를 is 연산자로 비교해보면 True가 나온다. 즉, 변수 이름만 다를 뿐 리스트 a와 b는 같은 객체이다. a와 b는 같으므로 b[2] = 99와 같이 리스트 b의 요소를 변경하면 a와 b에 모두 반영된다.a is bTrue&gt;&gt;&gt; b[2] = 99&gt;&gt;&gt; a[0, 0, 99, 0, 0]&gt;&gt;&gt; b[0, 0, 99, 0, 0]리스트 a와 b를 완전히 두 개로 만들려면 copy 메서드로 모든 요소를 복사해야 한다. b = a.copy()와 같이 copy를 사용한 뒤 b에 할당해주면 리스트 a의 요소가 모두 b에 복사된다.a = [0, 0, 0, 0, 0]b = a.copy()a와 b를 is 연산자로 비교해 보면 False가 나온다. 즉, 두 리스트는 다른 객체이다. 그러나 복사된 요소는 같으므로 ==로 비교하면 True가 나온다. 이제 리스트 a와 b는 별개이므로 한쪽의 값을 변경해도 다른 리스트에 영향을 미치지 않는다. b의 요소를 변경해도 a의요소는 바뀌지 않았다.&gt;&gt;&gt; a is bFalse&gt;&gt;&gt; a == bTrue&gt;&gt;&gt; b[2] = 99&gt;&gt;&gt; a[0, 0, 0, 0, 0]&gt;&gt;&gt; b[0, 0, 99, 0, 0]3. 반복문으로 리스트의 요소를 모두 출력하기리스트와 반복문을 사용해 모든 요소를 출력해 보자.for 반복문으로 요소 출력하기for 반복문은 in뒤에 리스트를 지정한다.for 변수 in 리스트:     반복할 코드다음은 for로 리스트 a의 모든 요소를 출력한다. for i in a:는 리스트 a에서 요소를 꺼내서 i에 저장하고, 꺼낼 때마다 코드를 반복한다.a = [38, 21, 53, 62, 19]for i in a:     print(i)3821536219인덱스와 요소를 함께 출력하기for 반복문으로 요소를 출력할 때 인덱스도 함께 출력 해야 할 이때는 enumerate를 사용한다.  for 인덱스, 요소 in enumerate(리스트):for index, value in enumerate(a):와 같이 enumerate에 리스트를 넣으면 for 반복문에서 인덱스와 요소를 동시에 꺼내 올 수 있다.a = [38, 21, 53, 62, 19]for index, value in enumerate(a):     print(index, value)0 381 212 533 624 19앞의 코드는 인덱스를 0부터 출력하는데 1부터 출력하고 싶을 수도 있습니다. 다음과 같이 그냥 index + 1을 출력하면 되겠다.for index, value in enumerate(a):     print(index + 1, value)1 382 213 534 625 19위와같이 +1을 해줘도 되지만 다음과 같이 enumerate에 start를 지정해주면 된다. enumerate(a, start=1)처럼 start에 1을 지정하여 인덱스가 1부터 시작하도록 만들었다.  for 인덱스, 요소 in enumerate(리스트, start=숫자):for index, value in enumerate(a, start=1):     print(index, value)1 382 213 534 625 19for 반복문에서 인덱스로 요소를 출력하기for에서 인덱스를 지정하여 요소를 가져올 때는 range에 len으로 리스트의 길이(요소 개수)를 구해서 넣어주면 인덱스를 순서대로 만들어준다.a = [38, 21, 53, 62, 19]for i in range(len(a)):     print(a[i])3821536219while반복문으로 요소 출력하기이번에는 while 반복문으로 리스트의 요소를 출력해보자. len(a)는 5이고 index의 가장 큰 값은 4이기 때문에 i가 0부터 4까지 while문이 돌게 된다.a = [38, 21, 53, 62, 19]i = 0while i &lt; len(a):     print(a[i])     i += 13821536219만약 i &lt;= len(a)처럼 &lt;=을 사용하면 리스트의 범위를 벗어나게 되므로 주의해야 한다.a = [38, 21, 53, 62, 19]i = 0while i &lt;= len(a):     print(a[i])     i += 13821536219Traceback (most recent call last):  File \"&lt;stdin&gt;\", line 2, in &lt;module&gt;IndexError: list index out of rangewhile 반복문 안에서 요소를 출력할 때는 print(a[i])와 같이 리스트의 인덱스 부분에 i를 지정하여 출력한다. 그다음에는 i가 1씩 증가하도록 만들면 된다.while i &lt; len(a):    print(a[i])    i += 1",
        "url": "/python-basic19"
    }
    ,
    
    "practice-2": {
        "title": "Python으로 웹 스크래퍼 만들기-1",
            "author": "AhnSang0915",
            "category": "",
            "content": "Python으로 웹 스크래퍼 만들기-1indeed.py파일import requestsfrom bs4 import BeautifulSoupLIMIT = 50URL = f\"https://kr.indeed.com/%EC%B7%A8%EC%97%85?q=python&amp;limit={LIMIT}&amp;radius=25&amp;start=0&amp;vjk=0699e6dbb5a0ec38\"def get_last_page():  result = requests.get(URL)  soup = BeautifulSoup(result.text,\"html.parser\")  # html의 내용을 가져온다.  pagination = soup.find(\"div\",{\"class\" : \"pagination\"})  # html의 내용중 pagination을 찾는다.                            links = pagination.find_all('a')  pages = [] #for반복문으로 찾은 link을 리스트에 담아주기 위해서 pages라는 빈 리스트를 생성.  for link in links[:-1]:    pages.append(int(link.string)                )  max_page = pages[-1]  return max_pagedef extract_job(html):    title = html.find(\"span\",title=True).text    company = html.find(\"span\", {\"class\" : \"companyName\"}).string    location = html.find(\"div\",{\"class\" : \"companyLocation\"}).string    job_id = html[\"data-jk\"]    return{'title': title, 'company': company, 'location': location,'link' : f\"https://kr.indeed.com/%EC%B7%A8%EC%97%85?q=python&amp;radius=25&amp;start=50&amp;vjk={job_id} \"}def extract_jobs(last_pages):  jobs = []  for page in range(last_pages):    print(f\"Scrapping page {page}\")    result = requests.get(f\"{URL}&amp;start={page*LIMIT}\")    soup = BeautifulSoup(result.text,\"html.parser\")    results = soup.find_all('a',{\"class\" : \"fs-unmask\"} )    for result in results:      job = extract_job(result)      jobs.append(job)  return(jobs)def get_jobs():  last_page = get_last_page()  jobs = extract_jobs(last_page)  return jobsmain.pyfrom indeed import get_jobs as get_indeed_jobsfrom so import get_jobs as get_so_jobs#indeed_jobs = get_indeed_jobs()so_jobs = get_so_jobs()#print(indeed_jobs)so.pyimport requestsfrom bs4 import BeautifulSoup# s-paginationURL = f\"https://stackoverflow.com/jobs/companies?q=python\"def get_last_page():  result = requests.get(URL)  soup = BeautifulSoup(result.text, \"html.parser\")    pages = soup.find(\"div\", {\"class\":\"s-pagination\"}).find_all(\"a\")  last_page = pages[-2].get_text(strip=True)  return int(last_page)def extract_jobs(last_page):  jobs = []  for page in range(last_page):    result = requests.get(f\"{URL}&amp;pg={page+1}\")    soup = BeautifulSoup(result.text, \"html.parser\")    results = soup.find_all(\"div\", {\"class\":\"d-flex\"})    for result in results:      print(results)          def get_jobs():  last_page = get_last_page()  jobs = extract_jobs(last_page)  return jobs",
        "url": "/practice-2"
    }
    ,
    
    "python-basic18": {
        "title": "Python - Python 터틀 그래픽스로 그림 그리기",
            "author": "AhnSang0915",
            "category": "",
            "content": "Python    Python 기본    Python 숫자 계산하기    Python 변수 만들기    Python 출력 방법    Python 불과 비교, 논리 연산자    Python 문자열 사용하기    Python 리스트와 튜플 사용하기    Python 시퀀스 자료형 활용하기    Python 딕셔너리 사용하기    Python if 조건문으로 특정 조건일 때 코드 실행하기    Python else를 사용하여 두 방향으로 분기하기    Python elif를 사용하여 두 방향으로 분기하기    Python for 반복문    Python while 반복문    Python break, continue로 반복문 제어하기    Python 중첩루프    Python FizzBuzz 문제    Python 터틀 그래픽스로 그림 그리기    Python 리스트와 튜플 응용하기    Python 리스트와 튜플 응용하기 - 2    Python 2차원 리스트 사용하기    Python 문자열 응용하기    Python 딕셔너리 응용하기터틀 그래픽스로 그림 그리기터틀 그래픽스(Turtle graphics) 모듈을 사용해서 간단한 그림을 그려보자.1. 사각형 그리기t.shape(‘turtle’)까지 입력하면 파이썬 터틀 그래픽스(Python Turtle Graphics) 창이 표시되고 오른쪽을 바라보는 거북이가 나온다.import turtle as tt.shape('turtle')t.forward(100)t.forward(100)을 입력하면 거북이를 100픽셀만큼 앞으로 이동시킨다. t.right(90)를 입력하면 거북이가 오른쪽으로 90도 회전한다. 다시 t.forward(100)을 입력하면 회전한 방향에서 100픽셀 만큼 이동하게된다. 이런식으로 반복하여 사각형을 그려보자.  fd, bk, lt, rt 같이 짧게 줄여서 입력할 수 있다.  앞으로 이동: forward, fd  뒤로 이동: backward, bk, back  왼쪽으로 회전: left, lt  오른쪽으로 회전: right, rtimport turtle as t t.shape('turtle') t.fd(100)t.rt(90)t.fd(100)t.rt(90)t.fd(100)t.rt(90)t.fd(100)2. 다각형 그리기이번에는 반복문을 사용해 사각형을 그려보자.import turtle as t t.shape('turtle')for i in range(4):    # 사각형이므로 4번 반복    t.forward(100)    t.right(90)오각형 그리기오각형의 한각의 크기는 360/5를 하여 구할 수 있다.import turtle as t t.shape('turtle')for i in range(5):      # 오각형이므로 5번 반복    t.forward(100)    t.right(360 / 5)    # 360을 5로 나누어서 외각을 구함입력값에 해당하는 다각형 그리기이 소스 코드를 응용해서 사용자가 숫자를 입력하면 해당 숫자에 해당하는 다각형을 그려보자.import turtle as t n = int(input())        # 사용자의 입력을 받음t.shape('turtle')for i in range(n):      # n번 반복    t.forward(100)    t.right(360 / n)    # 360을 n으로 나누어서 외각을 구함다각형에 색칠하기소스 코드를 실행해보면 빨간색 육각형이 나온다. 먼저 color는 펜의 색을 설정한다. 여기서는 ‘red’를 지정하여 빨간색으로 만들었다. 그리고 도형을 그리기 전에 t.begin_fill()로 색칠할 준비를 한다. 그다음에 for 반복문으로 도형을 그린 뒤에 t.end_fill()을 사용하면 도형에 현재 펜 색이 칠해진다. 색은 rgb 코드로도 입력할 수 있다.import turtle as t n = 6    # 육각형t.shape('turtle')t.color('red')          # 펜의 색을 빨간색으로 설정t.begin_fill()          # 색칠할 영역 시작for i in range(n):      # n번 반복    t.forward(100)    t.right(360 / n)    # 360을 n으로 나누어서 외각을 구함t.end_fill()            # 색칠할 영역 끝    3. 복잡한 도형 그리기이번에는 원을 그려보자. 터틀에서 원을 그릴 때는 circle을 사용한다. t.circle에 120을 지정하여 반지름이 120인 원을 그렸다.import turtle as tt.shape('turtle')t.circle(120)원을 반복해서 그리기for 반복문을 사용해 원을 반복해서 그려보자. 오른쪽으로 6도씩 회전하면서 원을 그리게 된다. speed는 거북이의 속도를 설정한다. 속도는 다음과 같이 문자열 또는 숫자로 설정할 수 있다(숫자는 0.5부터 10까지 설정할 수 있다). 여기서는 ‘fastest’를 지정해서 가장 빠른 속도로 그렸다.  ‘fastest’: 0  ‘fast’: 10  ‘normal’: 6  ‘slow’: 3  ‘slowest’: 1import turtle as t n = 60    # 원을 60번 그림t.shape('turtle')t.speed('fastest')      # 거북이 속도를 가장 빠르게 설정for i in range(n):    t.circle(120)       # 반지름이 120인 원을 그림    t.right(360 / n)    # 오른쪽으로 6도 회전선으로 복잡한 무늬 그리기이번에는 선을 이용해서 복잡한 무늬를 그려보자. 소스 코드를 실행해보면 복잡한 무늬가 그려진다. 먼저 for로 i가 0부터 299까지 반복하는데 forward로 i만큼 앞으로 이동하도록 만들었다. 즉, 반복할 때마다 선이 길어진다. 그리고 right로 91도 회전했다. 이렇게 하면 미세하게 틀어진 사각형이 그려지면서 바깥으로 퍼져 나가게 된다. 각자 반복 횟수, 선의 길이, 각도를 조금씩 바꿔가면서 그려보자.import turtle as t t.shape('turtle')t.speed('fastest')      # 거북이 속도를 가장 빠르게 설정for i in range(300):    # 300번 반복    t.forward(i)        # i만큼 앞으로 이동. 반복할 때마다 선이 길어짐    t.right(91)         # 오른쪽으로 91도 회전예제표준 입력으로 삼각형의 높이가 입력됩니다. 입력된 높이만큼 산 모양으로 별을 출력하는 프로그램을 만드세요(input에서 안내 문자열은 출력하지 않아야 합니다). 이때 출력 결과는 예제와 정확히 일치해야 합니다. 모양이 같더라도 공백이나 빈 줄이 더 들어가면 틀린 것으로 처리됩니다.count = int(input())for i in range(count): # 0~4    for j in reversed(range(count)): #4~0        if j &gt; i:            print(' ', end='')        else :            print('*', end='')    print('*'*i)",
        "url": "/python-basic18"
    }
    ,
    
    "python-basic17": {
        "title": "Python - Python FizzBuzz 문제",
            "author": "AhnSang0915",
            "category": "",
            "content": "Python    Python 기본    Python 숫자 계산하기    Python 변수 만들기    Python 출력 방법    Python 불과 비교, 논리 연산자    Python 문자열 사용하기    Python 리스트와 튜플 사용하기    Python 시퀀스 자료형 활용하기    Python 딕셔너리 사용하기    Python if 조건문으로 특정 조건일 때 코드 실행하기    Python else를 사용하여 두 방향으로 분기하기    Python elif를 사용하여 두 방향으로 분기하기    Python for 반복문    Python while 반복문    Python break, continue로 반복문 제어하기    Python 중첩루프    Python FizzBuzz 문제    Python 터틀 그래픽스로 그림 그리기    Python 리스트와 튜플 응용하기    Python 리스트와 튜플 응용하기 - 2    Python 2차원 리스트 사용하기    Python 문자열 응용하기    Python 딕셔너리 응용하기FizzBuzz 문제FizzBuzz는 매우 간단한 프로그래밍 문제이며 규칙은 다음과 같다.  1에서 100까지 출력  3의 배수는 Fizz 출력  5의 배수는 Buzz 출력  3과 5의 공배수는 FizzBuzz 출력1. 1부터 100까지 숫자 출력하기FizzBuzz 문제는 반복문, 조건문, 나머지 연산자, 비교 연산자를 모두 동원해야 풀 수 있다. 먼저 1부터 100까지 숫자를 출력해보자.for i in range(1, 101):    # 1부터 100까지 100번 반복    print(i)# 출력123... (생략)98991002. 3의 배수일 때와 5의 배수일 때 처리하기이제 3의 배수와 5의 배수일 때 숫자 대신 ‘Fizz’, ‘Buzz’를 출력해보자. i를 3으로 나눈 나머지가 0이면 Fizz를 출력하고 i를 5를 나눈 나머지가 0이면 Buzz를 출력한다. 3과5를 나누었을때 나머지가 0이 아닌i는 그대로 출력하게 한다.for i in range(1, 101):    # 1부터 100까지 100번 반복    if i % 3 == 0:         # 3의 배수일 때        print('Fizz')      # Fizz 출력    elif i % 5 == 0:       # 5의 배수일 때        print('Buzz')      # Buzz 출력    else:        print(i)           # 아무것도 해당되지 않을 때 숫자 출력# 출력    12Fizz... (생략)9798FizzBuzz3. 3과 5의 공배수 처리하기3과 5의 공배수를 처리하는 코드를 작성하자. 3과 5의 배수이면 FizzBuzz를 출력하려면 and 연산자를 사용한다. and는 두 값이 모두 True여야 True로 판정한다. i % 3 == 0 and i % 5 == 0로 작성해줘야하고 만약 i가 30일때 3의 배수를 먼저 검사하면 3과 5의 공배수는 검사하지 않고 넘어가기 때문에 3과 5의 공배수를 먼저 검사한뒤 elif로 3의 배수, 5의 배수를 검사해야 한다.for i in range(1, 101):              # 1부터 100까지 100번 반복    if i % 3 == 0 and i % 5 == 0:    # 3과 5의 공배수일 때        print('FizzBuzz')            # FizzBuzz 출력    elif i % 3 == 0:                 # 3의 배수일 때        print('Fizz')                # Fizz 출력    elif i % 5 == 0:                 # 5의 배수일 때        print('Buzz')                # Buzz 출력    else:        print(i)                     # 아무것도 해당되지 않을 때 숫자 출력#출력12Fizz... (생략)FizzBuzz9192Fizz94BuzzFizz9798FizzBuzz4. 논리 연산자를 사용하지 않고 3과 5의 공배수 처리하기and를 사용하지 않고 3과 5의 공배수를 검사하게 만들어보자. 3과5의 최소공배수는 15임으로 15로 나누었을때 나머지가 0인 i를 FizzBuzz로 출력해주면 된다. 하지만 실무에서는 i % 3 == 0 and i % 5 == 0처럼 의미를 명확하게 드러내는 것이 좋다.for i in range(1, 101):      # 1부터 100까지 100번 반복    if i % 15 == 0:          # 15의 배수(3과 5의 공배수)일 때        print('FizzBuzz')    # FizzBuzz 출력    elif i % 3 == 0:         # 3의 배수일 때        print('Fizz')        # Fizz 출력    elif i % 5 == 0:         # 5의 배수일 때        print('Buzz')        # Buzz 출력    else:        print(i)             # 아무것도 해당되지 않을 때 숫자 출력# 결과 12Fizz... (생략)FizzBuzz9192Fizz94BuzzFizz9798FizzBuzz5. 코드 단축하기이번에는 코드를 단축해 문제를 해결해 보자. 파이썬에선 문자열에 True를 곱하면 문자열이 그대로 출력되고, False를 곱하면 문자열이 출력되지 않는다. True는 1, False는 0으로 연산되기 때문이다. Fizz뒤의 불과, Buzz뒤의 불이 모두 충족되면 +를 사용해 FizzBuzz를 출력하게 하고, or 연산자로 앞의 두 불이 False여도 i를 출력하게 만들었다. 0이 아닌 숫자가 i에 오면 True이기 때문에 3과 5의 배수나 공배수가 아니더라도 i의 값이 출력된다.for i in range(1, 101):    print('Fizz' * (i % 3 == 0) + 'Buzz' * (i % 5 == 0) or i)    # 문자열 곱셈과 덧셈을 이용하여 print 안에서 처리# 결과 12Fizz... (생략)FizzBuzz9192Fizz94BuzzFizz9798FizzBuzz",
        "url": "/python-basic17"
    }
    ,
    
    "python-basic16": {
        "title": "Python - Python 중첩루프",
            "author": "AhnSang0915",
            "category": "",
            "content": "Python    Python 기본    Python 숫자 계산하기    Python 변수 만들기    Python 출력 방법    Python 불과 비교, 논리 연산자    Python 문자열 사용하기    Python 리스트와 튜플 사용하기    Python 시퀀스 자료형 활용하기    Python 딕셔너리 사용하기    Python if 조건문으로 특정 조건일 때 코드 실행하기    Python else를 사용하여 두 방향으로 분기하기    Python elif를 사용하여 두 방향으로 분기하기    Python for 반복문    Python while 반복문    Python break, continue로 반복문 제어하기    Python 중첩루프    Python FizzBuzz 문제    Python 터틀 그래픽스로 그림 그리기    Python 리스트와 튜플 응용하기    Python 리스트와 튜플 응용하기 - 2    Python 2차원 리스트 사용하기    Python 문자열 응용하기    Python 딕셔너리 응용하기중첩루프이번에는 지금까지 배운 for 반복문과 if 조건문을 사용하여 계단식으로 별(*)을 출력해보자.***************1. 중첩 루프 사용하기콘솔(터미널, 명령 프롬프트)은 2차원 평면이므로 별을 일정한 모양으로 출력하려면 반복문을 두 개 사용하는 것이 편리하다. i를 사용하는 바깥루프는 세로방향을 처리하고, j를 사용하는 안쪽 루프는 가로 방향을 처리한다.첫번째 for문 i가 0일때 두번째 for문 j는 0부터 4까지의 j를 출력한다. 출력후 다음 print문에서 줄바꿈을 출력하게되고 다시 i = 1로 시작해 두번쨰 for문을 돈다.for i in range(5):          # 5번 반복. 바깥쪽 루프는 세로 방향    for j in range(5):      # 5번 반복. 안쪽 루프는 가로 방향        print('j:', j, sep='', end=' ')    # j값 출력. end에 ' '를 지정하여 줄바꿈 대신 한 칸 띄움    print('i:', i, '\\\\n', sep='')    # i값 출력, 개행 문자 모양도 출력                                     # 가로 방향으로 숫자를 모두 출력한 뒤 다음 줄로 넘어감                                     # (print는 기본적으로 출력 후 다음 줄로 넘어감)# 출력j 0 j 1 j 2 j 3 j 4 I 0 //nj 0 j 1 j 2 j 3 j 4 I 1 //nj 0 j 1 j 2 j 3 j 4 I 2 //nj 0 j 1 j 2 j 3 j 4 I 3 //nj 0 j 1 j 2 j 3 j 4 I 4 //n중첩 루프는 2차원 평면을 다룰 수 있다. 영상처리, 이미지 처리, 좌표계 처리 등에 주로 쓰인다.2. 사각형으로 별 출력하기중첩 반복문으로 5x5 사각형 별을 그려보자. 안쪽의 for문을 실행하면 가로방향으로 이5개 출력된다. 5번 반복해 print()를 하는데 끝에 end=’‘를 사용해 줄바꿈을 하지 않기 때문이다. 바깥쪽의 for i in range(5):의 경우 안쪽의 for j in range(5):를 5번 반복한다. 마지막 print()는 기본적으로 end=’\\n’ 상태이므로 아무것도 기입하지 않아도 \\n은 출력되어 줄바꿈을 해주게 된다.for i in range(5) :    for j in range(5):        print('*', end='')    print()# 출력    *************************사각형 모양 바꾸기이제 for 반복문의 조건식을 수정하여 사각형의 모양을 바꿔보자.for i in range(3):            # 3번 반복. 세로 방향    for j in range(7):        # 7번 반복. 가로 방향        print('*', end='')    # 별 출력. end에 ''를 지정하여 줄바꿈을 하지 않음    print()    # 가로 방향으로 별을 다 그린 뒤 다음 줄로 넘어감               # (print는 출력 후 기본적으로 다음 줄로 넘어감)#출력*********************3. 계단식으로 별 출력하기계단식으로 별을 출력해 보자. 계단식으로 출력하려면 출력하지 않는 부분이 있기 때문에 if문을 사용한다. j &lt;= i로 i가 1일때 j는 1보다 작거나 같아야만 출력이된다.for i in range(5):        # 0부터 4까지 5번 반복. 세로 방향    for j in range(5):    # 0부터 4까지 5번 반복. 가로 방향        if j &lt;= i:                # 세로 방향 변수 i만큼            print('*', end='')    # 별 출력. end에 ''를 지정하여 줄바꿈을 하지 않음    print()    # 가로 방향으로 별을 다 그린 뒤 다음 줄로 넘어감               # (print는 출력 후 기본적으로 다음 줄로 넘어감)#출력***************대각선으로 별 출력하기별을 대각선으로 출력해 보자. i = 1일때 *출력 이후 else부분의 공백이 4개 들어가게 된다.for i in range(5):        # 0부터 4까지 5번 반복. 세로 방향    for j in range(5):    # 0부터 4까지 5번 반복. 가로 방향        if j == i:                # 세로 방향 변수와 같을 때            print('*', end='')    # 별 출력. end에 ''를 지정하여 줄바꿈을 하지 않음        else:                     # 세로 방향 변수와 다를 때            print(' ', end='')    # 공백 출력. end에 ''를 지정하여 줄바꿈을 하지 않음    print()    # 가로 방향으로 별을 다 그린 뒤 다음 줄로 넘어감               # (print는 출력 후 기본적으로 다음 줄로 넘어감)# 결과 * *  *   *    *예제표준 입력으로 삼각형의 높이가 입력됩니다. 입력된 높이만큼 산 모양으로 별을 출력하는 프로그램을 만드세요(input에서 안내 문자열은 출력하지 않아야 합니다). 이때 출력 결과는 예제와 정확히 일치해야 합니다. 모양이 같더라도 공백이나 빈 줄이 더 들어가면 틀린 것으로 처리됩니다.count = int(input())for i in range(count): # 0~4    for j in reversed(range(count)): #4~0        if j &gt; i:            print(' ', end='')        else :            print('*', end='')    print('*'*i)",
        "url": "/python-basic16"
    }
    ,
    
    "python-basic15": {
        "title": "Python - Python break, continue로 반복문 제어하기",
            "author": "AhnSang0915",
            "category": "",
            "content": "Python    Python 기본    Python 숫자 계산하기    Python 변수 만들기    Python 출력 방법    Python 불과 비교, 논리 연산자    Python 문자열 사용하기    Python 리스트와 튜플 사용하기    Python 시퀀스 자료형 활용하기    Python 딕셔너리 사용하기    Python if 조건문으로 특정 조건일 때 코드 실행하기    Python else를 사용하여 두 방향으로 분기하기    Python elif를 사용하여 두 방향으로 분기하기    Python for 반복문    Python while 반복문    Python break, continue로 반복문 제어하기    Python 중첩루프    Python FizzBuzz 문제    Python 터틀 그래픽스로 그림 그리기    Python 리스트와 튜플 응용하기    Python 리스트와 튜플 응용하기 - 2    Python 2차원 리스트 사용하기    Python 문자열 응용하기    Python 딕셔너리 응용하기break, continue로 반복문 제어하기break와 continue를 사용해 반복문을 제어하는 방법을 알아보자. break는 for와 while의 문법에서 제어흐름을 벗어나기 위해 사용한다. 즉, 루프를 중단한다. continue는 제어흐름을 유지한 상태에서 코드의 실행만 건너뛴다.  break: 제어흐름 중단  continue: 제어흐름 유지, 코드 실행만 건너뜀1. break로 반복문 끝내기break를 사용해 for와 while 에서 반복을 끝내는 방법을 알아보자.while에서 break로 반복문 끝내기while 무한 루프에서 숫자를 증가시키다 변수 i가 100일 때 반복문을 끝내도록 만들었다. i값을 출력하고 증가시키므로 99까지 출력하고 반복을 멈추게 된다.i = 0while True:    # 무한 루프    print(i)    i += 1          # i를 1씩 증가시킴    if i == 100:    # i가 100일 때        break       # 반복문을 끝냄. while의 제어흐름을 벗어남#결과012... (생략)979899for에서 break로 반복문 끝내기for에 range(10000)을 지정했다. 0부터 9999까지 반복하는데 i 가 100일때 break를 실행 함으로 0부터 100까지만 출력하고 반복문을 끝낸다. 100일때 100을 출력하고 반복을 멈추게 된다.for i in range(10000):    # 0부터 9999까지 반복    print(i)    if i == 100:    # i가 100일 때        break       # 반복문을 끝냄. for의 제어흐름을 벗어남#출력012... (생략)98991002. continue로 코드 실행 건너뛰기continue를 사용해 일부 코드를 실행하지 않고 건너 뛰어 보자.for에서 continue로 코드 실행 건너뛰기for반복문에 range(100)를 사용해 0부터 99까지 반복한다. 그리고 if를 사용해 i가 짝수이면 continue를 실행한다. 마지막으로 print i의 값을 출력하고 99 까지 출력후 종료된다.for i in range(100):       # 0부터 99까지 증가하면서 100번 반복    if i % 2 == 0:         # i를 2로 나누었을 때 나머지가 0면 짝수        continue           # 아래 코드를 실행하지 않고 건너뜀    print(i)# 결과135... (생략)959799while 반복문에서 continue로 코드 실행 건너뛰기while i &lt; 100 : 으로 0부터 99까지 반복한다. i값을 1씩증가시킨뒤 if를 사용해 i가 짝수이면 continue를 실행한다. i의 초기값은 0이고 i +=1로 1로증가시킨 값부터 시작한다.i = 0while i &lt; 100:        # i가 100보다 작을 때 반복. 0부터 99까지 증가하면서 100번 반복    i += 1            # i를 1씩 증가시킴    if i % 2 == 0:    # i를 2로 나누었을 때 나머지가 0이면 짝수        continue      # 아래 코드를 실행하지 않고 건너뜀    print(i)만약 무한루프에서 continue를 사용하면 홀수만 계속 출려될 뿐 반복문은 끝나지 않는다.반복문과 passfor, while의 반복할 코드에서 아무 일도 하지 않지만, 반복문의 형태를 유지하고 싶다면 pass를 사용하면 된다.for i in range(10):    # 10번 반복    pass               # 아무 일도 하지 않음while True:    # 무한 루프    pass       # 아무 일도 하지 않음3. 입력한 횟수대로 반복하기count에 input으로 입력을 받아 count변수에 저장하고 i에 0을 항당해 while True를 지정한 무한 루프로 만든다. 반복문 안에서는 i의 값을 출력하고, 변화식 에서는 i를 1씩증가시킨다. i의 값이 count의 값과 같으면 break를 실행한다.count = int(input('반복할 횟수를 입력하세요: ')) i = 0while True:    # 무한 루프    print(i)    i += 1    if i == count:    # i가 입력받은 값과 같을 때        break         # 반복문을 끝냄#출력반복할 횟수를 입력하세요: 3 (입력)012입력한 숫자까지 홀수 출력하기input으로 입력 값을 받아서 count 변수에 저장했다. 그리고 for의 range에 count + 1을 지정하여 count에 들어있는 값만큼 반복하도록 만들었다. 왜냐하면 range(count)는 0부터 시작하므로 count의 값은 반복에 포함되지 않기 때문이다.반복문 안에서는 if를 사용하여 i가 짝수이면 continue를 실행한다. 그다음에 print를 사용하여 i의 값을 출력한다.여기서는 9를 입력했으므로 0부터 9까지 반복하면서 i가 짝수이면 print를 실행하지 않고 건너뛰며 i가 홀수이면 print를 사용하여 숫자를 출력한다. 따라서 1 3 5 7 9가 출력된다.count = int(input('반복할 횟수를 입력하세요: ')) for i in range(count + 1):       # 0부터 증가하면서 count까지 반복(count + 1)    if i % 2 == 0:               # i를 2로 나누었을 때 나머지가 0이면 짝수        continue                 # 아래 코드를 실행하지 않고 건너뜀    print(i)# 결과 반복할 횟수를 입력하세요: 9 (입력)13579",
        "url": "/python-basic15"
    }
    ,
    
    "python-basic14": {
        "title": "Python - Python while 반복문",
            "author": "AhnSang0915",
            "category": "",
            "content": "Python    Python 기본    Python 숫자 계산하기    Python 변수 만들기    Python 출력 방법    Python 불과 비교, 논리 연산자    Python 문자열 사용하기    Python 리스트와 튜플 사용하기    Python 시퀀스 자료형 활용하기    Python 딕셔너리 사용하기    Python if 조건문으로 특정 조건일 때 코드 실행하기    Python else를 사용하여 두 방향으로 분기하기    Python elif를 사용하여 두 방향으로 분기하기    Python for 반복문    Python while 반복문    Python break, continue로 반복문 제어하기    Python 중첩루프    Python FizzBuzz 문제    Python 터틀 그래픽스로 그림 그리기    Python 리스트와 튜플 응용하기    Python 리스트와 튜플 응용하기 - 2    Python 2차원 리스트 사용하기    Python 문자열 응용하기    Python 딕셔너리 응용하기while 반복문while 반복문은 조건식으로만 동작하며 반복할 코드 안에 조건식에 영향을 주는 변화식이 들어간다.여기서는 조건식 → 반복할 코드 및 변화식 → 조건식으로 순환하는 부분이 루프(loop)이다.i = 0                     # 초기식while i &lt; 100:            # while 조건식     print('Hello, world!')    # 반복할 코드     i += 1                    # 변화식while반복문은 초기식부터 시작해 조건식을 판별하고 이때 조건식이 참(True)이면 반복할 코드와 변화식을 함께 수행한다. 그리고 다시 조건식을 판별하여 참(True)이면 코드를 계속 반복하고, 거짓(False)이면 반복문을 끝낸 뒤 다음 코드를 실행한다.1. while 반복문 사용하기다음과 같이 whil반복문은 조건식을 지정하고 끝에 :(클론)을 붙여준다. 그리도 다음줄에 반복할 코드와 변화식을 넣어준다.초기식while 조건식:     반복할 코드     변화식while 다음줄에 오는 코드는 반드시 들여쓰기를 해줘야한다. while 반복문으로 ‘Hello, world!’를 100번 출력해보자. 먼저 while 반복문에 변수 i에 0을 할당하고 조건식을 지정한다. 그리고 변화식을 정해줘야하는데 이때 조건식만 지정하고 변화식을 지정하지 않으면 무한루프가 되므로 변화식을 꼭 써야한다.i = 0while i &lt; 100 :    print('Hello, world!')    i += 1 # i를 1씩 증가시킨다. i = i + 1#출력Hello, world!Hello, world!Hello, world!Hello, world!Hello, world!Hello, world!Hello, world!.....초깃값을 1부터 시작하기초기 값을 1로 할당하여 ‘Hello, world!’를 100번 출력해 보자. i가 0부터라면 99까지 나오면 100번이기 때문에 i &lt; 100 이지만 1부터기 때문에 i &lt;=100으로 작성해 줘야한다.i가 101이 되면 i &lt;= 100은 거짓( False)이므로 반복문을 끝낸다.i = 1while i &lt;= 100:    print('Hello, world!', i)    i += 1#출력Hello, world! 1Hello, world! 2Hello, world! 3...  (생략)Hello, world! 99Hello, world! 100초깃값을 감소시키기지금까지 초기값을 증가시키면서 루프를 실행했다. 반대로 초깃값을 크게주고, 변수를 감소시키면서 반복해 보자. 시작 값은 100이고 조건식을 i&gt;0과 같이 지정해 1까지만 반복하도록 만들었다. 변화식은 i-=1로 지정해 변수의 값을 1씩 감소시킨다. i가 0이되면 i&gt;0은 거짓(False)가 되기떄문에 반복이 종료된다.i = 100while i &gt; 0:    print('Hello, world!', i)    i -= 1 # i = i-1#출력Hello, world! 100Hello, world! 99Hello, world! 98... (생략)Hello, world! 2Hello, world! 1입력한 횟수대로 반복하기입력한 횟수대로 반복을 해보자. input입력값을 3으로 입력하고 반복을 실행하면 3번 반복하게된다. 반복문의 조건을 i &lt; count로 지정해 count에 들어있는 값만큼 반복하도록 만들었다.count = int(input('반복할 횟수를 입력하세요: ')) i = 0while i &lt; count:     # i가 count보다 작을 때 반복    print('Hello, world!', i)    i += 1# 출력Hello, world! 0Hello, world! 1Hello, world! 2초깃값을 받은 뒤 초깃값만큼 출력하게 만들었다. 여기서는 변수 i 대신 count를 바로 사용하므로 변화식을 count -= 1로 지정하여 반복할 때마다 count를 감소시키고 count가 0이 되면 반복문을 끝낸다.count = int(input('반복할 횟수를 입력하세요: ')) while count &gt; 0:     # i가 count보다 작을 때 반복    print('Hello, world!', count)    count -= 1# 출력Hello, world! 3Hello, world! 2Hello, world! 12. 반복 횟수가 정해지지 않은 경우지금까지 조건식에서 반복 횟수를 정한 뒤 변수 i를 증가시키거나 감소시켜 while 반복문을 사용했다. 하지만 while 반복문은 반복 횟수가 정해지지 않았을 때 주로 사용한다. 이번에는 난수를 생성해서 숫자에 따라 반복을 끝내 보자. 난수(random number)란 특정 주기로 반복되지 않으며 규칙 없이 무작위로 나열되는 숫자를 뜻한다.파이썬에서 난수를 생성하려면 random 모듈이 필요하다. 모듈은 다음과 같이 import 키워드를 사용하여 가져올 수 있다.  import 모듈import random    # random 모듈을 가져옴이제 random.random() 으로 random모듈의 random함수를 호출해 보자.random.random()0.6308359530867019random.random()0.9884423768957599random.random()0.526192298540528숫자를 알아보기 쉽도록 정수를 생성하는 random모듈의 randint함수를 사용해보자. randint 함수는 난수를 생성할 범위를 지정하며, 범위에 지정한 숫자도 난수에 포함된다.random. randint(1, 6)2random. randint(1, 6)4random. randint(1, 6)3random. randint(1, 6)5random.randint(1, 6)과 while반복문을 사용해보자. 아래 코드는 1에서 6사이의 난수를 생성하고 3이 나오면 반복을 끝낸다.i = 0while i != 3: # i가 3이 아닐때 계속 반복    i = random.randint(1, 6)    print(i)    12113 # 3이 나와 종료,random.choicerandom.choice 함수를 사용하면 시퀀스 객체에서 요소를 무작위로 선택할 수 있다. 다음은 1, 2, 3, 4, 5, 6이 들어있는 리스트에서 무작위로 숫자를 선택한다. random.choice 함수는 시퀀스 객체를 받으므로 리스트뿐만 아니라 튜플, range, 문자열 등을 넣어도 된다.dice = [1, 2, 3, 4, 5, 6]random.choice(dice)1random.choice(dice)4random.choice(dice)33. while 반복문으로 무한 루프 만들기while 반복문으로 무한 루프를 만들어 보자.while True:    # while에 True를 지정하면 무한 루프    print('Hello, world!')# 출력... (생략)Hello, world!Hello, world!Hello, world!Hello, world!... (계속 반복)while에 True대신 True로 취급하는 값을 사용해도 무한 루프로 동작한다.while 1:    # 0이 아닌 숫자는 True로 취급하여 무한 루프로 동작    print('Hello, world!')while 'Hello':    # 내용이 있는 문자열은 True로 취급하여 무한 루프로 동작    print('Hello, world!')",
        "url": "/python-basic14"
    }
    ,
    
    "python-basic13": {
        "title": "Python - Python for 반복문",
            "author": "AhnSang0915",
            "category": "",
            "content": "Python    Python 기본    Python 숫자 계산하기    Python 변수 만들기    Python 출력 방법    Python 불과 비교, 논리 연산자    Python 문자열 사용하기    Python 리스트와 튜플 사용하기    Python 시퀀스 자료형 활용하기    Python 딕셔너리 사용하기    Python if 조건문으로 특정 조건일 때 코드 실행하기    Python else를 사용하여 두 방향으로 분기하기    Python elif를 사용하여 두 방향으로 분기하기    Python for 반복문    Python while 반복문    Python break, continue로 반복문 제어하기    Python 중첩루프    Python FizzBuzz 문제    Python 터틀 그래픽스로 그림 그리기    Python 리스트와 튜플 응용하기    Python 리스트와 튜플 응용하기 - 2    Python 2차원 리스트 사용하기    Python 문자열 응용하기    Python 딕셔너리 응용하기for 반복문‘Hello, world!’문자열을 100번 출력하려면 print를 100번 사용하면 되지만, for문을 사용해 반복하는 기능을 알아보자.1. for와 range 사용하기파이썬의 for반복문은 다양한  사용 방법이 있지만, 먼저 range와 함께 사용하는 방법부터 알아보자. 다음과 같이 for 반복문은 range에 반복할 횟수를 지정하고 앞에 in과 변수를 입력한다. 그리고 :(클론)을 붙이고 다음 중ㄹ에 반복할 코드를 입력한다. for다음 줄에 오는 코드는 반드시 들여쓰기를 해준다.for 변수 in range(횟수):     반복할 코드‘Hello, world!’를 100번 출력해 보자. range(100)과 같이 지정하면 0부터 99까지 숫자 100개를 생성한다. 그리고 for는 in으로 숫자를 하나씩 꺼내 변수i에 지정하고, print를 실행한다. 즉, range(100)에서 숫자를 100번 꺼내면서 print를 실행하므로 ‘Hello, world!’가 100번 출력되게 된다.for i in range(100) :    print('Hello, world!')for 변수 in range(횟수) → 반복할 코드로 순환하는 것을 루프(loop)라고 부른다.반복문에서 변수의 변화 알아보기‘Hello, world!’를 100번 출력하는 동시에 i의 값을 확인해보자.for i in range(100) :    print('Hello, world!',i)변수 i를 루프 인덱스라고도 부르며 index의 첫 머리글자를 따서 i를 주로 사용한다.2. for와 range 응용하기이번에는 range의 다양한 기능을 활용하여 for반복문을 사용해보자.시작하는 숫자와 끝나는 숫자 지정하기range에 횟수만 지정하면 숫자가 0부터 시작하지만, 다음과 같이 시작하는 숫자와 끝나는 숫자를 지정해 반복할 수도 있다. for i in range(5, 12):와 같이 지정하면 5부터 11까지 5, 6, 7, 8, 9, 10, 11이 나오고 7번 반복한다. 즉, 마지막 숫자는 range의 끝나는 숫자보다 1이 작다(끝나는 숫자는 생성된 숫자에 포함되지 않음).for i in range(5, 12) : # 5부터 11까지의 숫자를 생성    print('Hello, world!', i)#출력Hello, world! 5Hello, world! 6Hello, world! 7Hello, world! 8Hello, world! 9Hello, world! 10Hello, world! 11증가폭 사용하기range는 증가폭을 지정해서 해당 값만큼 숫자를 증가시킬 수 있다.  for 변수 in range(시작, 끝, 증가폭):for i in range(0, 10, 2) :    print('Hello, world!', i)#출력Hello, world! 0Hello, world! 2Hello, world! 4Hello, world! 6Hello, world! 8숫자를 감소시키기for과 range는 숫자가 증가하면서 반복했다. 숫자를 감소시켜보자. range는 숫자가 증가하는 기본값이 양수 1이기 때문에 for i in range(10, 0)로 코드를 작성한다고 해서 숫자가 감소하지 않는다. range에 증가폭을 음수로 지정해 감소시킬 수 있다. 특히 range의 끝나는 숫자 0은 생성되는 숫자에 포함되지 않으므로 1까지만 감소한다. range는 그냥 증가, 감소에 상관없이 끝나는 숫자는 생성되는 숫자에 포함되지 않는다는 점만 기억하자.for i in range(0, 10, -1) : # 10에서 1까지 1씩감소    print('Hello, world!', i)#출력Hello, world! 10Hello, world! 9Hello, world! 8Hello, world! 7Hello, world! 6Hello, world! 5Hello, world! 4Hello, world! 3Hello, world! 2Hello, world! 1증가폭을 음수로 지정하지 않고 reversed를 사용해 순서를 반대로 뒤집어 보자. reversed의 경우 range(10)을 반대로 뒤집은것 이기 때문에 0부터 9까지 숫자를 만들고 만들어진 숫자를 뒤집는다. 따라서 9~0까지의 숫자가 출력된다.  for 변수 in reversed(range(횟수))  for 변수 in reversed(range(시작, 끝))  for 변수 in reversed(range(시작, 끝, 증가폭))for i in reversed(range(10)) :    print('Hello, world!', i)#출력          Hello, world! 9Hello, world! 8Hello, world! 7Hello, world! 6Hello, world! 5Hello, world! 4Hello, world! 3Hello, world! 2Hello, world! 1Hello, world! 0반복문의 i변수를 할당해 보았다. 반복할 코에서 변수 i에 10을 할당하여 10이 출력될것 같은데, 0부터 9까지 출력되었다. 변수i는 반복할 때마다 다음 값으로 덮어써지기 때문에 값을 할당해도 변수에 영향을 주지 못한다.for i in range(10):     print(i, end=' ')     i = 10 0 1 2 3 4 5 6 7 8 9입력한 횟수대로 반복하기이번에는 입력한 횟수대로 반복을 해보자. count라는 변수에 input으로 입력값을 받아 for문에 range에 입력한 횟수를 count변수가 받아 반복문이 실행된다.count = int(input('반복할 횟수 입력: '))for i in range(count) :     print('Hello, world!', i)# 출력반복할 횟수 입력: 3          Hello, world! 0Hello, world! 1Hello, world! 23. 시퀀스 객체로 반복하기for문에 range대신 시퀀스객체를 넣어 반복을 실행해 보자. range대신 리스트를 넣어 실행해 보았다.a = [10, 20, 30, 40, 50]for i in a:    print(i)# 출력1020304050튜플을 넣어 실행해 보았다.fruits = ('apple', 'orange', 'grape')for fruits in fruits:    print(fruits)# 출력appleorangegrape문자열을 넣어 실행해 보자.for i in 'Python' :    print(i, end=' ')# 출력P y t h o n 문자열을 reversed로 뒤집어 출력해 보자.for i in reversed('Python') :    print(i, end=' ')# 출력n o h t y P ",
        "url": "/python-basic13"
    }
    ,
    
    "python-basic12": {
        "title": "Python - Python  elif를 사용하여 여러 방향으로 분기하기",
            "author": "AhnSang0915",
            "category": "",
            "content": "Python    Python 기본    Python 숫자 계산하기    Python 변수 만들기    Python 출력 방법    Python 불과 비교, 논리 연산자    Python 문자열 사용하기    Python 리스트와 튜플 사용하기    Python 시퀀스 자료형 활용하기    Python 딕셔너리 사용하기    Python if 조건문으로 특정 조건일 때 코드 실행하기    Python else를 사용하여 두 방향으로 분기하기    Python elif를 사용하여 두 방향으로 분기하기    Python for 반복문    Python while 반복문    Python break, continue로 반복문 제어하기    Python 중첩루프    Python FizzBuzz 문제    Python 터틀 그래픽스로 그림 그리기    Python 리스트와 튜플 응용하기    Python 리스트와 튜플 응용하기 - 2    Python 2차원 리스트 사용하기    Python 문자열 응용하기    Python 딕셔너리 응용하기Python elif를 사용하여 여러 방향으로 분기하기elif는 조건식을 여러 개 지정하여 각 조건 마다 다른 코드를 실행할 수 있다.if 콜라 버튼을 눌렀다면:    콜라를 내보냄elif 사이다 버튼을 눌렀다면:    사이다를 내보냄elif 환타 버튼을 눌렀다면:    환타를 내보냄:else:    제공하지 않는 메뉴1. elif 사용하기elif는 else인 상태에서 조건식을 지정할 때 사용하며 else if라는 뜻이다. 물론 if, else와 마찬가지로 조건식 끝에 :(콜론)을 붙여야 하고, elif 단독으로 사용할 수 없다.if 조건식:     코드1elif:     코드2x = 20if x == 10:    print('10이다.')elif x == 20:    print('20이다.')    # 20이다.if, elif, else를 모두 사용하기elif와 else는 단독으로 사용할 수 없으며 if, else 형태로 사용하거나, if, elif, else 형태로 사용한다. 이번에는 if, elif, else를 모두 사용해보자.if 조건식:    코드1elif 조건식:    코드2else:    코드3  아래 코드는 if, elif의 조건식이 모두 거짓일 때만 else의 코드가 실행된다. 여기서는 x가 30이라 if, elif의 조건식에 모두 만족하지 않는다. 따라서 마지막 else의 ‘10도 20도 아닙니다.’가 출력된다.x = 30 if x == 10:             # x가 10일 때    print('10입니다.')elif x == 20:           # x가 20일 때    print('20입니다.')else:                   # 앞의 조건식에 모두 만족하지 않을 때    print('10도 20도 아닙니다.') # 10도 20도 아닙니다.음료수 자판기 만들기버튼 1번은 ‘콜라’, 2번은 ‘사이다’, 3번은 ‘환타’이고 각 버튼에 따라 음료수 이름을 출력한다고 하자(1, 2, 3이외의 숫자는 ‘제공하지 않는 메뉴’ 출력).button = int(input()) if button == 1:    print('콜라')elif button == 2:    print('사이다')elif button == 3:    print('환타')else:    print('제공하지 않는 메뉴')# 1 (입력)# 콜라",
        "url": "/python-basic12"
    }
    ,
    
    "python-basic11": {
        "title": "Python - Python  else를 사용하여 두 방향으로 분기하기",
            "author": "AhnSang0915",
            "category": "",
            "content": "Python    Python 기본    Python 숫자 계산하기    Python 변수 만들기    Python 출력 방법    Python 불과 비교, 논리 연산자    Python 문자열 사용하기    Python 리스트와 튜플 사용하기    Python 시퀀스 자료형 활용하기    Python 딕셔너리 사용하기    Python if 조건문으로 특정 조건일 때 코드 실행하기    Python else를 사용하여 두 방향으로 분기하기    Python elif를 사용하여 두 방향으로 분기하기    Python for 반복문    Python while 반복문    Python break, continue로 반복문 제어하기    Python 중첩루프    Python FizzBuzz 문제    Python 터틀 그래픽스로 그림 그리기    Python 리스트와 튜플 응용하기    Python 리스트와 튜플 응용하기 - 2    Python 2차원 리스트 사용하기    Python 문자열 응용하기    Python 딕셔너리 응용하기Python else를 사용하여 두 방향으로 분기하기if 조건문은 분기를 위한 문법이다. 즉, 분기는 ‘둘이상으로 갈라지다’라는 뜻으로 프로그램의 흐름을 둘 이상으로 나누는 것을 말한다. if조건 문은 조건식에 맞는 코드를 실행한다. if에 else를 사용하면 조건식이 만족할 때와 만족하지 않을 때 각각 다른 코드를 실행할 수 있다.1. else 사용하기else는 if조건문 뒤에 오며 단독으로 사용할 수 없다. if와 마찬가지로 else도 :(콜론)을 붙이며 다음 줄에 실행할 코드가 온다.if 조건식:     코드1else:     코드2x = 5    if x == 10:         print('10입니다.')    else:         print('10이 아닙니다.')# 10이 아닙니다.if와 else의 기본 형태와 실행 흐름 알아보기else는 if의 조건식이 만족하지 않을 때 코드를 실행한다. 여기에서는 x에 5를 할당해서 x == 10을 만족하지 않음으로 else의 print가 실행되어 ‘10이 아닙니다.’가 출력된다.x = 5if x == 10:         print('10입니다.')    else:         print('10이 아닙니다.')# 10이 아닙니다.   변수에 값 할당을 if, else로 축약하기변수 x에 10이 들어있으면 y에 x를 할당하고, 아니면 y에 0을 할당하는 코드는 다음과 같이 만들수 있다.x = 5    if x == 10:        y = x    else:        y = 0y0이렇게 if, else에서 변수에 값을 할당할 때는 변수 = 값 if 조건문 else 값 형식으로 축약할 수 있으며 이런 문법을 조건부 표현식(conditional expression)이라고 부른다.x = 5y = x if x == 10 else 0y02. else와 들여쓰기else는 if와 들여쓰기 규칙이 같다. 다음은 들여쓰기가 잘못된 코드다.x = 5 if x == 10:    print('10입니다.') else:print('x에 들어있는 숫자는')    # unexpected indent 에러 발생     print('10이 아닙니다.')올바른 코드로 고쳐보자.if x == 10:    print('10입니다.') else:    print('x에 들어있는 숫자는')    print('10이 아닙니다.') else가 여러 줄일 때는 마지막 줄의 들여쓰기를 하지 않으면 의도치 않은 동작이 된다.x = 10 if x == 10:    # x가 10이라 조건식이 참    print('10입니다.')    # 출력else:     print('x에 들어있는 숫자는')print('10이 아닙니다.')    # 출력되지 않아야 하는데 출력됨x가 10이라는 조건식이 참이므로 ‘10입니다.’가 출력된다. 하지만 else의 ‘10이 아닙니다.’도 함께 출력되어 버렸다. print(‘10이 아닙니다.’)는 들여쓰기가 없어서 else와는 상관없는 코드가 되었기 때문이다. print를 한 줄 띄워보면 왜 잘못되었는지 알 수 있다.x = 10 if x == 10:    # x가 10이라 조건식이 참    print('10입니다.')else:    print('x에 들어있는 숫자는') print('10이 아닙니다.')3. if 조건문의 동작 방식 알아보기이번에는 조건식이 아닌 값으로 if와 else의 코드를 동작시켜 보자. True는 if 코드가 실행되고 Fasle는 else의 코드가 실행된다. 특히 None은 Fasle로 취급되므로 else의 코드가 실행 된다. 실제 코드를 작성할 때 변수에 들어있는 값이나 함수의 결과가 None인 경우가 많으므로 이 부분은 꼭 기억해두자.if True:    print('참')    # True는 참else:    print('거짓') if False:    print('참')else:    print('거짓')    # False는 거짓 if None:    print('참')else:    print('거짓')    # None은 거짓# 결과# 참# 거짓# 거짓if 조건문에 숫자 지정하기숫자는 정수(2진수, 10진수, 6진수), 실수와 관계없이 0이면 거짓, 0이 아닌 수는 참이다.if 0:    print('참')else:    print('거짓')    # 0은 거짓 if 1:    print('참')    # 1은 참else:    print('거짓') if 0x1F:    # 16진수    print('참')    # 0x1F는 참else:    print('거짓') if 0b1000:    # 2진수    print('참')    # 0b1000은 참else:    print('거짓') if 13.5:    # 실수    print('참')    # 13.5는 참else:    print('거짓')# 결과# 거짓# 참# 참# 참# 참if 조건문에 문자열 지정하기문자열은 내용이 있을때 참, 빈 문자열은 거짓이다.if 'Hello':    # 문자열    print('참')    # 문자열은 참else:    print('거짓') if '':    # 빈 문자열    print('참')else:    print('거짓')    # 빈 문자열은 거짓# 결과# 참# 거짓0, None, 빈 문자열을 not으로 뒤집으면?0, None, 빈 문자열 ‘‘을 not으로 뒤집으면 참(True)이 되므로 if를 동작시킬 수 있다.if not 0:    print('참')    # not 0은 참 if not None:    print('참')    # None은 참 if not '':    print('참')    # not 빈 문자열은 참# 결과# 참# 참# 참True, False로 취급하는 것들다음은 파이썬 문법 중에서 False로 취급하는 것들입니다.      None        False        0인 숫자들: 0, 0.0, 0j        비어 있는 문자열, 리스트, 튜플, 딕셔너리, 세트: ‘’, “”, [], (), {}, set()        클래스 인스턴스의 bool(), len() 메서드가 0 또는 False를 반환할 때  앞에서 나열한 것들을 제외한 모든 요소들은 True로 취급합니다.4. 조건식을 여러 개 지정하기지금까지 if에 조건식을 하나만 지정했다. 만약 조건이 복잡하다면 어떻게 해야할까? if 조건문에는 논리 연산자를 사용하여 조건식을 여러 개 지정할 수 있다. x == 10이고 y == 20처럼 and 논리 연산자를 사용하면 x == 10이면서 y == 20일 때 if 코드가 실행된다.x = 10y = 20 if x == 10 and y == 20:     # x가 10이면서 y가 20일 때    print('참')else:    print('거짓')만약 둘중 하나라도 만족했을때 ‘참’이 출력되도록 만드려면 or 논리 연산자를 사용하면 된다.중첩 if조건문과 논리 연산자보통 여러 조건을 판단할 때 if를 계속 나열해서 중첩 if 조건문으로 만드는 경우가 많다. 예를 들어 x가 양수이면서 20보다 작은지 판단하려고 한다. if로 x가 0보다 큰지 검사하고(0보다 크면 양수), 다시 if로 20보다 작은지 검사했다.x = 10y = 20 if x &gt; 0:    if x &lt; 20:        print('20보다 작은 양수입니다.')이런 중첩 if 조건문은 and 논리 연산자를 사용해서 if 하나로 줄일 수 있다.x = 10y = 20 if x &gt; 0 and x &lt; 20:    print('20보다 작은 양수입니다.')   위보다 더 간단하게 만들 수 있다.x = 10y = 20 if 0 &lt; x &lt; 20:    print('20보다 작은 양수입니다.')   ",
        "url": "/python-basic11"
    }
    ,
    
    "python-basic10": {
        "title": "Python - Python  if 조건문으로 특정 조건일 때 코드 실행하기",
            "author": "AhnSang0915",
            "category": "",
            "content": "Python    Python 기본    Python 숫자 계산하기    Python 변수 만들기    Python 출력 방법    Python 불과 비교, 논리 연산자    Python 문자열 사용하기    Python 리스트와 튜플 사용하기    Python 시퀀스 자료형 활용하기    Python 딕셔너리 사용하기    Python if 조건문으로 특정 조건일 때 코드 실행하기    Python else를 사용하여 두 방향으로 분기하기    Python elif를 사용하여 두 방향으로 분기하기    Python for 반복문    Python while 반복문    Python break, continue로 반복문 제어하기    Python 중첩루프    Python FizzBuzz 문제    Python 터틀 그래픽스로 그림 그리기    Python 리스트와 튜플 응용하기    Python 리스트와 튜플 응용하기 - 2    Python 2차원 리스트 사용하기    Python 문자열 응용하기    Python 딕셔너리 응용하기Python if 조건문으로 특정 조건일 때 코드 실행하기조건문은 특정 조건일 경우 코드를 실행하는 문법이다. 조건문은 여러 가지 상황을 처리해야 하는 경우 다양한 상황에 대처할 때 사용한다.1. if 조건문 사용하기if 조건문은 if에 조건식을 지정하고 :(클론)을 붙이며 다음줄에 실행할 코드가 나온다. 이때 코드는 반드시 들여쓰기를 해야한다.if 조건식 :  코드x = 10if x = 10 :    print('10입니다')    # 출력 : 10입니다.if 조건문의 기본 형태와 실행 흐름 알아보기파이썬에서 if 조건문은 if 조건식 : 형식으로 사용하며 그 다음 줄에는 들여쓰기를 한 뒤 조건식이 만족할 때 실행할 코드를 넣는다. 이 조건식이 만족할 때 실행할 코드를 if 본문(if body)이라고 부른다.if x == 10 : # 조건식    print('10입니다.') #if 본문# 들여쓰기4칸    if 의 조건식이 만족하면 참(True), 만족하지 않으면 거짓(False)이라고 부른다.if 조건문을 사용할 때 주의할 점if 조건문을 사용할 때 주의할 점이 있는데 파이썬에서는 =을 할당으로 사용하고 있으므로 값을 비교할때는 ==로 사용한다. 자주 틀리는 부분이니 if안에서 == 을 사용했는지 반드시 확인하자. 또한 :(클론)을 빠뜨리지 않도록 주의한다.if x = 10:   File \"&lt;stdin&gt;\", line 1    if x = 10:         ^SyntaxError: invalid syntax if x == 10    File \"&lt;stdin&gt;\", line 1    if x == 10             ^SyntaxError: invalid syntax if 조건문에서 코드를 생략하기if 조건문에 조건식만 작성하고 코드를 생략하는 방법을 알아보자. if 다음줄에 pass라는 특별한 키워드를 넣었다. 여기서 pass는 아무 일도 하지 않고 그냥 넘어간다는 뜻이다. 파이썬은 if 다음줄에 아무 코드도 넣지 않으면 에러가 발생하므로 if 조건문의 형태를 유지하기 위해 pass를 사용한다.pass는 아무 일도 하지 않는 코드라서 의미가 없을 것 같지만 나중에 작성해야 할 코드를 표시할 때 사용할 수 있다. 즉, 다음과 같이 pass만 넣고 나중에 할 일은 주석으로 남겨놓는 방식이다.if x == 10:    pass    # TODO: x가 10일 때 처리가 필요함  TODO : TODO는 해야 할 일이라는 뜻인데 보통 주석에 넣는다. 이렇게 TODO를 넣어 두면 검색으로 쉽게 찾을 수 있다.그래서 프로그래머들은 주석에 TODO 이외에도 FIXME, BUG, NOTE 등과 같이 코드는 아니지만 일관된 주석을 사용한다.2. if 조건문과 들여쓰기파이썬은 들여쓰기도 문법으로 정해져 있으며 if 조건문도 들여쓰기가 중요하다.아래 코드를 실행하면 unexpected indent 에러가 발생한다.x = 10 if x == 10:     print('x에 들어있는 숫자는')         print('10입니다.')     # unexpected indent 에러 발생올바른 코드로 고쳐보자.x = 10 if x == 10:     print('x에 들어있는 숫자는')     print('10입니다.')# 실행결과  x에 들어있는 숫자는# 10입니다.if 다음에 오는 코드들은 반드시 들여쓰기 깊이가 같아야 한다. 만약 첫 번째 print만 들여쓰기를 하고, 두 번째 print는 들여쓰기를 하지 않으면 의도치 않은 동작이 된다.x = 10 if x == 10:     print('x에 들어있는 숫자는')print ('10입니다.')# 실행결과  x에 들어있는 숫자는# 10입니다.print 두 개가 모두 실행되 잘 동작하는것 같지만 x의 값을 5로 하면 어떻게 될까? x에 5를 할당했기 때문에 if의 조건식을 만족하지 않음으로 다음에 오는 print는 실행이 되지 않는다. 그런데 print(‘10입니다.’)는 실행이 되었다. 들여쓰기가 없어서 if와는 상관없는 코드가 되었기 때문이다.x = 5          # x에 5를 할당 if x == 10:    # x가 5라서 조건식을 만족하지 않음     print('x에 들어있는 숫자는')print ('10입니다.')# 10입니다.즉, if 다음 줄에 들여쓰기가 된 코드는 if의 영향을 받아서 조건식에 따라 실행이 결정되지만 들여쓰기가 되지 않은 코드는 항상 실행된다. 이런 코드는 일단 실행이 되기 때문에 잘못된 부분을 찾기가 쉽지 않다. 내가 의도한 부분의 코드의 들여쓰기가 일치하는지 항상 확인하자. 파이썬에서 :가 나오면 그 다음 줄부터는 무조건 들여쓰기를 한다는 점만 기억하면 된다.if와 들여쓰기 칸 수if에서 처음부터 들여쓰기를 4칸으로 했다면 계속 4칸으로 유지하고, 2칸으로 했다면 계속 2칸으로 유지한다. 어떨 땐 4칸 어떨 땐 2칸 이렇게는 안 된다. 파이썬 코딩 스타일 가이드(PEP 8)에서는 공백4칸으로 규정하고 있으므로 4칸을 권장한다.3. 중첩 if 조건문 사용하기if 를 여러번 사용하는 중첩 if 조건문을 사용해보자. 다음은 변수의 값이 10이상이면 ‘10 이상입니다.’를 출력한 뒤 15이면 ‘15입니다.’, 20이면 ‘20입니다.’를 출력한다.x = 15 if x &gt;= 10:     print('10 이상입니다.')      if x == 15:         print('15입니다.')      if x == 20:         print('20입니다.')# 출력 10 이상입니다.#      15입니다.들여쓰기에 주목하자. x가 10이상일때 출력하는 코드안에 if를 보면 들여쓰기가 되어있다. 이렇게 들여쓰기가 된 if x == 15:와 if x == 20:은 처음에 나온 if x &gt;= 10:에 속한 코드이다. 즉, if x &gt;= 10:의 조건식이 만족해야만 실행되는 코드라는 말이다.if x &gt;= 10:    print('10 이상입니다.')     if x == 15:        print('15입니다.')     if x == 20:        print('20입니다.') 그리고 다시 안쪽의 if에 속한 print는 들여쓰기를 한번 더 해준다.if x &gt;= 10:    print('10 이상입니다.')     if x == 15:        print('15입니다.')      if x == 20:        print('20입니다.') 4. 사용자가 입력한 값에 if 조건문 사용하기이번에는 input을 사용하여 사용자가 입력한 값을 변수에 저장하고, if 조건문으로 값을 비교해 보자.x = int(input())          # 입력받은 값을 변수에 저장 if x == 10:               # x가 10이면    print('10입니다.')    # '10입니다.'를 출력 if x == 20:               # x가 20이면    print('20입니다.')    # '20입니다.'를 출력입력 값이 x에 저장되고, if로 x가 10인지 비교하였다. 여기서는 10을 입력했으므로 ‘10입니다.’가 출력된다. 20과 다른 값을 입력하여 if가 동작하는 모습을 살펴보자.지금까지 if 조건문에 대해 알아보았다. if 조건문은 조건식이 만족했을 때 코드를 실행한다는 점이 중요하다. 특히 if 조건문은 들여쓰기에 따라 문법 에러가 발생하거나, 의도치 않은 동작이 나올 수 있으므로 들여쓰기 규칙을 정확히 익혀 두는것이 중요하다.",
        "url": "/python-basic10"
    }
    ,
    
    "python-basic9": {
        "title": "Python - Python 딕셔너리 사용하기",
            "author": "AhnSang0915",
            "category": "",
            "content": "Python    Python 기본    Python 숫자 계산하기    Python 변수 만들기    Python 출력 방법    Python 불과 비교, 논리 연산자    Python 문자열 사용하기    Python 리스트와 튜플 사용하기    Python 시퀀스 자료형 활용하기    Python 딕셔너리 사용하기    Python if 조건문으로 특정 조건일 때 코드 실행하기    Python else를 사용하여 두 방향으로 분기하기    Python elif를 사용하여 두 방향으로 분기하기    Python for 반복문    Python while 반복문    Python break, continue로 반복문 제어하기    Python 중첩루프    Python FizzBuzz 문제    Python 터틀 그래픽스로 그림 그리기    Python 리스트와 튜플 응용하기    Python 리스트와 튜플 응용하기 - 2    Python 2차원 리스트 사용하기    Python 문자열 응용하기    Python 딕셔너리 응용하기Python 딕셔너리 사용하기파이썬은 연관된 값을 묶어 저장하는 용도로 딕셔너리라는 자료형을 제공한다. 게임 캐릭터의 능력치를 딕셔너리에 저장해봤다.lux = {'health': 490, 'mana': 334, 'melee': 550, 'armor': 18.72}이제 딕셔너리만 봐도 lux라는 캐릭터의 체력(health)은 490, 마나(mana)는 334, 사거리(melee)는 550, 방어력(armor)은 18.72라는 것을 쉽게 알 수 있다.1. 딕셔너리 만들기딕셔너리는 {}안에 키 : 값 의 형식으로 저장하며 각 키와 값은 ,(콤마)로 구분해 준다. 키를 먼저 지정하고 :(콜론)을 붙여서 값을 표현한다. 특히 키에는 값을 하나만 지정할 수 있으며 이런 특성을 따서 키 - 값 쌍(key-value pair)이라 부른다(키-값은 1:1 대응).lux = {'health': 490, 'mana': 334, 'melee': 550, 'armor': 18.72}lux{'health': 490, 'mana': 334, 'melee': 550, 'armor': 18.72}키 이름이 중복되면?딕셔너리의 키값이 중복되면 가장 뒤에있는 값만 사용한다. 중복된 키는 저장되지 않는다. 딕셔너리 lux를 만들 때 ‘health’: 490이 있고 그 뒤에 ‘health’: 800을 넣었다. lux[‘health’]를 출력해보면 800이 나오는걸 알 수 있다.lux = {'health': 490, 'health': 800, 'mana': 334, 'melee': 550, 'armor': 18.72}lux['health']    # 키가 중복되면 가장 뒤에 있는 값만 사용함800lux    # 중복되는 키는 저장되지 않음{'health': 800, 'mana': 334, 'melee': 550, 'armor': 18.72}딕셔너리 키의 자료형딕셔너리의 키는 문자열뿐만 아니라 정수, 실수, 불 도 사용할 수 있으며 자료형을 섞어서 사용해도 된다. 그리고 값에는 리스트, 딕셔너리 등을 포함하여 모든 자료형을 사용할 수 있다. 단, 키에는 리스트와 딕셔너리를 사용할 수 없다.x = {100: 'hundred', False: 0, 3.5: [3.5, 3.5]}x{100: 'hundred', False: 0, 3.5: [3.5, 3.5]}x = {100 : 20, 100 : {100: 800}}x{100: {100: 800}}# 키에는 리스트와 딕셔너리를 사용할 수 없다.x = {[10, 20]: 100}Traceback (most recent call last):  File \"&lt;pyshell#3&gt;\", line 1, in &lt;module&gt;    x = {[10, 20]: 100}TypeError: unhashable type: 'list'x = \\{\\{'a': 10}: 100\\}Traceback (most recent call last):  File \"&lt;pyshell#4&gt;\", line 1, in &lt;module&gt;    x = \\{\\{'a': 10\\}: 100\\}TypeError: unhashable type: 'dict'빈 딕셔너리 만들기비어있는 딕셔너리를 만들때는 {}만 지정하거나 dict을 사용하면 된다. 보통 {}를 주로 사용한다.  딕셔너리 = {}  딕셔너리 = dict()x = {}x# {}y = dict()y# {}dict로 딕셔너리 만들기dict는 다음과 같이 키와 값을 연결하거나, 리스트, 튜플, 딕셔너리로 딕셔너리를 만들때 사용한다.  딕셔너리 = dict(키1=값1, 키2=값2)  딕셔너리 = dict(zip([키1, 키2], [값1, 값2]))  딕셔너리 = dict([(키1, 값1), (키2, 값2)])  딕셔너리 = dict({키1: 값1, 키2: 값2})다음과 같이 dict에서 키=값 형식으로 딕셔너리를 만들 수 있다. 이때는 키에 ‘ ‘(작은따옴표)나 “ “(큰따옴표)를 사용하지 않아야 한다. 키는 딕셔너리를 만들고 나면 문자열로 바뀐다.lux1 = dict(health=490, mana=334, melee=550, armor=18.72)    # 키=값 형식으로 딕셔너리를 만듦lux1{'health': 490, 'mana': 334, 'melee': 550, 'armor': 18.72}두 번째 방법은 dict에서 zip 함수를 이용하는 방법이다. 다음과 같이 키가 들어있는 리스트와 값이 들어있는 리스트를 차례대로 zip에 넣은 뒤 다시 dict에 넣어주면 된다. 물론 키와 값을 리스트가 아닌 튜플에 저장해서 zip에 넣어도 된다.lux2 = dict(zip(['health', 'mana', 'melee', 'armor'], [490, 334, 550, 18.72]))     # zip 함수로lux2      # 키 리스트와 값 리스트를 묶음{'health': 490, 'mana': 334, 'melee': 550, 'armor': 18.72}세 번째 방법은 리스트 안에 (키, 값) 형식의 튜플을 나열하는 방법이다.lux3 = dict([('health', 490), ('mana', 334), ('melee', 550), ('armor', 18.72)])lux3    # (키, 값) 형식의 튜플로 딕셔너리를 만듦{'health': 490, 'mana': 334, 'melee': 550, 'armor': 18.72} 네 번째 방법은 dict 안에서 중괄호로 딕셔너리를 생성하는 방법이다.lux4 = dict({'health': 490, 'mana': 334, 'melee': 550, 'armor': 18.72})     # dict 안에서lux4  # 중괄호로 딕셔너리를 만듦{'health': 490, 'mana': 334, 'melee': 550, 'armor': 18.72}2. 딕셔너리의 키에 접근하고 값 할당하기딕셔너리의 키에 접근할 때는 딕셔너리 뒤에  를 사용하며 [ ] 안에 키를 지정해주면 된다.lux = {'health': 490, 'mana': 334, 'melee': 550, 'armor': 18.72}lux['health']490lux['armor']18.72#딕셔너리에 키를 지정하지 않은상태는 해당 딕셔너리 전체를 뜻한다.lux = {'health': 490, 'mana': 334, 'melee': 550, 'armor': 18.72}lux    # 딕셔너리에 키를 지정하지 않으면 딕셔너리 전체를 뜻함{'health': 490, 'mana': 334, 'melee': 550, 'armor': 18.72}딕셔너리의 키에 값 할당하기딕셔너리는 []로 키에 접근한 뒤 값을 할당할 수 있다.lux = {'health': 490, 'mana': 334, 'melee': 550, 'armor': 18.72}lux['health'] = 2037lux['mana'] = 1184lux{'health': 2037, 'mana': 1184, 'melee': 550, 'armor': 18.72}딕셔너리에 없는 키에 값을 할당하면 해당 키와 값이 추가된다.lux['mana_regen'] = 3.28lux{'health': 2037, 'mana': 1184, 'melee': 550, 'armor': 18.72, 'mana_regen': 3.28}딕셔너리에 없는 키값을 가져오려고 하면 에러가 발생한다.\\lux = {'health': 490, 'mana': 334, 'melee': 550, 'armor': 18.72}lux['attack_speed']    # lux에는 'attack_speed' 키가 없음Traceback (most recent call last):  File \"&lt;pyshell#3&gt;\", line 1, in &lt;module&gt;    lux['attack_speed']KeyError: 'attack_speed'딕셔너리에 키가 있는지 확인하기딕셔너리 안에 키가 있는지 확인하려면 in연산자를 사용한다.  키 in 딕셔너리딕셔너리에 특정 키가 있으면 True 없으면 Fasle가 나온다.lux = {'health': 490, 'mana': 334, 'melee': 550, 'armor': 18.72}'health' in luxTrue'attack_speed' in luxFalse반대로 not in을 하면 특정 키가 없는지 확인한다. 없으면 True 있으면 False가 나온다.lux = {'health': 490, 'mana': 334, 'melee': 550, 'armor': 18.72}&gt;&gt;&gt; 'attack_speed' not in luxTrue&gt;&gt;&gt; 'health' not in luxFalse  해시 : 딕셔너리는 해시(Hash) 기법을 이용해서 데이터를 저장한다. 보통 딕셔너리와 같은 키-값 형태의 자료형을 해시, 해시 맵, 해시테이블 등으로 부르기도 한다.딕셔너리의 키 개수 구하기딕셔너리를 사용하다 보면 딕셔너리의 키 개수를 구할 필요가 있다. 딕셔너리의 키와 값을 직접 타이핑 할 때는 키의 개수를 알기가 쉽다. 하지만 실무에서는 함수 등을 사용해서 딕셔너리를 생성하거나 키를 추가하기 때문에 키의 개수가 눈에 보이지 않는다. 따라서 다음과 같이 키의 개수는 len함수를 사용하여 구한다.  len(딕셔너리)len에 딕셔너리 변수를 넣어도 되고 딕셔너리를 그대로 넣어도 된다.lux = {'health': 490, 'mana': 334, 'melee': 550, 'armor': 18.72}len(lux)4len({'health': 490, 'mana': 334, 'melee': 550, 'armor': 18.72})4",
        "url": "/python-basic9"
    }
    ,
    
    "python-basic8": {
        "title": "Python - Python 시퀀스 자료형 활용하기",
            "author": "AhnSang0915",
            "category": "",
            "content": "Python    Python 기본    Python 숫자 계산하기    Python 변수 만들기    Python 출력 방법    Python 불과 비교, 논리 연산자    Python 문자열 사용하기    Python 리스트와 튜플 사용하기    Python 시퀀스 자료형 활용하기    Python 딕셔너리 사용하기    Python if 조건문으로 특정 조건일 때 코드 실행하기    Python else를 사용하여 두 방향으로 분기하기    Python elif를 사용하여 두 방향으로 분기하기    Python for 반복문    Python while 반복문    Python break, continue로 반복문 제어하기    Python 중첩루프    Python FizzBuzz 문제    Python 터틀 그래픽스로 그림 그리기    Python 리스트와 튜플 응용하기    Python 리스트와 튜플 응용하기 - 2    Python 2차원 리스트 사용하기    Python 문자열 응용하기    Python 딕셔너리 응용하기Python 시퀀스 자료형 활용하기지금까지 사용했던 리스트, 튜플, range, 문자열을 잘 보면 공통점이 있다. 이들 모두 값이 연속적(sequence)으로 이어져 있다는 점이다. 파이썬에서는 리스트, 튜플, range, 문자열처럼 값이 연속적으로 이어진 자료형을 시퀀스 자료형(sequence types)라고 부른다.—1. 시퀀스 자료형의 공통 기능 사용하기시퀀스 자료형의 가장 큰 특징은 공통된 동작과 기능을 제공한다는 점이다. 따라서 시퀀스 자료형의 기본적인 사용 방법을 익혀 두면 나중에 어떠한 시퀀스 자료형을 접하게 되더라도 큰 어려움 없이 바로 사용할 수 있다.시퀀스 자료형으로 만든 객체를 시퀀스 객체라고 하며, 시퀀스 객체에 들어있는 각 값을 요소(element)라고 부른다.특정 값이 있는지 확인하기시퀀스 객체 안에 특정 값이 있는지 확인하는 방법이다. 아래 코드는 a에서 30과 100이 있는지 확인한다. 확인하려는 값이 있으면 True 없으면 False가 나온다.a = [0, 10, 20, 30, 40, 50, 60, 70, 80, 90]30 in aTrue100 in aFalsein 앞에 not을 붙이면 값이 없는지 확인한다. 없으면 True 있으면 False가 나온다.a = [0, 10, 20, 30, 40, 50, 60, 70, 80, 90]100 not in aTrue30 not in aFalse튜플, range, 문자열 에도 사용 가능하다.43 in (38, 76, 43, 62, 19)True1 in range(10)True'p' in 'Hello, Python'False시퀀스 객체 연결하기시퀀스 객체는 +연산자를 사용하여 객체를 서로 연결하여 새 객체를 만들 수 있다.a = [0, 10, 20, 30]b = [9, 8, 7, 6]a + b[0, 10, 20, 30, 9, 8, 7, 6]range는 +연산자로 객체를 연결할 수 없다.range(0, 10) + range(10, 20)Traceback (most recent call last):  File \"&lt;pyshell#1&gt;\", line 1, in &lt;module&gt;    range(0, 10) + range(10, 20)TypeError: unsupported operand type(s) for +: 'range' and 'range' range를 연결하고 싶다면 리스트 또는 튜플로 연결해야 한다.list(range(0, 10)) + list(range(10, 20))[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19]tuple(range(0, 10)) + tuple(range(10, 20))(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19)문자열은 +연산자로 여러 문자열을 연결할 수 있다.'Hello, ' + 'world!''Hello, world!'문자열에 정수,실수를 연결하고 싶다면 str을 사용해 숫자를 문자열로 변환해 연결해 주면 된다.'Hello, ' + str(10)      # str을 사용하여 정수를 문자열로 변환'Hello, 10''Hello, ' + str(1.5)     # str을 사용하여 실수를 문자열로 변환'Hello, 1.5'시퀀스 객체 반복하기*연산자를 사용하면 시퀀스 객체를 특정 횟수만큼 반복할 수 있다. 0또는 음수를 곱하면 빈 객체가 나오며 실수는 곱할 수 없다.[0, 10, 20, 30] * 3[0, 10, 20, 30, 0, 10, 20, 30, 0, 10, 20, 30][0, 10, 20, 30] * 0[][0, 10, 20, 30] * -1[][0, 10, 20, 30] * 3.2Traceback (most recent call last):  File \"&lt;pyshell#45&gt;\", line 1, in &lt;module&gt;    [0, 10, 20, 30] * 3.2TypeError: can't multiply sequence by non-int of type 'float'range는 연결과 마찬가지로 *연산자를 사용해 반복할 수 없다. range를 리스트나 튜플로 만들어 연결할 수 있다.list(range(0, 5, 2)) * 3[0, 2, 4, 0, 2, 4, 0, 2, 4]tuple(range(0, 5, 2)) * 3(0, 2, 4, 0, 2, 4, 0, 2, 4)문자열은 *연산자를 사용해 반복이 가능하다.'ansang' * 3'ansangansangansang'2. 시퀀스 객체의 요소 개수 구하기요소의 길이는 len함수를 사용해 구할 수 있다.리스트와 튜플의 요소 개수 구하기리스트의 요소는 아래와 같이 구할 수 있다.a = [0, 10, 20, 30, 40, 50, 60, 70, 80, 90]len(a)10튜플도 마찬가지 이다.b = (38, 76, 43, 62, 19)len(b)5range에 len을 사용하면 숫자가 생성되는 개수를 구할 수 있다. 예제에서는 요소의 수가 적어 알기 쉽지만 실무에서는 요소가 많고 추가 삭제 반복을 하기 때문에 len을 사용해야한다.문자열의 길이 구하기문자열도 시퀀스 자료형이므로 len 함수를 사용하면 된다. 공백도 포함이되고 문자열을 묶은 따옴표는 제외된다. 따옴표는 문자열을 표현하는 문법일뿐 길이에는 포함되지 않는다.(문자열의 큰따옴표와 작은따옴표의 경우는 포함된다.)hello = 'Hello, world!'len(hello)13hello = '안녕하세요'len(hello)53. 인덱스 사용하기시퀀스 객체에 들어있는 요소에 접근하는 방법을 알아보자. 시퀀스 객체의 각 요소는 순서가 정해져 있으며, 이 순서를 인덱스라고 부른다. 인덱스의 시작 숫자는 항상 0부터 시작하는것을 기억하자.리스트a = [38, 21, 53, 62, 19]a[0]    # 리스트의 첫 번째(인덱스 0) 요소 출력38a[2]    # 리스트의 세 번째(인덱스 2) 요소 출력53a[4]    # 리스트의 다섯 번째(인덱스 4) 요소 출력19튜플b = (38, 21, 53, 62, 19)b[0]        # 튜플의 첫 번째(인덱스 0) 요소 출력38ranger = range(0, 10, 2) # 02468r[2]        # range의 세 번째(인덱스 2) 요소 출력4문자열hello = 'Ansang coding'hello[7]    # 문자열의 여덟 번째(인덱스 7) 요소 출력'c'시퀀스 객체에 인덱스를 지정하지 않으면 해당 객체 전체를 뜻한다. 시퀀스 객체에서 []를 사용하면 실제로는 __getitem__메서드를 호출하는 것과 같다. 따라서 __getitem__을 사용해 요소를 가져올 수도 있다.a = [38, 21, 53, 62, 19]a.__getitem__(1)21음수 인덱스 지정하기인덱스를 음수로 지정하면 요소의 뒤에서부터 접근한다. -1은 뒤에서 첫번째를 의미하게 되는것이다.# 리스트a = [38, 21, 53, 62, 19]a[-1]   # 리스트의 뒤에서 첫 번째(인덱스 -1) 요소 출력19a[-5]   # 리스트의 뒤에서 다섯 번째(인덱스 -5) 요소 출력38#튜플b = (38, 21, 53, 62, 19)b[-1]        # 튜플의 뒤에서 첫 번째(인덱스 -1) 요소 출력19#ranger = range(0, 10, 2)r[-3]        # range의 뒤에서 세 번째(인덱스 -3) 요소 출력4#문자열hello = 'Ansang coding'hello[-4]    # 문자열의 뒤에서 네 번째(인덱스 -4) 요소 출력'd'인덱스의 범위를 벗어나면?시퀀스 객체의 인덱스는 요소의 숫자보다 하나 작은 값이 마지막 인덱스 값이 된다.a = [38, 21, 53, 62, 19]a[5]    # 인덱스 5는 범위를 벗어났으므로 에러Traceback (most recent call last):  File \"&lt;pyshell#1&gt;\", line 1, in &lt;module&gt;    a[5]IndexError: list index out of range 마지막 요소에 접근하기시퀀스 객체의 인덱스를 -1로 지정하게되면 뒤에서 첫번째 요소에 접근한다. 시퀀스 객체의 마지막 요소에 접근하는 다른 방법을 알아보자.아래와 같이 len함수를 사용해 길이를 구하고 그 값을 그대로 넣으면 에러가 발생한다. 인덱스 값은 요소의 전체 숫자보다 하나가 작기 때문이다.a = [38, 21, 53, 62, 19]a[len(a)]Traceback (most recent call last):  File \"&lt;pyshell#3&gt;\", line 1, in &lt;module&gt;    a[len(a)]IndexError: list index out of range 요소의 길이를 구하고 -1을 해주게끔 코드를 바꿔보자.a = [38, 21, 53, 62, 19]a[len(a)-1]# 19요소에 값 할당하기시퀀스 객체중 리스트만이 요소를 수정, 변경, 삭제할 수 있다. 튜플, range, 문자열은 값 할당이 불가능하다. 시퀀스 객체는 []로 요소에 접근한뒤 = 로 값을 할당한다. 이때도 볌위를 벗어난 인덱스는 지정할 수 없다.a = [0, 0, 0, 0, 0]    # 0이 5개 들어있는 리스트a[0] = 38a[1] = 21a[2] = 53a[3] = 62a[4] = 19a[38, 21, 53, 62, 19]a[0]38a[4]19# 인덱스 범위를 벗어나 지정할 경우a[5] = 90Traceback (most recent call last):  File \"&lt;pyshell#4&gt;\", line 1, in &lt;module&gt;    a[5] = 90IndexError: list assignment index out of range del로 요소 삭제하기마찬가지로 리스트만 삭제가 가능하고 튜플, range, 문자열은 불가능하다. 삭제 방법은 del 시퀀스객체[index]로 삭제할 수 있다.a = [38, 21, 53, 62, 19]del a[2]a[38, 21, 62, 19]4. 슬라이스 사용하기슬라이스는 시퀀스 객체의 일부를 잘라내 사용하는 방법이다. 다음은 리스트의 일부를 잘라내 새 리스트를 만든다. 인덱스의 끝 값은 가져오려는 범위에 포함되지 않는것을 기억하자.a = [0, 10, 20, 30, 40, 50, 60, 70, 80, 90]a[0:4]  # 인덱스의 0부터 3까지 잘라내 새 리스트를 만든다.[0, 10, 20, 30]# 처음부터 끝까지 가져오려고 할때a[0:10] # 요소의 숫자는 9개지만 모두 가져오려고 한다면 10을 끝인덱스로 지정해야한다.[0, 10, 20, 30, 40, 50, 60, 70, 80, 90]슬라이스를 했을 때 실제로 가져오는 요소는 시작 인덱스 부터 끝인덱스 -1까지 이다.리스트의 중간 부분 가져오기리스트 중간의 부분을 가져오는 방법도 동일하다.a = [0, 10, 20, 30, 40, 50, 60, 70, 80, 90]a[4:7] # 4, 5, 6 인덱스를 가져왔다.[40, 50, 60]인덱스를 음수로 지정하면 마찬가지로 끝인덱스의 -1까지 가져온다.a = [0, 10, 20, 30, 40, 50, 60, 70, 80, 90]a[4:-1] # 인덱스 4부터 인덱스 -2까지[40, 50, 60, 70, 80]인덱스 증가폭 사용하기슬라이스는 range처럼 인덱스의 증가폭을 지정해 범위내의 요소를 가져올 수 있다.다음은 인덱스를 3씩 증가시키며 요소를 가져온다. 주의할 점은 인덱스의 증가폭이지 요소의 값 증가폭이 아니라는 점이다. 인덱스 2의값 그다음 5의값 그다음 8의 값을 가져올것 같지만 슬라이스는 마지막 인덱스값의 -1까지만 가져오게 되어있고 마지막 인덱스 8의 -1인 7까지에서 3씩 증가시킨 값인 2와 5의 값만을 가져오게 된다. 인덱스의 증가폭을 지정하더라도 가져오려는 인덱스를 넘어설 수 없다는 것이다.a = [0, 10, 20, 30, 40, 50, 60, 70, 80, 90]a[2:8:3] # 인덱스 2~8(-1인 7까지)의 값중 3씩증가시킨 인덱스 2와 5의 값[20, 50]만약 끝 인덱스 -1과 증가폭으로 증가한 인덱스가 일치하면 해당 요소까지 가져올 수 있다. 다음은 끝 인덱스를 9로 지정하여 인덱스 8의 80까지 가져온다.a = [0, 10, 20, 30, 40, 50, 60, 70, 80, 90]a[2:9:3] # 인덱스 2~9(-1인 8까지)의 값중 3씩증가시킨 인덱스 2, 5, 8의 값[20, 50, 80]인덱스 생략하기슬라이스 사용시 시작인덱스와 끝인덱스를 생략할 수 있다. 생략하는 방법은 객체의 길이를 몰라도 값을 가져올 수 있기 때문에 자주 쓰이는 방식이다. 주로 시퀀스 객체의 마지막 일부분만 출력할 때 사용한다.a = [0, 10, 20, 30, 40, 50, 60, 70, 80, 90]a[:7] # 인덱스 0부터 6까지의 값을 가져온다.[0, 10, 20, 30, 40, 50, 60]a[7:] # 인덱스 7부터 끝까지의 값을 가져온다.[70, 80, 90]a[:] # 인덱스 처음부터 끝까지의 값을 가져온다.[0, 10, 20, 30, 40, 50, 60, 70, 80, 90]인덱스를 생략하면서 증가폭 사용하기인덱스의 처음또는 끝 값을 생략하면서 증가폭을 가지고 값을 가져올수도 있다.a = [0, 10, 20, 30, 40, 50, 60, 70, 80, 90]a[:7:2] # 인덱스 0(처음)부터 6까지의 값중 인덱스 값을 2씩 증가시킨 인덱스의 값을 가져온다. 0, 2, 4, 6의 값을 가져온다.[0, 20, 40, 60]a[7::2] # 인덱스 7부터 끝까지의 값중 인덱스 값을 2씩 증가시킨 인덱스 값을 가져온다. 인덱스 7, 9의 값을 가져온다.[70, 90]a[::2] # 인덱스 처음부터 끝까지의 값중 인덱스 값을 2 씩증가시킨 인덱스 값을 가져온다. 인덱스 0, 2, 4, 6, 8의 값을 가져온다.[0, 20, 40, 60, 80]a[5:1:-1] # 인덱스 5부터 2까지의 값중 인덱스의 값을 -1씩 감소시킨 인덱스 값을 가져온다. 인덱스 5, 4, 3, 2의 값을 가져온다.[50, 40, 30, 20]a[::] # 시작, 끝, 증가폭을 모두 생략하면 리스트 전체를 가져온다. 즉, a[:]와 a[::]의 결과는 같다.[0, 10, 20, 30, 40, 50, 60, 70, 80, 90]a[::-1] # 리스트 전체에서 인덱스를 1씩 감소시키며 값을 가져옴으로 리스트를 반대로 뒤집게 된다.[90, 80, 70, 60, 50, 40, 30, 20, 10, 0]len 응용하기len을 사용하여 리스트 전체를 가져올 수 있다. len(a)의 값은 10이기 때문에 인덱스 9까지의 값을 가져오게 된다. 요소의 갯수가 9개이기 때문에 모든 값을 가져올 수 있다.a = [0, 10, 20, 30, 40, 50, 60, 70, 80, 90]a[0:len(a)] # 인덱스 0부터 9까지의 값을 가져온다.[0, 10, 20, 30, 40, 50, 60, 70, 80, 90]a[:len(a)] # 시작 인덱스를 생략[0, 10, 20, 30, 40, 50, 60, 70, 80, 90]튜플, range, 문자열에 슬라이스 사용하기튜플, range, 문자열도 시퀀스 자료형이기 때문에 슬라이스를 사용할 수 있다.b = (0, 10, 20, 30, 40, 50, 60, 70, 80, 90)b[4:7] # 인덱스 4부터 6까지의 값(40, 50, 60)b[4:] # 인덱스 4부터 마지막까지의 값(40, 50, 60, 70, 80, 90)b[:7:2] # 인덱스 처음부터 6까지 중 2씩 증가한 값 0, 2, 4, 6(0, 20, 40, 60)range도 연속된 숫자를 만든다. range에 슬라이스를 사용하면 지정된 범위의 숫자를 생성하는 range객체를 새로 만든다.r = range(10)# 0~9까지의 값을 만든다.rrange(0, 10)r[4:7] # 인덱스 4부터 6까지 숫자 4, 5, 6을 생성하는 range객체를 만든다.range(4, 7)r[4:] # 인덱스 4부터 끝까지 숫자 4, 5, 6, 7, 8, 9를 생성하는 range객체를 만든다.range(4, 10)r[4:10] # 인덱스 4부터 9까지 숫자 4, 5, 6, 7, 8, 9를 생성하는 range객체를 만든다.range(4, 10)r[:7:2] # 인덱스 0부터 6까지 증가폭2를 갖는 인덱스 값에 해당되는 0, 2, 4, 6을 생성하는 range객체를 만든다.range(0, 7, 2)range는 리스트 튜플과 달리 요소가 모두 표시되지 않고 범위만 표시한다. list에 넣어 표시하게 만들어보자.list(r[4:7])[4, 5, 6]list(r[4:])[4, 5, 6, 7, 8, 9]list(r[4:10])[4, 5, 6, 7, 8, 9]list(r[:7:2])[0, 2, 4, 6]문자열도 시퀀스 자료형이기 때문에 슬라이스를 사용할 수 있다.hello = 'Hello, world!'hello[2:9]'llo, wo'hello[2:]'llo, world!'hello[:9:2]'Hlo o파이썬에서는 slice객체를 사용하여 시퀀스 객체를 잘라낼 수도 있다. 다음과 같이 시퀀스 객체의 []또는 getitem 메서드에 slice객체를 넣어주면 지정된 범위만큼 잘라내서 새 객체를 만든다.range(10)[slice(4, 7, 2)]range(4, 7, 2)range(10).__getitem__(slice(4, 7, 2))range(4, 7, 2)#슬라이스 객체를 하나만 만든뒤 여러 시퀀스 객체에 사용하는 방법a = [0, 10, 20, 30, 40, 50, 60, 70, 80, 90]s = slice(4, 7)a[s][40, 50, 60]r = range(10)r[s]range(4, 7)list(range(4,7))[4, 5, 6]hello = 'Hello, world!'hello[s]'o, 슬라이스에 요소 할당하기시퀀스 객체는 슬라이스로 범위를 지정해 여러 요소의 값을 할당할 수 있다. 리스트를 만들고 특정 범위의 요소에 값을 할당해 보자. 이렇게 범위를 지정해서 요소를 할당했을 경우에는 원래 있던 리스트가 변경되며 새 리스트는 생성되지 않는다.  시퀀스객체[시작인덱스:끝인덱스] = 시퀀스객체a = [0, 10, 20, 30, 40, 50, 60, 70, 80, 90]a[2:5] = ['a', 'b', 'c'] # 인덱스 2부터 4까지의 값을 a, b, c로 값을 할당한다.a[0, 10, 'a', 'b', 'c', 50, 60, 70, 80, 90]슬라이스 범위와 할당할 리스트의 요소 개수를 맞추지 않아도 알아서 할당된다. 개수가 적으면 리스트 요소도 줄어들고 많으면 요소 개수도 늘어난다.a = [0, 10, 20, 30, 40, 50, 60, 70, 80, 90]a[2:5] = ['a'] # 인덱스 2부터 4까지에 값 1개를 할당하여 요소의 개수가 줄어든다.a[0, 10, 'a', 50, 60, 70, 80, 90]a = [0, 10, 20, 30, 40, 50, 60, 70, 80, 90]a[2:5] = ['a', 'b', 'c', 'd', 'e'] # 인덱스 2부터 4까지 값 5개를 할당하여 요소의 개수가 늘어난다.a[0, 10, 'a', 'b', 'c', 'd', 'e', 50, 60, 70, 80, 90]슬라이스는 인덱스 증가폭을 지정할 수 있었다. 이번에는 인덱스 증가폭을 지정하여 인덱슬를 건너뛰면서 할당해보자. 단, 인덱스 증가폭을 지정할때는 슬라이스 범위의 요소 개수와 할당할 요소 개수가 정확히 일치해야 한다.  시퀀스객체[시작인덱스:끝인덱스:인덱스증가폭] = 시퀀스객체a = [0, 10, 20, 30, 40, 50, 60, 70, 80, 90]a[2:8:2] = ['a', 'b', 'c'] # 인덱스 2부터 7까지 2씩증가시키면서 a,b,c를 2씩 증가된 인덱스 위치에 할당.a[0, 10, 'a', 30, 'b', 50, 'c', 70, 80, 90]# 슬라이스 범위의 요소 개수와 할당할 요소 개수가 정확히 일치해야 한다.a = [0, 10, 20, 30, 40, 50, 60, 70, 80, 90]a[2:8:2] = ['a', 'b']Traceback (most recent call last):  File \"&lt;pyshell#1&gt;\", line 1, in &lt;module&gt;    a[2:8:2] = ['a', 'b']ValueError: attempt to assign sequence of size 2 to extended slice of size 3 튜플, range, 문자열은 슬라이스 범위를 지정하더라도 요소를 할당할 수 없다.b = (0, 10, 20, 30, 40, 50, 60, 70, 80, 90)b[2:5] = ('a', 'b', 'c')Traceback (most recent call last):  File \"&lt;pyshell#2&gt;\", line 1, in &lt;module&gt;    b[2:5] = ('a', 'b', 'c')TypeError: 'tuple' object does not support item assignment r = range(10)r[2:5] = range(0, 3)Traceback (most recent call last):  File \"&lt;pyshell#4&gt;\", line 1, in &lt;module&gt;    r[2:5] = range(0, 3)TypeError: 'range' object does not support item assignment hello = 'Hello, world!'hello[7:13] = 'Python'Traceback (most recent call last):  File \"&lt;pyshell#6&gt;\", line 1, in &lt;module&gt;    hello[7:13] = 'Python'TypeError: 'str' object does not support item assignment del로 슬라이스 삭제하기시퀀스 객체의 슬라이스를 삭제해보자. 슬라이스 삭제는 다음과 같이 del뒤에 삭제할 범위를 지정해주면 된다.  del 시퀀스객체[시작인덱스:끝인덱스]다음은 리스트의 인덱스 2부터4까지 요소를 삭제한다. del로 요소를 삭제하면 원래 있던 리스트가 변경되며 새 리스트는 생성되지 않는다.a = [0, 10, 20, 30, 40, 50, 60, 70, 80, 90]del a[2:5] # 리스트a에서 2~4까지의 요소를 삭제.a[0, 10, 50, 60, 70, 80, 90]인덱스 증가폭을 지정하면 인덱스를 건너뛰면서 삭제한다.a = [0, 10, 20, 30, 40, 50, 60, 70, 80, 90]del a[2:8:2] # 인덱스 2부터 7까지 2씩증가시키며 삭제. 인덱스 2, 4, 6의 값이 삭제된다.a[0, 10, 30, 50, 70, 80, 90]마찬가지로 튜플, range, 문자열은 del로 슬라이스를 삭제할 수 없다.b = (0, 10, 20, 30, 40, 50, 60, 70, 80, 90)del b[2:5]Traceback (most recent call last):  File \"&lt;pyshell#8&gt;\", line 1, in &lt;module&gt;    del b[2:5]TypeError: 'tuple' object does not support item deletionr = range(10)del r[2:5]Traceback (most recent call last):  File \"&lt;pyshell#10&gt;\", line 1, in &lt;module&gt;    del r[2:5]TypeError: 'range' object does not support item deletion hello = 'Hello, world!'del hello[2:9]Traceback (most recent call last):  File \"&lt;pyshell#12&gt;\", line 1, in &lt;module&gt;    del hello[2:9]TypeError: 'str' object does not support item deletion",
        "url": "/python-basic8"
    }
    ,
    
    "python-basic7": {
        "title": "Python - Python 리스트와 튜플 사용하기",
            "author": "AhnSang0915",
            "category": "",
            "content": "Python    Python 기본    Python 숫자 계산하기    Python 변수 만들기    Python 출력 방법    Python 불과 비교, 논리 연산자    Python 문자열 사용하기    Python 리스트와 튜플 사용하기    Python 시퀀스 자료형 활용하기    Python 딕셔너리 사용하기    Python if 조건문으로 특정 조건일 때 코드 실행하기    Python else를 사용하여 두 방향으로 분기하기    Python elif를 사용하여 두 방향으로 분기하기    Python for 반복문    Python while 반복문    Python break, continue로 반복문 제어하기    Python 중첩루프    Python FizzBuzz 문제    Python 터틀 그래픽스로 그림 그리기    Python 리스트와 튜플 응용하기    Python 리스트와 튜플 응용하기 - 2    Python 2차원 리스트 사용하기    Python 문자열 응용하기    Python 딕셔너리 응용하기Python 리스트와 튜플 사용하기1. 리스트 만들기지금까지는 변ㄴ수에 값을 한 개씩만 저장했다. 여러 값을 저장할 수 있는 리스트를 알아보자. 대괄호로 원하는 값들을 묶어주면 된다.a = [38, 21, 53, 62, 19]a[38, 21, 53, 62, 19]리스트에 여러 가지 자료형 저장하기리스트는 문자열, 정수, 실수, 불 등 모든 자료형을 저장할 수 있고 섞어서 저장해도 된다.person = ['ansang', 31, 9.15, True]person['ansang', 31, 9.15, True]빈 리스트 만들기빈리스트는 []또는 list()로 만들수 있다.a = []a# []b = list()b# []range를 사용하여 리스트 만들기range를 사용해 리스트를 만들어 보자. range는 연속된 숫자를 생성한다. range에 10을 지정하면 0에서 9까지의 숫자를 생성한다.range(10)range(0, 10)a = list(range(10))a[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]range는 시작숫자와 끝나는 숫자를 지정할 수도 있다. 이떄도 끝나는 숫자는 생성되지 않는다.b = list(range(5, 12))b[5, 6, 7, 8, 9, 10, 11]증가폭을 다르게 할수도 있다. 이때는 range(시작, 끝, 증가폭)의 형식으로 작성해주면 된다. 음수로 작성하면 해당 값만큼 감소하는 리스트가 생성된다.c = list(range(-4, 10, 2))c[-4, -2, 0, 2, 4, 6, 8]d = list(range(10, 0, -1))d[10, 9, 8, 7, 6, 5, 4, 3, 2, 1]2. 튜플 사용하기튜플은 리스트처럼 요소를 일렬로 저장하지만, 안에 저장된 요소를 변경, 추가, 삭제할 수 없다. 튜플이 있는 이유는 요소가 변경되지 않고 유지되어야할 때 사용한다. 변수에 값을 저장할때 ()로 묶어주거나 괄호로묶지 않고 ,로 값만 콤마로 구분해도 튜플이 된다.a = (1, 2, 3, 4, 5, 6, 7)a# (1, 2, 3, 4, 5, 6, 7)a = 1, 2, 3, 4, 5, 6, 7a# (1, 2, 3, 4, 5, 6, 7)튜플도 리스트 처럼 여러 자료형을 섞어서 저장할 수 있다.person = ('ansang', 31, 9.15, True)person('ansang', 31, 9.15, True)not은 논리값을 뒤집는다. not True는 False가 되고, not False는 True가 된다. 여기서 and, or, not 논리 연산자가 식 하나에 들어있으면 not, and, or순으로 판단한다.not True and False or not False# False and False or True# False or True# True순서가 헷갈릴 때는 괄호로 판단 순서를 명확히 나타내 주는 것이 좋다.((not True) and False) or (not False)# True요소가 한 개 들어있는 튜플 만들기함수 클래스를 사용하다보면 값이 아닌 튜플을 넣어야 하는 경우도 있다. 이때 요소가 하나인 튜플을 사용해야한다.아래와 같이 요소가 한개 있는 튜플을 만들면 그냥 값이된다.a = (38)a38요소가 하나인 튜플을 만들 때는 ()안에 값을 넣은후 ,를 붙여준다. 또는 괄호로 묶지 않고 값 한개에 ,를 붙여도 된다.a = (38,)a# (38,)a = 38,a# (38,)range를 사용하여 튜플 만들기리스트와 마찬가지로 range를 사용해 튜플을 만들어 보자.a = tuple(range(10))a(0, 1, 2, 3, 4, 5, 6, 7, 8, 9)b = tuple(range(5, 12))b(5, 6, 7, 8, 9, 10, 11)c = tuple(range(-4, 10, 2))c(-4, -2, 0, 2, 4, 6, 8)튜플을 리스트로 만들고 리스트를 튜플로 만들기튜플과 리스트는 요소를 변경, 추가, 삭제할 수 있는지 없는지만 다를 뿐 기능과 형태는 같다. 따라서 튜플을 리스트로 만들거나 리스트를 튜플로 만들 수도 있다.a = [1, 2, 3]a[1, 2, 3]tuple(a)(1, 2, 3)반대로 list안에 튜플을 넣으면 새 리스트가 생성된다.b = (4, 5, 6)b(4, 5, 6)list(b)[4, 5, 6]list와 tuple안에 문자열을 넣으면 문자 리스트, 문자 튜플이 생성된다.list('hello')['h', 'e', 'l', 'l', 'o']tuple('hello')('h', 'e', 'l', 'l', 'o')리스트와 튜플을 사용하면 변수 여러개를 한번에 만들 수 있다. 이떄 변수의 갯수와 리스트의 요소 갯수는 같아야한다.a, b, c = [1, 2, 3]d, e, f = (4, 5, 6)print(a, b, c)1 2 3print(d, e, f)4 5 6리스트와 튜플 변수로도 변수 여러개를 만들 수 있다. 다음과 같이 리스트와 튜플의 요소를 변수 여러 개에 할당하는 것을 리스트 언패킹(list unpacking), 튜플 언패킹(tuple unpacking)이라고 한다.x = [1, 2, 3]a, b, c = xprint(a, b, c)1 2 3y = (4, 5, 6)d, e, f = yprint(d, e, f)4 5 6‘입력 값을 변수 두 개에 저장하기’에서 사용한 input().split()은 리스트를 반환한다. 그래서 리스트 언패킹 형식으로 입력 값을 변수 여러 개에 저장할 수 있었다.input().split()10 20['10', '20']x = input().split()10 20a, b = x         # a, b = input().split()과 같음print(a, b)10 20리스트 패킹(list packing)과 튜플 패킹(tuple packing)은 변수에 리스트 또는 튜플을 할당하는 과정을 뜻한다.a = [1, 2, 3]    # 리스트 패킹b = (1, 2, 3)    # 튜플 패킹c = 1, 2, 3      # 튜플 패킹",
        "url": "/python-basic7"
    }
    ,
    
    "python-basic6": {
        "title": "Python - Python 문자열 사용하기",
            "author": "AhnSang0915",
            "category": "",
            "content": "Python    Python 기본    Python 숫자 계산하기    Python 변수 만들기    Python 출력 방법    Python 불과 비교, 논리 연산자    Python 문자열 사용하기    Python 리스트와 튜플 사용하기    Python 시퀀스 자료형 활용하기    Python 딕셔너리 사용하기    Python if 조건문으로 특정 조건일 때 코드 실행하기    Python else를 사용하여 두 방향으로 분기하기    Python elif를 사용하여 두 방향으로 분기하기    Python for 반복문    Python while 반복문    Python break, continue로 반복문 제어하기    Python 중첩루프    Python FizzBuzz 문제    Python 터틀 그래픽스로 그림 그리기    Python 리스트와 튜플 응용하기    Python 리스트와 튜플 응용하기 - 2    Python 2차원 리스트 사용하기    Python 문자열 응용하기    Python 딕셔너리 응용하기Python 문자열 사용하기1.문자열 사용하기문자열은 영문 문자열뿐만 아니라 한글 문자열도 사용가능하다. 변수에 문자열을 담아보자.hello = '안녕하세요'파이썬에선 문자열을 작은따옴표, 큰따옴표, 작은따옴표3개, 큰따옴표3개로 묶을 수 있다.hello = '안녕하세요'hello = \"안녕하세요\"hello = '''안녕하세요'''hello = \"\"\"안녕하세요\"\"\"여러 줄로 된 문자열 사용하기여러줄로 된 문자열을 표현하는 방법을 알아보자.hello = \"\"\"안녕하세요파이썬 입니다작성하는 사람은접니다.\"\"\"문자열 안에 작은따옴표나 큰따옴표 포함하기문자열에 작은따옴표나 큰따옴표를 포함하고 싶다면 작은따옴표를 큰따옴표로 감싸주거나 큰따옴표를 작은따옴표로 묵어주면되고 작은따옴표에 작은따옴표를 넣거나 큰따옴표에 큰따옴표를 넣고싶다면 \\를 사용하면 된다.single_quote = '''\"안녕하세요.\"'파이썬'입니다.'''# \"안녕하세요.\"  '파이썬'입니다. double_quote1 = \"\"\"\"Hello\"'Python'\"\"\" #\"Hello\" 'Python'double_quote2 = \"\"\"Hello, 'Python'\"\"\" # Hello, 'Python'a = 'Python isn\\'t difficult'# \"Python isn't difficult\"\\n을 사용하면 여러개의 따옴표를 쓰지 않고도 여러 줄로된 문자열을 사용할 수 있다.print('Hello\\nPython')#결과HelloPython",
        "url": "/python-basic6"
    }
    ,
    
    "python-basic5": {
        "title": "Python - Python 불과 비교, 논리 연산자",
            "author": "AhnSang0915",
            "category": "",
            "content": "Python    Python 기본    Python 숫자 계산하기    Python 변수 만들기    Python 출력 방법    Python 불과 비교, 논리 연산자    Python 문자열 사용하기    Python 리스트와 튜플 사용하기    Python 시퀀스 자료형 활용하기    Python 딕셔너리 사용하기    Python if 조건문으로 특정 조건일 때 코드 실행하기    Python else를 사용하여 두 방향으로 분기하기    Python elif를 사용하여 두 방향으로 분기하기    Python for 반복문    Python while 반복문    Python break, continue로 반복문 제어하기    Python 중첩루프    Python FizzBuzz 문제    Python 터틀 그래픽스로 그림 그리기    Python 리스트와 튜플 응용하기    Python 리스트와 튜플 응용하기 - 2    Python 2차원 리스트 사용하기    Python 문자열 응용하기    Python 딕셔너리 응용하기Python 불과 비교, 논리 연산자1.불과 비교 연산자 사용하기if, while문에서 많이 사용하게되는 논리 연산자와 참(True), 거짓(False)을 나타내는 불리언(boolean)의 사용방법을 알아보자.boolean은 True, False로 표현하며 1, 3.6, ‘Python’처럼 값의 일종이다.비교 연산자의 판단 결과Python에서 비교 연산자와 논리 연산자의 판단 결과로 True, False를 사용한다. 즉, 비교 결과가 맞으면 True, 틀리면 False이다.1&gt;2False1&lt;2True숫자가 같은지 다른지 비교하기두 숫자가 같은지 다른지 비교하는 데에는 ==(equal), !=(not equal)을 사용한다.10==10True10 != 11True문자열이 같은지 다른지 비교하기문자열도 ==와 !=연산자로 비교 할 수 있다. 이때 문자열의 대소문자도 구분해야 한다. 같은 단어여도 대소문자가 다르면 다른 문자열로 판단한다.'Python' == 'Python'True'Python' == 'python'False'Python' != 'python'True부등호 사용하기부등호는 큰지, 작은지, 크거나 작거나 같은지를 판별한다. 기준은 첫번째 값이다.10 &gt; 20    # 10이 20보다 큰지 비교False10 &lt; 20    # 10이 20보다 작은지 비교True10 &gt;= 10    # 10이 10보다 크거나 같은지 비교True10 &lt;= 10    # 10이 10보다 작거나 같은지 비교True객체가 같은지 다른지 비교하기객체가 같은지 다른지 비교할땐 is와 is not을 사용한다. ==, !=는 값 자체를 비교하고 is와 is not은 객체를 비교한다.1과 1.0은 정수와 실수이다. 데이터의 타입은 다르지만 값은 같기때문에 ==는 True가 나온다. 하지만 1과 1.0을 is로 비교해 보면 False가 나온다. 이유는 1은 정수 객체, 1.0은 실수객체이기 때문이다. 객체로서는 다르기 떄문에 is not으로 비교하면 True가 나온다.1 == 1.0True1 is 1.0False1 is not 1.0True정수객체와 실수객체가 서로 다른지 확인하기정수 객체와 실수 객체가 서로 다른지 확인하려면 id함수를 사용한다. id는 객체의 고유한 값(메모리 주소)를 구한다.(이 값은 파이썬을 실행하는 동안에는 계속 유지되며 다시 실행하면 달라진다)id(1)2156471124208id(1.0)2156509782960값 비교에 is를 쓰지 않기값 자체를 비교할때는 ==와 !=를 사용한다. 변수 a가 있는 상태에서 다른 값을 할당하면 메모리 주소가 달라질 수 있기 때문이다. 따라서 다른 객체가 되므로 값이 같더라고 is로 비교하면 False가 나온다. 값을 비교할 때는 is가 아닌 비교 연산자를 사용해야 한다.a = -5a is -5Truea = -6a is -6Falsea == -6True2. 논리 연산자 사용하기논리 연산자는 and, or, not을 사용한다. and는 두값이 모두 True여야 True이다. 하나라도 False이면 False가 나온다.True and True# TrueTrue and False# FalseFalse and True# FalseFalse and False# Falseor는 두 값 중 하나라도 True이면 True, 두값이 모두 False면 False가 된다.True or True#TrueTrue or False# TrueFalse or True# TrueFalse or False# Falsenot은 논리값을 뒤집는다. not True는 False가 되고, not False는 True가 된다. 여기서 and, or, not 논리 연산자가 식 하나에 들어있으면 not, and, or순으로 판단한다.not True and False or not False# False and False or True# False or True# True순서가 헷갈릴 때는 괄호로 판단 순서를 명확히 나타내 주는 것이 좋다.((not True) and False) or (not False)# True논리 연산자와 비교 연산자를 함께 사용하기논리연산자와 비교 연산자를 함께 사용해보자. 이때는 비교 연산자(is, is not, ==, !=, &lt;, &gt;, &lt;=, &gt;=)를 먼저 판단하고 논리 연산자(not, and, or)를 판단하게된다.10 == 10 and 10 != 5    # True and True# True10 &gt; 5 or 10 &lt; 3        # True or False# Truenot 10 &gt; 5              # not True# Falsenot 1 is 1.0            # not False# True정수, 실수, 문자열을 불로 만들기정수, 실수, 문자열을 True, False로 만들어 보자. 정수1은 True 0은 False이다. 문자열의 내용이 ‘False’라도 불로 만들면 Ture가 된다. 문자열의 경우 값이 있으면 True로 나타낸다. 정수0, 0.0이외의 숫자는 모두 True, 빈문자열 ‘’, ““를 제외한 모든 문자열은 True가된다.bool(1)# Truebool(0)# Falsebool(1.5)# Truebool('False')# Truebool('')# Falsebool(\"\")# Falsebool(0)# Falsebool(0.0)# False단락 평가논리 연산에서 중요한 것이 단락 평가(short-circuit evalution)이다. 단락 평가는 첫번째 값만으로 결과가 확실할 때 두 번째 값은 평가하지 않는 방법이다.# 첫 번째 값이 거짓이므로 두 번째 값은 확인하지 않고 거짓으로 결정print(False and True)     # Falseprint(False and False)    # False# 첫 번째 값이 참이므로 두 번째 값은 확인하지 않고 참으로 결정print(True or True)     # Trueprint(True or False)    # TrueTrue and ‘Python’를 확인하면 True가 나올것 같지만 ‘Python’이 나온다. 파이썬에서 논리 연산자는 마지막 단락 평가를 실시한 값을 그대로 반환하기 때문이다. 마지막에 단락평가를 실시한 값이 불이면 불을 반환한다.True and 'Python'# 'Python'True and 'ansang'# 'ansang''Python' and True# True'ansang' and True# True여기서는 문자열 ‘Python’을 True로 쳐서 and 연산자가 두 번째 값까지 확인하므로 두 번째 값이 반환된다.만약 다음과 같이 and 연산자 앞에 False나 False로 치는 값이 와서 첫 번째 값 만으로 결과가 결정나는 경우에는 첫 번째 값이 반환된다.False and 'Python'#False0 and 'Python'    # 0은 False이므로 and 연산자는 두 번째 값을 평가하지 않음#0or 연산자도 마찬가지로 마지막으로 단락 평가를 실시한 값이 반환된다. 다음은 or 연산자에서 첫 번째 값만으로 결과가 결정되므로 첫 번째 값이 반환된다.True or 'Python'# True'Python' or True# 'Python'만약 두번째 값까지 판한해야 한다면 두 번째 값이 반환된다.False or 'Python'# 'Python'0 or False# False",
        "url": "/python-basic5"
    }
    ,
    
    "python-basic4": {
        "title": "Python - Python 출력 방법",
            "author": "AhnSang0915",
            "category": "",
            "content": "Python    Python 기본    Python 숫자 계산하기    Python 변수 만들기    Python 출력 방법    Python 불과 비교, 논리 연산자    Python 문자열 사용하기    Python 리스트와 튜플 사용하기    Python 시퀀스 자료형 활용하기    Python 딕셔너리 사용하기    Python if 조건문으로 특정 조건일 때 코드 실행하기    Python else를 사용하여 두 방향으로 분기하기    Python elif를 사용하여 두 방향으로 분기하기    Python for 반복문    Python while 반복문    Python break, continue로 반복문 제어하기    Python 중첩루프    Python FizzBuzz 문제    Python 터틀 그래픽스로 그림 그리기    Python 리스트와 튜플 응용하기    Python 리스트와 튜플 응용하기 - 2    Python 2차원 리스트 사용하기    Python 문자열 응용하기    Python 딕셔너리 응용하기Python 출력 방법 알아보기1.값을 여러 개 출력하기print 하나로 여러개의 값을 출력하는 방법을 알아보자.print에 변수나 값 여러개를 ,(콤마)로 구분하여 여러개를 넣을 수 있다.print(1, 2, 3)# 1 2 3print('Hello', 'python')# Hello pythona=20b=30c=40print(a,b,c)# 20 30 40sep로 값 사이에 문자 넣기그런데 값 사이에 공백이 아닌 다른 문자를 넣고 싶을 수도 있다. 이때는 다음과 같이 print의 sep에 문자 또는 문자열을 지정해주면 된다.print(1, 2, 3, sep=', ')    # sep에 콤마와 공백을 지정# 1, 2, 3print(4, 5, 6, sep=',')    # sep에 콤마만 지정# 4,5,6print('Hello', 'Python', sep='')    # sep에 빈 문자열을 지정# HelloPythonprint(1920, 1080, sep='x')    # sep에 x를 지정# 1920x10802. 줄바꿈 활용하기출력되는 값을 줄바꿈 해 출력하는 방법을 알아보자. print의 sep에 개행 문자(\\n)라는 특별한 문자를 지정하면 값을 한 줄에 하나씩 출력할 수 있다.print(1, 2, 3, sep='\\n')123print에서도 여러줄로 출력이 가능하다.다음과 같이 문자열 안에 \\n를 넣으면 1 2 3은 세 줄로 출력이 된다.print('1\\n2\\n3')123제어 문자제어 문자는 화면에 출력되지 않지만 출력 결과를 제어한다고해서 제어 문자라고 부른다. 제어 문자는 \\로 시작하는 이스케이프 시퀀스 이다.  \\n: 다음 줄로 이동하며 개행이라고도 부릅니다.  \\t: 탭 문자, 키보드의 Tab 키와 같으며 여러 칸을 띄웁니다.  \\: \\ 문자 자체를 출력할 때는 \\를 두 번 써야 합니다.end 사용하기print는 기본적으로 출력하는 값 끝에 \\n을 붙인다. 그래서 print를 여러 번 사용하면 값이 여러 줄에 출력된다.print(1)print(2)print(3)# 결과123print를 여러 번 사용해서 print(1, 2, 3)처럼 한 줄에 여러 개의 값을 출력할 수 있다. 이때는 print의 end에 빈 문자열을 지정해주면 된다.print(1, end='')    # end에 빈 문자열을 지정하면 다음 번 출력이 바로 뒤에 오게 됨print(2, end='')print(3)#결과123즉, end는 현재 print가 끝난 뒤 그 다음에 오는 print 함수에 영향을 준다. 만약 1 2 3 사이를 띄워주고 싶다면 end에 공백 한 칸을 지정하면 된다.print(1, end=' ')    # end에 공백 한 칸 지정print(2, end=' ')print(3)# 결과1 2 3",
        "url": "/python-basic4"
    }
    ,
    
    "python-basic3": {
        "title": "Python - Python 변수 만들기",
            "author": "AhnSang0915",
            "category": "",
            "content": "Python    Python 기본    Python 숫자 계산하기    Python 변수 만들기    Python 출력 방법    Python 불과 비교, 논리 연산자    Python 문자열 사용하기    Python 리스트와 튜플 사용하기    Python 시퀀스 자료형 활용하기    Python 딕셔너리 사용하기    Python if 조건문으로 특정 조건일 때 코드 실행하기    Python else를 사용하여 두 방향으로 분기하기    Python elif를 사용하여 두 방향으로 분기하기    Python for 반복문    Python while 반복문    Python break, continue로 반복문 제어하기    Python 중첩루프    Python FizzBuzz 문제    Python 터틀 그래픽스로 그림 그리기    Python 리스트와 튜플 응용하기    Python 리스트와 튜플 응용하기 - 2    Python 2차원 리스트 사용하기    Python 문자열 응용하기    Python 딕셔너리 응용하기Python 변수 만들기1.변수와 입력 사용하기변수(variable)을 만들고 결과를 저장하는 방법을 알아보자.변수 만들기x = 100 이라고 입력하면 100이 들어있는 변수 x가 만들어진다. 즉, 변수이름 = 값 형식이다. 이렇게 하면 변수가 생성되는 동시에 값이 할당(저장)된다.  영문 문자와 숫자를 사용할 수 있습니다.  대소문자를 구분합니다.  문자부터 시작해야 하며 숫자부터 시작하면 안 됩니다.  _(밑줄 문자)로 시작할 수 있습니다.  특수 문자(+, -, *, /, $, @, &amp;, % 등)는 사용할 수 없습니다.  파이썬의 키워드(if, for, while, and, or 등)는 사용할 수 없습니다.x = 100y = \"Hello, world\"변수의 자료형 알아내기변수도 마찬가지로 type을 넣어 변수(객체)의 타입이 나온다.type(x)&lt;class 'int'&gt;type(y)&lt;class 'str'&gt;변수 여러 개를 한 번에 만들기변수를 한번에 여러개 만드는 방법은 아래와 같다. 변수이름1, 변수이름2, 변수이름3 = 값1, 값2, 값3 형식으로 변수를 ,(콤마)로 구분한 뒤 각 변수에 할당될 값을 지정해주면 된다. 변수와 값의 갯수는 동일하게 맞춰주어야 한다.x, y, z = 10, 20, 30x# 10y# 20z# 30여러개의 변수를 만들때 값이 같다면 = 같은 값을 지정할수 있다.변수1 = 변수2 = 변수3 = 값 형식으로 변수 여러 개를 =로 연결하고 마지막에 값을 할당해주면 같은 값을 가진 변수 3개가 만들어진다.x = y = z = 20x#20y#20z#20두 변수의 값을 바꿀 수 있다. 변수1, 변수2 = 변수2, 변수1 형식으로 두 변수의 값을 바꿀 수 있다.x, y = 10, 20x, y = y, xx# 20y# 10변수를 삭제하려면 del을 사용하면 되고 확인 해 보면 아래와 같이 찾을수 없다고 나온다.del xxTraceback (most recent call last):  File \"&lt;pyshell#20&gt;\", line 1, in &lt;module&gt;    xNameError: name 'x' is not defined값이 들어있지 않은 빈 변수도 만들 수 있다. 변수 = None형식으로 만든다. 파이썬에서 None은 아무것도 없는 상태를 말하고 다른 언어에서는 null이라고 표현한다.x = Nonex# 아무것도 출력되지 않는다.2.변수로 계산하기계산값을 변수로 지정해 저장하는 방법을 알아보자. 변수 a, b에 숫자를 할당한 뒤에 a와 b의 값을 더해서 변수 c에 할당했다. 이렇게 변수는 변수끼리 계산할 수 있고, 계산 결과를 다른 변수에 할당할 수 있다.a=10b=20c=a+bc30산술 연산 후 할당 연산자 사용하기변수의 값을 증가시키는 방법이다. a의 값에20을 더할뿐 결과를 저장히지는 않는다.a=10a+2030a10변수의 값을 저장하려면 결과를 다시 변수에 저장해야 한다.a = 10a += 20 # a = a + 20a30a를 다시 입력하지 않고 결과를 저장하는 방법이다. +=처럼 산술연신자 앞에 할당연산자(+)를 붙이면 연산 결과를 변수에 저장한다. -=, /=, //=, %=, *=도 사용 가능하다.a=10a=a+20a30할당 연산자를 만들때 주의할 점이다. 변수d를 지정하지 않고 코드를 입력하면 아래와 같은 에러가 나온다. 변수를 지정하고 변수를 사용해 계산을 해야한다.d = d +10Traceback (most recent call last):  File \"&lt;pyshell#57&gt;\", line 1, in &lt;module&gt;    d = d +10NameError: name 'd' is not defined. Did you mean: 'id'?값을 실수로 만들기어떤 값을 강제로 실수로 만드는 방법을 알아보자.float는 부동소수점(floating point)에서 따왔으며 값을 실수로 만들어준다. 즉, 실수는 float 자료형이며 type에 실수를 넣어보면 &lt;class ‘float’&gt;가 나온다.float(1+2)#3.0float('5')# 5.0float(5.3)# 5.3type(3.5)      &lt;class 'float'&gt;계산을 하다보면 부호를 붙여야 할 때도 있다. 이때는 값이나 변수 앞에 양수, 음수 부호를 붙이면 된다.x = -10+x-10-x10복소수파이썬에서는 실수부와 허수부로 이루어진 복소수(complex number)도 사용할 수 있다. 이때 허수부는 숫자 뒤에 j를 붙인다(수학에서는 허수를 i로 표현하지만 공학에서는 j를 사용한다).두 실수를 복소수로 만들 때는 complex를 사용하면 된다.1.2+1.3j# (1.2+1.3j)#두 실수를 복소수로 만들 때complex(1.2, 1.3)# (1.2+1.3j)3.입력 값을 변수에 저장하기매번 다른 값을 변수에 할당하는 방법을 알아보자. input()을 사용하면 사용자가 입력한 값을 가져올 수 있다.input()hello, world!'hello, world!'input()안상현'안상현'함수의 결과를 변수에 할당하기input함수의 결과를 변수에 할당했다.x = input()hello world!x'hello world!'위 코드에서 불편한점은 input함수가 실행된 다음에 아무 내용이 없어서 입력을 받는 상태인지 출력이 없는 상태인지 알 수가 없다는 점이다. 이때는 input의 괄호 안에 문자열을 지정해준다.x = input('문자열을 입력하세요')문자열을 입력하세요우리집 강아지는 보름이x'우리집 강아지는 보름이'위 코드는 사용자에게 입력받는 값의 용도를 미리 알려줄 때 사용한다. 다른 말로는 prompt라고도 부른다.두 숫자의 합 구하기숫자 두개를 입력받은 뒤에 두  숫자의 합을 구해보자. 아래 코드를 실행한 결과는 1020이다. input에서 입력받은 값은 항상 문자열 형태이기 때문이다.a = input('첫 번째 숫자를 입력하세요: ')첫 번째 숫자를 입력하세요: 10b = input('두 번째 숫자를 입력하세요: ')두 번째 숫자를 입력하세요: 20print(a + b)1020변수에 값을 input으로 할당하고 데이터 타입을 확인하면 아래와 같이str(string)이 출력되게 된다.a = input()10type(a)# &lt;class 'str'&gt;입력 값을 정수로 변환하기10 + 20의 결과가 30이 나오게 하려면 input에서 입력받은 문자열을 숫자(정수)로 들어주어야 한다. int로 문자열’10’을 정수 10으로 바꿔준다. 만약 실수를 더하려면 int대신 float를 사용한다.a = int(input('첫 번째 숫자를 입력하세요: '))    # int를 사용하여 입력 값을 정수로 변환b = int(input('두 번째 숫자를 입력하세요: '))    # int를 사용하여 입력 값을 정수로 변환 print(a + b)4. 입력 값을 변수 두 개에 저장하기input 한번에 값을 여러 개 입력받는 방법을 알아보자. input에서 split을 사용하여 변수 여러 개에 저장해주면 된다. 공백으로 변수 a와 b의 값을 구분짓는다.a, b = input('문자열 두 개를 입력하세요: ').split()문자열 두 개를 입력하세요: an sangprint(a)anprint(b)sang두 숫자의 합 구하기두 숫자의 합을 구해보는 예제이다. 전 항목에서와 마찬가지로 input으로 입력받은 값은 문자열 이기 때문에 합의 값이 1020이 나온다.a, b = input('숫자 두개를 입력하세요: ').split()숫자 두개를 입력하세요: 10 20print(a + b)1020입력 값을 정수로 변환하기a = int(a)와 같이 int에 변수를 넣은 뒤 다시 변수에 저장해주면 변수가 정수 자료형으로 변환된다.a = int(a)b = int(b)print(a + b)30print안에서 int로 바꾸어 정수값을 얻는 방법도 있다.print(int(a) + int(b))# 30map을 사용하여 정수로 변환하기 map에 int와 input().split()을 넣으면 int로 변환하지 않아도 split의 결과를 모두 int로 변환해준다(실수로 변환할 때는 int 대신 float를 넣는다.).a, b = map(int, input('숫자 두 개를 입력하세요: ').split())숫자 두 개를 입력하세요: 10 20print(a + b)30### 입력받는 값을 콤마를 기준으로 분리하기split에 기준 문자열을 지정하여 공백이 아닌 다른 문자로 값을 분리해 보자.a, b = map(int, input('숫자 두 개를 입력하세요: ').split(','))숫자 두 개를 입력하세요: 10,20print(a + b)30",
        "url": "/python-basic3"
    }
    ,
    
    "python-basic2": {
        "title": "Python - Python 숫자 계산하기",
            "author": "AhnSang0915",
            "category": "",
            "content": "Python    Python 기본    Python 숫자 계산하기    Python 변수 만들기    Python 출력 방법    Python 불과 비교, 논리 연산자    Python 문자열 사용하기    Python 리스트와 튜플 사용하기    Python 시퀀스 자료형 활용하기    Python 딕셔너리 사용하기    Python if 조건문으로 특정 조건일 때 코드 실행하기    Python else를 사용하여 두 방향으로 분기하기    Python elif를 사용하여 두 방향으로 분기하기    Python for 반복문    Python while 반복문    Python break, continue로 반복문 제어하기    Python 중첩루프    Python FizzBuzz 문제    Python 터틀 그래픽스로 그림 그리기    Python 리스트와 튜플 응용하기    Python 리스트와 튜플 응용하기 - 2    Python 2차원 리스트 사용하기    Python 문자열 응용하기    Python 딕셔너리 응용하기Python 숫자 계산하기1.정수 계산하기파이썬은 파이썬 셸을 통하여 입력한 코드의 결과를 즉스 출력할수 있었다. 파이썬의 숫자의 타입은 정수, 실수, 복소수가 있다. 정수는 말그대로 123같은 숫자를 나타내고 실수는 소수점이 있는 숫자, 복소수는 제곱을 할때 -가 나오는 수를 말한다. 정수는 int, 실수는 float, 복소수는 complex라고 한다.사칙연산사칙연산은 +,-,*(곱하기),/(나누기)를 사용할 수 있다.1+1# 21-1# 01-2# -12*2# 45/2# 2.54/2# 2.0연산자 // (버림 나눗셈)나눗셈후 소수점 이하를 버리는 연산자는 //이다. 정수로 계산을하면 정수로 테이터를 얻을수 있다. 하지만 실수로 계산하면 실수로 나오고 소수점 이하는 버리게되어 .0으로 나오게된다.5 // 2#24 // 2# 25.5 // 2# 2.04 // 2.0# 2.04.1 // 2.1# 1.0연산자 % (나머지를 구하는 연산자)%로 나누기를 하게되면 나머지 값을 구할 수 있다.5 % 2# 1연산자 ** (거듭제곱을 구하는 연산자)**를 사용해 거듭 제곱을 할 수 있다.2**3# 82**10# 1024값을 정수로 만들기계산결과가 실수로 나왔을때 강제로 정수로 만들 수 있다. int뒤에 괄호를 붙이고 숫자 또는 계산식을 넣어주면 된다. int뒤에 문자열을 넣어도 정수로 만들 수 있다. 하지만 정수로된 문자열만 가능하다. 실수 문자열을 넣어주면 아래와 같은 문법오류가 나온다.int(5.20)#5int('10.3')# Traceback (most recent call last):#   File \"&lt;pyshell#14&gt;\", line 1, in &lt;module&gt;#     int('10.3')# ValueError: invalid literal for int() with base 10: '10.3'int(-8.3)#-8객체의 자료형 알아내기객체의 타입을 알아내는 함수는 type이고 ()에 타입을 확인하고 싶은 데이터를 넣는다. &lt;class ‘int’&gt;라고 하는것은 정수라는 이야기고 class는 python에서 객체를 나타내는 표현법이다. 정수로 만드는 방법인 int()의 경우 ()안의 데이터를 int클래스로 된 객체로 만들겠다는 말이다.type(10)      # &lt;class 'int'&gt;몫과 나머지를 함께 구하기몫과 나머지를 함께 구하려면 diwmod를 사용한다.divmod(5, 2)      # (2, 1) 데이터를 괄호로 묶은 형태를 튜플(tuple)이라고 한다.a, b = divmod(5, 2)      print(a, b)      2 12진수, 8진수, 16진수정수는 10진수 이외에도 2진수, 8진수, 16진수로도 표현할 수 있다.      2진수: 숫자 앞에 0b를 붙이며 0과 1을 사용한다.        8진수: 숫자 앞에 0o(숫자 0과 소문자 o)를 붙이며 0부터 7까지 사용한다.        16진수: 숫자 앞에 0x 또는 0X를 붙이며 0부터 9, A부터 F까지 사용한다(소문자 a부터 f도 가능).  0b110# 60o10# 80xF# 152.실수 계산하기소수점이 붙은 것을 실수라한다. 실수의 계산을 알아보자.아래 뺄셈의 경우 다소 어려운 주제이다. 실무에서 실수를 다룰때는 적절한 처리가 필요하다.3.5+2.1# 5.64.3-2.7# 1.59999999999999961.5*3.1# 4.655.5/3.1# 1.7741935483870968실수와 정수를 함께 계산실수와 정수를 함께 계산할 경우 표현 범위가 넓은 실수로 출력된다.4.2+5# 9.2값을 실수로 만들기어떤 값을 강제로 실수로 만드는 방법을 알아보자.float는 부동소수점(floating point)에서 따왔으며 값을 실수로 만들어준다. 즉, 실수는 float 자료형이며 type에 실수를 넣어보면 &lt;class ‘float’&gt;가 나온다.float(1+2)#3.0float('5')# 5.0float(5.3)# 5.3type(3.5)      &lt;class 'float'&gt;복소수파이썬에서는 실수부와 허수부로 이루어진 복소수(complex number)도 사용할 수 있다. 이때 허수부는 숫자 뒤에 j를 붙인다(수학에서는 허수를 i로 표현하지만 공학에서는 j를 사용한다).두 실수를 복소수로 만들 때는 complex를 사용하면 된다.1.2+1.3j# (1.2+1.3j)#두 실수를 복소수로 만들 때complex(1.2, 1.3)# (1.2+1.3j)3.괄호 사용하기곱셈보다 덧셈을 먼저 계산하고 싶다면 괄호로 묶어준다.7 + (10 - 5) * 2# 17",
        "url": "/python-basic2"
    }
    ,
    
    "practice-1": {
        "title": "연습문제 - 나도코딩 예제",
            "author": "AhnSang0915",
            "category": "",
            "content": "Python 연습문제나도코딩 예제예) http://naver.com규칙 1 : http://부분을 제외 규칙 2 : 처음 만나는 점(.) 이후 부분은 제외규칙 3 : 남은 글자 중 처음 세자리 + 글자 갯수 + 글자 내 “e” 갯수 + “!” 로 구성예) 생성된 비밀번호 : nav51!아래 문제의 포인트는 url주소가 naver가 아니더라도 출력이 잘 되야 하는것이다.#내가 푼 답안url = \"http://naver.com\"first = url[7 : url.index(\".\")]first1 = first[:3]len = len(first)e = first.count(\"e\")print(f\"생성된 비밀번호 : {first1}{len}{e}%s\" %\"!\")# 선생님답안url = \"http://naver.com\"rule1 = url.replace(\"http://\", \"\")rule1 = rule1[:rule1.index(\".\")]password = rule1[:3] + str(len(rule1)) + str(rule1.count(\"e\"))+\"!\"print(\"{}의 비밀번호는 {} 입니다.\".format(url, password))",
        "url": "/practice-1"
    }
    ,
    
    "python-basic": {
        "title": "Python - Python 기본",
            "author": "AhnSang0915",
            "category": "",
            "content": "Python    Python 기본    Python 숫자 계산하기    Python 변수 만들기    Python 출력 방법    Python 불과 비교, 논리 연산자    Python 문자열 사용하기    Python 리스트와 튜플 사용하기    Python 시퀀스 자료형 활용하기    Python 딕셔너리 사용하기    Python if 조건문으로 특정 조건일 때 코드 실행하기    Python else를 사용하여 두 방향으로 분기하기    Python elif를 사용하여 두 방향으로 분기하기    Python for 반복문    Python while 반복문    Python break, continue로 반복문 제어하기    Python 중첩루프    Python FizzBuzz 문제    Python 터틀 그래픽스로 그림 그리기    Python 리스트와 튜플 응용하기    Python 리스트와 튜플 응용하기 - 2    Python 2차원 리스트 사용하기    Python 문자열 응용하기    Python 딕셔너리 응용하기Python 기본Python은 세미콜론(;)을 안붙여도 된다.파이썬은 세미콜론이 없어도 된다. 세미콜론을 붙여도 문법적 오류가 발생하지 않는다. 하지만 필요없는 내용을 코드에 작성할 필요는 없을것 같다.Python의 주석파이썬에서 사람만 알아볼 수 있도록 작성하는 부분을 주석(comment)라고 한다. 즉, 주석은 파이썬 인터프리터가 처리하지 않으므로 프로그램의 실행에는 영향을 주지 않는다. 아래는 파이썬의 주석처리 방법이다.한줄 주석의 경우 주석의 내용 앞에 #를 붙여준다. 일반적으로 #뒤에 한칸을 띄어쓰기하고 사용한다.# print(\"파이썬 공부하자\")파이썬의 여러줄 주석은 ‘'’이나 “\"”을 앞뒤로 붙여주면 된다.'''print(\"파이썬 공부하자\")print(\"파이썬 공부하자\")print(\"파이썬 공부하자\")'''\"\"\"print(\"파이썬 공부하자\")print(\"파이썬 공부하자\")print(\"파이썬 공부하자\")\"\"\"들여쓰기들여쓰기란 코드의 가독성을 높이기 위해 일정한 간격을 띄워서 작성하는 방법이다. 파이썬은 들여쓰기가 문법으로 되어있어 들여쓰기를 하지 않으면 문법 오류가 나오게 된다.if a == 10:print('10입니다.')    # 들여쓰기 문법 에러#IndentationError: expected an indented blockif a == 10:   print('10입니다.')  코드블록특정한 동작을 위해 코드가 모여있는 상태를 코드블록 이라고 한다. 주의할 점은 같은 블록은 들여쓰기 칸수가 같아야고 공백과 tap을 같이 사용하면 안된다.if a == 10:      print('10')      print('입니다.')",
        "url": "/python-basic"
    }
    ,
    
    "javascript-basic25": {
        "title": "Javascript - JavaScript 객체지향 - 참조",
            "author": "AhnSang0915",
            "category": "",
            "content": "Javascript    JavaScript 기본     JavaScript 숫자와 문자     JavaScript 변수, 비교    JavaScript 조건문    JavaScript 반복문    JavaScript 함수    JavaScript 배열    JavaScript 객체(Object)    JavaScript 모듈    JavaScript UI와 API    JavaScript 정규표현식    JavaScript 함수지향 - 유효범위    JavaScript 함수지향 - 값으로서의 함수와 콜백    JavaScript 함수지향 - 클로저    JavaScript 함수지향 - arguments    함수지향 - 함수의 호출    객체지향 - 객체지향 프로그래밍 소개    객체지향 - 생성자와 new    객체지향 - 전역객체    객체지향 - this    객체지향 - 상속    객체지향-표준 내장객체의 확장    JavaScript 객체지향-ObjectJavaScript 객체지향 - 참조1. 복제란?바로 이러한 특징이 소프트웨어를 기존의 산업과 구분하는 가장 큰 특징일 것이다. 프로그래밍에서 복제가 무엇인가를 살펴보자.아래 코드의 결과는 1이다. 2행에서 var b = a; 3행에서 b = 2;기떄문에 2가 아닌가 생각할 수 있지만 그렇지 않다. a와 b는 각각다른 데이터를 갖고있기 때문에 a의 값에는 영향을 주지 않는다. 두 변수는 연결되어 있지 않은 별도의 데이터이다.var a = 1;var b = a;b = 2;console.log(a); //12. 참조객체는 어떻게 동작하는지 알아보자. b = a;라고 했고 b에는 {‘id’:1};이런 값이 들어가게 될것이다. 그상태 에서 b.id로 b의 id값을 2로바꿨다. 그리고 a의 id값을 체크하면 값이 2가된다. 이말은 b의 프로퍼티 값을 변경하면 a의 프로퍼티 값이 변경 된다는 것이다.var a = {'id':1}; //a라는 변수에 di가 1인 객체를 지정var b = a;b.id = 2;console.log(a.id);  // 2아래의 예제는 1을 출력한다. b = {‘id’ : 2};로 새로운 객체를만들어 변수b에 할당을 한것이다. 그렇기 때문에 b라는 변수는 더이상 {‘id’:1};를 의미하지 않고 새롭게 만들어진 {‘id’ : 2};를 의미하게 되는 것이다.var a = {'id':1}; var b = a;b = {'id' : 2};  //객체를 생성한것이다.console.log(a.id); //1//사실상 아래의 코드와 같다.var a = 1;var b = a;b = 2;console.log(a); //1변수에 담겨진 값이 객체인경우 b = a;라고 했을때 b와 a는 똑같은 객체를 바라보게된다. 하지만 데이터가 원시 데이터 타입인 경우 b = a;라고하면 이순간에 a에 담겨있던 값이 복제되어 새로만들어지고 그값이 b에 담겨지게 되는것이다. 즉 참조건 복제건 상관없이, 원시데이터이건 객체건 상관없이 새로운 데이터를 만들어서 그것을 변수에 할당하면 새로운 데이터의 값을 바라보게 되지만 지만 객체는 b = a; 라고 했을 때 객체는 똑같은 객체를 각각의 변수들이 바라보게 되는것이고 원시데이터에서 b = a;라고 했을땐 a가 바라보던 값을 b가 만들어졌을땐 복제한 별개의 값을 바라보게 되는것이다.3. 함수와 참조그럼 일종의 변수할당이라고 할 수 있는 메소드의 매개변수는 어떻게 동작하는가를 살펴보자. 조금 복잡하므로 꼼꼼하게 살펴봐야 한다. 예제를 보자.다음은 원시 데이터 타입을 인자로 넘겼을 때의 동작 모습이다. a에 1이라는 값이 담겨있다. 그리고 함수를 정의했는데 매개변수(parameter)인 b의값을 2로 바꾸고있다. 그리고 함수를 호출할때 a를 전달했다. 이말은 b = a;라는 것과 같다. a=1인상태이고 b=a;, 그리고 b=2; 인것이다. 여기서 a=1이고 함수가 b = a;라는 의미이기 때문에 복제와 같다. a=1의 값이 함수 b에 들어가지만 함수내의 b=2;로 b=2가되고 개별의 데이터인 a는 그대로 1이되게 된다.var a = 1;function func(b){ // b = a; 라는것이다.    b = 2;}func(a);console.log(a);이번에는 변수에 담긴 값이 객체이다. a = {‘id’:1};이고 위 함수와 마찬가지로 b = a;를 의미하고 a는 객체이기 때문에 b와 a는 똑같은 객체를 바라보고 있는 상황이지만 b = {‘id’:2};가 새로운 객체를 만들었고 b에 새로운 객체를 할당했기 때문에 b는 {‘id’:2};를 바라보고 있다. 그렇기 때문에 b와 a가 같은 객체를 바라보지 않게 되는것이다. 따라서 결과는 1이다.var a = {'id':1};function func(b){    b = {'id':2};}func(a);console.log(a.id);  // 1아래는 결과가 다르다. 아래도 마찬가지로 b = a;를 함수로 나타내고 있지만 b.id = 2;로 b와a는 데이터가 객체이기 때문에 같은 객체를 바라보고 있다. b.id = 2;로 a의 값도 바뀌기 때문에 결과는 2가된다.var a = {'id':1};function func(b){    b.id = 2;}func(a);console.log(a.id);  // 2",
        "url": "/javascript-basic25"
    }
    ,
    
    "javascript-basic24": {
        "title": "Javascript - JavaScript 객체지향 - 데이터타입",
            "author": "AhnSang0915",
            "category": "",
            "content": "Javascript    JavaScript 기본     JavaScript 숫자와 문자     JavaScript 변수, 비교    JavaScript 조건문    JavaScript 반복문    JavaScript 함수    JavaScript 배열    JavaScript 객체(Object)    JavaScript 모듈    JavaScript UI와 API    JavaScript 정규표현식    JavaScript 함수지향 - 유효범위    JavaScript 함수지향 - 값으로서의 함수와 콜백    JavaScript 함수지향 - 클로저    JavaScript 함수지향 - arguments    함수지향 - 함수의 호출    객체지향 - 객체지향 프로그래밍 소개    객체지향 - 생성자와 new    객체지향 - 전역객체    객체지향 - this    객체지향 - 상속    객체지향-표준 내장객체의 확장    JavaScript 객체지향-ObjectJavaScript 객체지향-테이터 타입1. 원시 데이터 타입과 객체데이터 타입은 크게 2가지로 구분할 수 있다. 원시 데이터 타입과 객체 데이터 타입이다. 원식 데이터 타입은 기본데이터 타입이라고도 하고 객체 데이터 타입은 참조 데이터 타입이라고도 한다. 객체가 아닌 데이터 타입을 원시 테이터 타입이라고 하고 아래와같다.  숫자  문자열  boolean(true/false)  null  nudefined위 항목의 데이터 타입을 원시 데이터 타입 이라고 하고 이외의 모든 데이터 타입을 객체 데이터 타입이라고 한다.2. 래퍼 객체위와 같은 데이터 타입을 분류하는게 중요한것은 아니고 개발자 입장에서 이러한것이 효용을 갖기 위해서는 원시데이터 타입과 객체가 서로 다르게 동작할 때에 효용이 있는것 이다.아래 코드는 문자열을 변수에 담았다. 문자열의 길이와 문자열의 첫번째 값을 출력한다. 객체가 아닌것은 원시데이터 타입이다. 문자열은 원시데이터 타입인데 아래 console.log를보면 객체처럼 동작하고 있다. 이 .의 정식 명칭은 Object access operator이고 객체접근 연산자 라는 뜻이다. 이 .을썻다는것은 .앞에있는 것이 객체라는 것을 의미한다. 객체이기 때문에 length프로퍼티와 charAt(0)메소드가 존재하는것이다. 이말은 str에 담겨있는 무엇인가가 객체이고 문자열은 객체라는 것이다. Javascript에서 문자열이 원시데이터가 맞긴한데 그문자열을 우리가 제어하기 위해서, 여기서는 문자열의 길이와 첫번째 값을 구하기 위해서는 원시데이터 타입인 문자열이 마치 객체인 것 처럼 동작 해야지만 이런 작업을 할 수 있다. 그런 이유로 인해서 Javascript에서 문자열과 같은 원시데이터 타입은 그것을 객체로서 사용할때 그것을 임시로 객체데이터 타입으로 만들어준다. 우리가 str.length를 할때 그순간에 내부적으로 str = new String(‘coding’); 이라고하는 객체를 생성해 str변수에 담아준것과 같은 작업이 1행과 2행 사이에 생긴다고 보면 된다.var str = 'coding';console.log(str.length);        // 6console.log(str.charAt(0));     // \"C\"‘coding’이라는 문자열을 str변수에 담았고 str.prop로 prop라는 프로퍼티를 지정했다. 거기에 ‘everybody’라는 텍스트를 넣었다. console.log(str.prop);로 출력을 하려고하면 undefined가 출력된다. 이말은 우리가 우리가 str.prop = ‘everybody’를통해 문자열을 객체화 시킨후 그 다음행으로 문제없이 넘어갈 수 있게 되는데 이순간엔 객체가 만들어졌지만 끝난후에 그 객체를 제거하고 원래의 원시 데이터 타입으로 변경했기 때문에 prop라는 값이 존재하지 않는것이다.var str = 'coding';str.prop = 'everybody';console.log(str.prop);      // undefined원시 데이터 타입은 객체처럼 사용하려고 할때 자동으로 만들어지는 객체를 래퍼객체(Wrapper Object)라고 한다. 원시 데이터 타입이 있을 때 그 원시 데이터 타입을 감싸주는 객체가 만들어져 객체화 시켜주는게 래퍼객체이다.  숫자 (Number)  문자열 (String)  boolean(true/false) (Boolean)  null X  nudefined Xnull과 nudefined은 래퍼객체가 존재하지 않는다. 객체화 시키려고 하면 타입에러가 발생할 것이다.",
        "url": "/javascript-basic24"
    }
    ,
    
    "javascript-basic23": {
        "title": "Javascript - JavaScript 객체지향-Object",
            "author": "AhnSang0915",
            "category": "",
            "content": "Javascript    JavaScript 기본     JavaScript 숫자와 문자     JavaScript 변수, 비교    JavaScript 조건문    JavaScript 반복문    JavaScript 함수    JavaScript 배열    JavaScript 객체(Object)    JavaScript 모듈    JavaScript UI와 API    JavaScript 정규표현식    JavaScript 함수지향 - 유효범위    JavaScript 함수지향 - 값으로서의 함수와 콜백    JavaScript 함수지향 - 클로저    JavaScript 함수지향 - arguments    함수지향 - 함수의 호출    객체지향 - 객체지향 프로그래밍 소개    객체지향 - 생성자와 new    객체지향 - 전역객체    객체지향 - this    객체지향 - 상속    객체지향-표준 내장객체의 확장    JavaScript 객체지향-ObjectJavaScript 객체지향-Object1. Object란?Object객체는 객체의 가장 기본적인 형태를 가지고 있는 객체이다. 다시 말해서 아무것도 상속받지 않는 순수한 객체다. Javascript에서는 값을 지정하는 기본적인 단위로 Object를 사용한다. var grades = {'egoing': 10, 'k8805': 6, 'sorialgi': 80};우리는 이전에 property에대해 배울 때 Ultra, Super, Sub라는 생성자 예제를 통해 상속에대해 알아보았다. Sub는 Super를 Super는 Ultra를 상속받았다. Ultra는 최상위에 있는것처럼 보이지만 암시적으로는 사실 Object라는 객체에 상속되어 있는것이다. Object라는 객체의 프로퍼티는 모든 객체가 갖고있는 프로퍼티가 되는것이다. 즉 Object의 prototype은 모든객체가 사용할 수 있는 prototype이 된다는 것이다. 우리가 모든 객체가 가지고 있었으면 하는 기능이 있다면 Object의 prototype에 우리가 직접 기능을 추가하는 것을 통해서 모든객체가 그기능을 갖게 할 수 있다는 것이다.2. Object API사용법Object.keys는 배열이 어떠한 인덱스값을 가지고 있는지 배열로 리턴하는 메소드이다. 따라서 첫번째 결과는 Object.keys(arr)[‘0’, ‘1’, ‘2’] 이된다. toString은 문자열을 리턴해준다고 생각하자. 중요한 것은 Object.keys()와 Object.prototype.toString()에서 prototype이 있고 없고의 차이가 뭔지 알아야한다. prototype이 있는 것은 어떠한 객체를 만든다. 그리고 그객체를 담고있는 식별자. toString이라고 한다. 그런데 prototype이 없는 Object.keys같은 경우에는 Object.keys(arr)처럼 어떠한 인자를 받아서 처리한다. 이러한 차이는 Object라고 하는 것이 생성자 함수인 것이다. 함수는 javascript에서 객체이기 때문에 프로퍼티를 가질수 있다. 그래서 Object.keys가 가능한 것이고 이렇게 정의되었을 것이다 Object.keys = function(){}. toString의 경우는 prototype의 프로퍼티이다. 즉 Object.prototype.toString = function(){} 로 정의되어 있다. 어떠한 메소드가 new Object를 실행을 시키는 순간에 어떠한 객체를 만들고 그객체는 prototype이라고 하는 특수한 프로퍼티에 저장되어있는 객체를 원형으로 하는 객체가 생성이 되는것이다. 그렇게 생성된 객체는 toString이라는 메소드를 사용할 수 있기 때문에 메소드로서 사용하게 되는것이다.//Object.keys()var arr = [\"a\", \"b\", \"c\"];console.log('Object.keys(arr)',Object.keys(arr));//Object.prototype.toString()var o = new Object();console.log('o.toString()',o.toString());var a = new Array(1,2,3);console.log('a.toString()'),a.toString());3. Object 확장우리가 필요한 기능을 모든 객체에서 사용 가능한 Object를 만드는 방법을 알아보자.아래 배열과 객체에서 contain.(인자)메소드로 어떤 인자를 전달하게되면 인자가 해당 되는 값이 그 객체나 배열에 있다면 true 없다면 false를 리턴하게하는 코드를 만들어 보았다. 모든 객체의 부모는 Object이기 때문에 Object라고 적어주고, o와a모두 객체이다. 객체에 어떤 기능, 메소드를 갖도록 추가하고 싶다면 prototype이라고하는 프로퍼티안의 객체를 변경하면 된다. for in문으로 배열과 객체를 차례로 나열하여 값을 확인하는 코드를 작성했다. 아래 코드에서 메소드 안의 this는 그 메소드가 소속되어있는 객체를 의미한다. name에는 각각의 객체에대한 키값이 담기게 된다. 현재 열거되고 있는 value값을 가져오려면 this[name]으로 가져오고 그값과 neddle을 비교하여 두 값이 일치하면 true를 리턴한다. 마지막 value까지 나열했는데 일치하는 값이 없다면 false를 리턴한다.Object.prototype.contain = function(neddle) {    for(var name in this){        if(this[name] === neddle){            return true;        }    }    return false;}var o = {'name' : 'ansang', 'city' : 'suwon'}console.log(o.contain('ansang'));var a = ['ansang', 'sang', 'hyun'];console.log(a.contain('sang'));4. Object 확장의 위험확장의 위험성에 대해 알아보자. 확장을 함으로써 모든 객체에 영향을 주기때문에 주의해야한다.크롬 개발자 도구에서 아래 코드를입력후 for(var name in o){console.log(o[name]);}을 출력한 결과를 보자. 함수까지 출력된 상황이다. 이유는 contain이 포함되었기 때문이다. 개발자 도구에서 다시 코드를 작성해보자. for(var name in o){console.log(name)}의 결과는 name, city, contian이다.for(var name in a){console.log(name)}의 실행결과 역시 0,1,2,contain이다.Object.prototype.contain = function(neddle) {    for(var name in this){        if(this[name] === neddle){            return true;        }    }    return false;}var o = {'name' : 'ansang', 'city' : 'suwon'}console.log(o.contain('ansang'));var a = ['ansang', 'sang', 'hyun'];console.log(a.contain('sang'));// 개발자 도구에서 for(var name in o){console.log(name)}을 출력한 결과for(var name in o){    console.log(o[name]);}VM693:2 ansangVM693:2 suwonVM693:2 ƒ (neddle) {    for(var name in this){        if(this[name] === neddle){            return true;        }    }    return false;}// 개발자 도구에서 for(var name in a){console.log(name);}을 출력한 결과12contain부모로 부터 contain이라는 프로퍼티까지 상속받았기 때문에 위와같은 결과가 나오는 것이다. 그렇다면 이런 문제를 해결할수 있는 메소드를 알아보자. a.hasOwnProperty(name)는 실행되는 객체가 인자로 전달된 값을 자신의 프로퍼티로 가지고 있는지 확인할 수 있는 메소드이다. contain은 부모로부터 상속받은 프로퍼티이기 때문에 어떠한 프로퍼티의 이름이 그객체의 직접적으로 정의되어있는지 확인하는 기능인 hasOwnProperty로 구별할 수 있다.Object.prototype.contain = function(neddle) {    for(var name in this){        if(this[name] === neddle){            return true;        }    }    return false;}var o = {'name' : 'ansang', 'city' : 'suwon'}var a = ['ansang', 'sang', 'hyun'];for(var name in o){    if(o.hasOwnProperty(name)){        console.log(name)    }}//name, cityfor(var name in a){    if(a.hasOwnProperty(name)){        console.log(name)    }}//0,1,25. prototype vs proto이번엔 prototype과 _proto__의 관계를 알아보자. 그전에 함수란 무엇인가를 확인해 보면. 함수는 javascript에서는 객체이다. function Person(){}는 var Person = new Function();으로 표현할수 있다. javascript에서 함수는 객체이기 때문에 프로퍼티를 가질 수 있다. 아래와 같은 함수를정의하면 객체이기 때문에 함수에 해당되는 Person이라고하는 객체가 생성되고 Person의 prototype이라는 객체가 하나 더 생긴다. 두개의 객체는 서로 연관되어 있기 때문에 Person이라고하는 객체는 내부적으로 prototype이라는 프로퍼티가 생기고 그 프로퍼티는 Person의 prototype객체를 의미한다. 그래서  Pserson.prototype이라 함은 Person의 prototype객체를 의미한다. Person의 prototype객체도 자신이 Person의 소속인것을 표시하기 위해서 어딘가에 기록해야한다. 그러기 위해서 Person의 prototype객체 안에 constructor라고하는 프로퍼티를 만들고 이 프로퍼티는 Person을 가르키게 된다. 서로간의 상호참조를 하고있는 것이다. Person은 prototype프로퍼티를 통해서 Person의 prototype객체를 가르키고 Person의 prototype객체는 constructor프로퍼티를 통해서 Person객체를 가르킨다는 것이다. 그다음person.prototype.sum = function(){} 를정의하게 되면 Person의 prototype객체에 sum이라는 함수가 없기때문에 생성하고 함수를 정의한다. var kim=new Person(‘kim’,10,20) 이렇게 객체를 생성하면 kim이라고하는 객체가 생성되고 kim이라는 객체 안에 프로퍼티 값으로 name,first,second 그리고 __proto__가 생성이 된다. kim객체의 __proto_ 프로퍼티는 Person의 prototype객체를 의미한다. 그렇다면 Person.prototype을통해서 Person의 prototype객체에 접근할 수 있고, kim.__proto__를 통해서도 접근 할 수 있다. var lee = new Person(‘lee’,10,10)를 통해서도 같은 접근을 할 수 있다. console.log(kim.name)을하면 name이라는 프로퍼티가 있는지를 확인하고 그값을 출력할 것이다. 만약 name이라는 값이 없다면 __proto__가 가르키는 객체에 name이 있는지 다시 찾아본다. kim.sum()을 하게 되면 kim이라는 객체에는 sum이라는 메소드가 없다. 그렇다면 javascript는 __proto__가 가르키는 Person의 prototype객체에 sum이 있는지 찾는다. 이런식으로 prototype이 동작하는 것이다.function Person(name, first, second){    this.name = name;    this.first = first;    this.second = second;}person.prototype.sum = function(){}var kim = new Person('kim',10,20)var lee = new Person('lee',10,10)console.log(kim.name)kim.sum()",
        "url": "/javascript-basic23"
    }
    ,
    
    "javascript-basic22": {
        "title": "Javascript - JavaScript 객체지향-표준 내장객체의 확장",
            "author": "AhnSang0915",
            "category": "",
            "content": "Javascript    JavaScript 기본     JavaScript 숫자와 문자     JavaScript 변수, 비교    JavaScript 조건문    JavaScript 반복문    JavaScript 함수    JavaScript 배열    JavaScript 객체(Object)    JavaScript 모듈    JavaScript UI와 API    JavaScript 정규표현식    JavaScript 함수지향 - 유효범위    JavaScript 함수지향 - 값으로서의 함수와 콜백    JavaScript 함수지향 - 클로저    JavaScript 함수지향 - arguments    함수지향 - 함수의 호출    객체지향 - 객체지향 프로그래밍 소개    객체지향 - 생성자와 new    객체지향 - 전역객체    객체지향 - this    객체지향 - 상속    객체지향-표준 내장객체의 확장    JavaScript 객체지향-ObjectJavaScript 객체지향-표준 내장객체의 확장1. 표준 내장 객체란?표준 내장 객체(Standard Built-in Object)는 자바스크립트가 기본적으로 가지고 있는 객체들을 의미한다. 내장 객체가 중요한 이유는 프로그래밍을 하는데 기본적으로 필요한 도구들이기 때문에다. 결국 프그래밍이라는 것은 언어와 호스트 환경에 제공하는 기능들을 통해서 새로운 소프트웨어를 만들어내는 것이기 때문에 내장 객체에 대한 이해는 프로그래밍의 기본이라고 할 수 있다. 자바스크립트의 표준 내장객체는 아래와 같다.  Object  Function  Array  String  Boolean  Number  Math  Date  RegExp2. 배열의 확장 1내장객체에 우리가 원하는 기능을 추가하는 방법을 알아보자. 아래 예제는 도시이름이 랜덤하게 값으로 반환되는 코드이다. Math.random함수는 0에서 1사이의 난수(난수란 무작위로 만들어진 수열을 가리킨다. 여기서 무작위란 다음에 나올 수를 절대 예측할 수 없다는 것을 뜻한다.)를 반환하는 함수이다.arr.length * Math.random()은 소수값이 포함되어 있기 때문에 index값을 불러올 수 없다. 그렇기 때문에 Math가 가진 API중에 Math.floor을 사용해 정수로 만들어 줘야한다. Math.floor는 소수점을 없애주는 역할을 한다. 예를들어 0.1은 0, 5.2는 5로 바꿔주는 역할을 한다. 그렇게 하고 우리가 랜덤하게 배열의 인덱스값을 배열에 전달할 수 있게 return arr[index];}를 해준다.var arr = new Array('seoul','new york','ladarkh','pusan', 'Tsukuba');function getRandomValueFromArray(arr){    var index = Math.floor(arr.length * Math.random());    return arr[index];}console.log(getRandomValueFromArray(arr))3. 배열의 확장 2이번엔 Array생성자를 확장해서 모든 배열이 그 배열이 갖고있는 값 중에 어떤 특정한 값을 랜덤하게 획득할 수 있는 기능을 모든 배열의 객체가 획득할 수 있도록 코드를 변경해 보자.  new Array로 새로운 배열을 만들어 낼때 Array.prototype.random = function() { }라는 생성자 함수가 실행이 될것이다. 그생성자가 가지고있는 prototype이라는 프로퍼티 안에 있는 객체가 만들어지는 그 객체의 원형이 되기 떄문에 random이라는 것을 추가한는 것을 통해서 배열객체가 만들어지는 원형, 배열객체의 원형에 random이라는 메소드를 추가하게 되는것이다. 프로토타입을 추가하는걸 통해서 배열 생성자를 통해서 만들어진 객체가 random이라는 메소드를 가지고 있다. random이라는 메소드 안에서 this는 배열객체 자체를 의미한다./*var arr = new Array('seoul','new york','ladarkh','pusan', 'Tsukuba');function getRandomValueFromArray(arr){    var index = Math.floor(arr.length * Math.random());    return arr[index];}console.log(getRandomValueFromArray(arr))*/Array.prototype.random = function() { //배열을 만들기 위한 생성자함수    var index = Math.floor(this.length * Math.random());    return this[index];}var arr = new Array('seoul','new york','ladarkh','pusan', 'Tsukuba');console.log(arr.random());",
        "url": "/javascript-basic22"
    }
    ,
    
    "javascript-basic21": {
        "title": "Javascript - JavaScript 객체지향 - 상속",
            "author": "AhnSang0915",
            "category": "",
            "content": "Javascript    JavaScript 기본     JavaScript 숫자와 문자     JavaScript 변수, 비교    JavaScript 조건문    JavaScript 반복문    JavaScript 함수    JavaScript 배열    JavaScript 객체(Object)    JavaScript 모듈    JavaScript UI와 API    JavaScript 정규표현식    JavaScript 함수지향 - 유효범위    JavaScript 함수지향 - 값으로서의 함수와 콜백    JavaScript 함수지향 - 클로저    JavaScript 함수지향 - arguments    함수지향 - 함수의 호출    객체지향 - 객체지향 프로그래밍 소개    객체지향 - 생성자와 new    객체지향 - 전역객체    객체지향 - this    객체지향 - 상속    객체지향-표준 내장객체의 확장    JavaScript 객체지향-ObjectJavaScript 객체지향 - 상속1. 상속(inheritance)이란?우리가 객체라고 하는 것은 하나의 컨테이너고 변수나 메소드가 하나의 객체 안에 상속되어있다. 이런 객체의 특성으로 인해 객체를 그대로 물려받은 새로운 객체를 만들 수 있다. 이 객체는 부모에 해당 되는 객체의 변수의 메소드에 접근할 수 있게 된다. 즉 상속이란 오리지널 객체가 갖고있는 기능을 상속받는 객체가 동일하게 가질 수 있다는 것이다.Person이라고 하는 생성자를 만들었고 그 생성자에 new를 사용해 새로운 객체를 만들었다. 그 객체는 name이라고 하는 프로퍼티와 introduce라고 하는 프로퍼티를 가지고 있고, name의 값은 person에 인자로 전달된 값이 name으로 사용된다. 아래 코드를 실행하면 ‘My name is ansang’이 출력된다.function Person(name){    this.name = name;    this.introduce = function(){        return 'My name is '+this.name;     }   }var p1 = new Person('ansang');document.write(p1.introduce()+\"&lt;br /&gt;\");아래도 마찬가지로 Person이라고 하는 생성자를 만들었고 그 아래 생성자에 portotype이라고 하는 특수한 프로퍼티에 name이라고 하는 프로퍼티를 준 것이다. 즉 Person이라고 하는 생성자에는 prototype 프로퍼티가 있는데 그 안에 어떤 객체가 들어가있다. 그객체 .name을 하게 되면 어떤 값을 줄 수 있게 되는것이고 그객체 .introduce하고 함수를 할당을 하게 되면 어떤 메소드를 지정할 수 있는 것이다.function Person(name){    this.name = name;}Person.prototype.name=null;Person.prototype.introduce = function(){    return 'My name is '+this.name; }var p1 = new Person('ansang');document.write(p1.introduce()+\"&lt;br /&gt;\");2. 상속의 사용법아래는 우리가 처음에 본 예제에서 Programmer라는 생성자를 추가한 것이다. Programmer라는 생성자를 통해 만든 객체가 Person이라는 생성자를 통해서 만들어진 객체와 동일한 기능성을 갖도록 코드를 작성한 것이다.new Programmer(‘ansang’);를 통해서 Programmer라는 생성자를 호출했다. name이라는 프로퍼티 값을 ansang으로 지정을 했다. p1.introduce을 사용하려고 하는데 생성자 Programmer에는 introduce라는 메소드가 정의되어 있지 않다. introduce메소드는 Person이라고 하는 생성자에 정의되어 있는데 여기서 Programmer.prototype = new Person();로 Person 생성자의 프로퍼티와 메소드를 가져오게 된다. 우리는 Programmer에서 name의 값을 ansang으로 주었고 Programmer.prototype = new Person();에서 prototype 라는 어떠한 객체의 값이 생성자 Person과 같다고 했기 때문에 name은 ansang이되고 introduce메소드를 사용할 수 있는 것이다.function Person(name){    this.name = name;}Person.prototype.name=null;Person.prototype.introduce = function(){    return 'My name is '+this.name; } function Programmer(name){    this.name = name;}Programmer.prototype = new Person(); var p1 = new Programmer('ansang');document.write(p1.introduce()+\"&lt;br /&gt;\");3. 기능의 추가상속을 받는 객체를 만들었다면 기능을 추하가는 기능을 알아보자. Person이라고하는 공통의 부모가 있고 Programmer, Designer라는 객체가 person이라는 객체를 상속받는 형식이다.function Person(name){    this.name = name;}Person.prototype.name=null;Person.prototype.introduce = function(){    return 'My name is '+this.name; } function Programmer(name){    this.name = name;}Programmer.prototype = new Person();Programmer.prototype.coding = function(){    return \"hello world\";}function Designer(name){    this.name = name;}Designer.prototype = new Person();Designer.prototype.design = function(){    return \"beautiful\";} var p1 = new Programmer('ansang');document.write(p1.introduce()+\"&lt;br /&gt;\");document.write(p1.coding()+\"&lt;br /&gt;\");var p2 = new Designer('nibagman');document.write(p2.introduce()+\"&lt;br /&gt;\");document.write(p2.design()+\"&lt;br /&gt;\");여기서 My name is를 My nickname is로 바꾸면 My nickname is ansanghello worldMy nickname is nibagmanbeautiful의 값을 출력하게 된다. 이말은 Person이라는 생성자를 상속받은 객체들의 값도 바뀐다는 말이다.function Person(name){    this.name = name;}Person.prototype.name=null;Person.prototype.introduce = function(){    return 'My nickname is '+this.name; } function Programmer(name){    this.name = name;}Programmer.prototype = new Person();Programmer.prototype.coding = function(){    return \"hello world\";}function Designer(name){    this.name = name;}Designer.prototype = new Person();Designer.prototype.design = function(){    return \"beautiful\";} var p1 = new Programmer('ansang');document.write(p1.introduce()+\"&lt;br /&gt;\");document.write(p1.coding()+\"&lt;br /&gt;\");var p2 = new Designer('nibagman');document.write(p2.introduce()+\"&lt;br /&gt;\");document.write(p2.design()+\"&lt;br /&gt;\");4. prototype그럼 prototype이란 무엇인가? 한국어로는 원형정도로 번역되는 prototype은 말 그대로 객체의 원형이라고 할 수 있다. 함수는 객체다. 그러므로 생성자로 사용될 함수도 객체다. 객체는 프로퍼티를 가질 수 있는데 prototype이라는 프로퍼티는 그 용도가 약속되어 있는 특수한 프로퍼티다. prototype에 저장된 속성들은 생성자를 통해서 객체가 만들어질 때 그 객체에 연결된  다.생성자는 기본적으로 함수이다. 우리가 이 함 수를 호출할 때 new를 사용하면 생성자가 되는 것이고 그렇게 해서 실행된 결과로 새로운 객체를 만들고 이 객체는 o에 들어가게 된다. 그런데 비어있는 객체를 만드는 것만이 생성자의 역할이라고 한다면 그렇게 효율적이지 못하다. 생성자를 사용하는 이유는 우리가 객체를 생성했을 때 그 객체가 가져야 할 방법이나 프로퍼티 값을 가지고 우리에게 주어지기를 바라기 때문이다. 우리가 어떤 객체를 생성했을 때 객체가 가지고 있어야 하는 방법과 프로퍼티 prototype이라는 프로퍼티에 저장이 되는 것이다. 즉 prototype는 어떠한 객체가 정의가 되어있다는 것이다. 그렇게 하고 new를 이용해 생성자 함수를 생성하게 되면 Javascript는 생성자 함수의 prototype에 저장되어있는 객체를 꺼내서 그것을 돌려보내 주게 된다. 코드를 보자. 우리가 Sub.prototype = new Super(); 라고 하면 생성자 function Super(){} 이 만든 객체 Super.prototype = newUltra(); 이 만든 값이 들어가는 것이고 그리고 생성자 function Super(){}의 값은 Super.prototype = newUltra();로 만들어진 객체가 담긴다는 것이다. 생성자 function Ultra(){}의 값은 Ultra.prototype.ultra Prop = true; 이기 때문에 true가 출력된다. 이러한 개념은 prototype chain 이라고 한다.function Ultra(){}Ultra.prototype.ultraProp = true; function Super(){}Super.prototype = new Ultra(); function Sub(){}Sub.prototype = new Super(); var o = new Sub();console.log(o.ultraProp);5. prototype chain전에 본 코드를 아래와 같이 바꾸면 1을 출력하게 된다. 그이유는 javascript가 기본적으로 동작할 떄 o라는 객체가 ultraprop라는 값을 가지고 있는지 확인하고 우리가 o.ultraProp = 1;로 지정했기 때문에 1을 출력하게 된다.function Ultra(){}Ultra.prototype.ultraProp = true; function Super(){}Super.prototype = new Ultra(); function Sub(){}Sub.prototype = new Super(); var o = new Sub();o.ultraProp = 1;console.log(o.ultraProp);아래의 결과는 2가 된다. 코드를 실행하면 o라는 객체에 ultra Prop기 있는지 확인한다. 우리는 var o = new Sub();로 ultraProp에 대해선 정의한 바가 없다. 그래서 이 객체에 직접 ultraProp가 없다는 걸 확인하고, o라는 객체의 생성자를 알아내고(생성자를 알아내는 방법은 따로 있다.) Sub이라는 생성자의 prototype 객체를 확인해 그 객체의 프로퍼티 중에 ultraProp이 있는지 확인하고 그 값을 가져오게 된다.function Ultra(){}Ultra.prototype.ultraProp = true; function Super(){}Super.prototype = new Ultra(); function Sub(){}Sub.prototype = new Super();Sub.prototype.ultraProp = 2; var o = new Sub();console.log(o.ultraProp);아래의 결과는 3이다.function Ultra(){}Ultra.prototype.ultraProp = true; function Super(){}Super.prototype = new Ultra(); function Sub(){}var s = new Super();s.ultraProp = 3;Sub.prototype = s; var o = new Sub();console.log(o.ultraProp);아래의 값은 4이다.function Ultra(){}Ultra.prototype.ultraProp = true; function Super(){}var t = new Ultra();t.ultraProp = 4;Super.prototype = t; function Sub(){}var s = new Super();Sub.prototype = s; var o = new Sub();console.log(o.ultraProp);아래의 값은 true다.function Ultra(){}Ultra.prototype.ultraProp = true; function Super(){}var t = new Ultra();Super.prototype = t; function Sub(){}var s = new Super();Sub.prototype = s; var o = new Sub();console.log(o.ultraProp);주의할점은 어떠한 객체 super를 sub가 상속받고 싶다면 Sub.prototype에는",
        "url": "/javascript-basic21"
    }
    ,
    
    "javascript-basic20": {
        "title": "Javascript - JavaScript 객체지향 - this",
            "author": "AhnSang0915",
            "category": "",
            "content": "Javascript    JavaScript 기본     JavaScript 숫자와 문자     JavaScript 변수, 비교    JavaScript 조건문    JavaScript 반복문    JavaScript 함수    JavaScript 배열    JavaScript 객체(Object)    JavaScript 모듈    JavaScript UI와 API    JavaScript 정규표현식    JavaScript 함수지향 - 유효범위    JavaScript 함수지향 - 값으로서의 함수와 콜백    JavaScript 함수지향 - 클로저    JavaScript 함수지향 - arguments    함수지향 - 함수의 호출    객체지향 - 객체지향 프로그래밍 소개    객체지향 - 생성자와 new    객체지향 - 전역객체    객체지향 - this    객체지향 - 상속    객체지향-표준 내장객체의 확장    JavaScript 객체지향-ObjectJavaScript 객체지향 - this1. 함수와 thisthis는 함수 내에서 함수 호출 맥락(context 어떠한 의미가 고정되어 있지 않고 사용되는 상황에따라 그의미가 달라질 수 있따.)를 의미한다. 맥락이라는 것은 상황에 따라서 달라진다는 의미인데 즉 함수를 어떻게 호출하느냐에 따라서 this가 가리키는 대상이 달라진다는 뜻이다. 함수와 객체의 관계가 느슨한 자바스크립트에서 this는 이 둘을 연결시켜주는 실질적인 연결점의 역할을 한다.아래 코드는 조건문에서 window(전역객체)와 함수안에서의 this가 정확하게 일치한다면 window === this를 출력하는 코드이다. 개발자 도구 콘솔에서 실행시 아래와 같이 나온다. 아래 예제처럼 함수안에서의 this는 전역객체를 의미하는 window를 의미하는 것이다.function func(){    if(window === this){        console.log(\"window === this\");    }}undefinedfunc();// window === this2. 메소드와 this객체의 소속인 메소드의 this는 그 객체를 가르킨다. o라고 하는 변수에 객체를 정의해서 할당했다. 그객체엔 func라는 프로퍼티가 있고 함수이기 때문에 메소드 이다. 함수의 내용은 변수o와 this가 정확하게 같다면 o === this를 출력하는 함수이다. 출력값은 o === this 이다.var o = {    func : function(){        if(o === this){            document.write(\"o === this\");        }    }}o.func();   3. 생성자 this아래 코드는 함수를 호출했을 때와 new를 이용해서 생성자를 호출했을 때의 차이를 보여준다.function Func()의 funcThis = this;는 지역변수로 지정하지 않았기 때문에 전역변수인 funcThis의 값이 this가 된다. 그렇기 때문에 if(function === window)는 true가 된다. 이말은 우리가 함수와 this에서 본 예제와 같이 함수안에서의 this는 전역객체 window를 의미하는 것이다. 그아래 var o2 = new Func();는 new를 사용해 javascript내부적으로 비어있는 객체를 만들었다. 그비어있는 객체는 o2가된다. 그리고 var o2 = new Func();를 실행하면 생성자 function Func()가 실행이되고 this의 값이 funcThis가 되고 그값은 var = funcThis가 된다. 자 정리하자. 우리가 new생성자를 통해 o2에 빈객체를 만들었고 그 new생성자는 function Func(){funcThis = this;}이고 여기서의 funcThis는 var funcThis를 의미한다. 즉 우리가 생성자를 통해 만든 객체는 o2에 들어있고 그 생성자가 가르키는것이 var funcThis이기 때문에 if(funcThis === o2)는 true가 된다. 이것을 통해 알수 있는것은 생성자의 맥락으로, 똑같은 함수지만 생성자로 사용될 때에는 this의 값이 생성될 객체를 의미한다.var funcThis = null;  function Func(){    funcThis = this;}var o1 = Func();if(funcThis === window){    document.write('window &lt;br /&gt;');} var o2 = new Func();if(funcThis === o2){    document.write('o2 &lt;br /&gt;');}위의 예제를 조금 바꿔봤다. if(o2 === this); 를 추가했는데 이렇게 되면 문제가 있다. 우리가 생성자를 호출하게 되면 생성자에대한 호출이 모두 끝나고난 뒤에 그때 비로소 o2라고하는 변수에 우리가 생성한 객체가 할당이 된다. 그전에 객체는 만들어져 있지만 o2라는 변수에 할당되어 있지 않기 때문에 우리는 객체를 할당할수 없다. 따라서 생성자 안에서 o2라는 변수와 this를 확인하면 o2라는 변수에 객체가 담겨있지 않기때문에 undefined이다. this라고 하는것은 객체에대한 초기화가 끝나서var funcThis = null;  function Func(){    if(o2 === this);}var o2 = new Func();if(funcThis === o2){    document.write('o2 &lt;br /&gt;');}//undefined4. 객체로서의 함수이번엔 javascript가 얼마나 유연한지 극명하게 보여주는 주제를 알아보자.아래 예제는 개발자도구에 입력한 내용이다. function sum(x,y) {return x+y;}는 sum이라고하는 함수 객체를 만든것이다. 그런데 우리가 new Function(‘x’,’y’,’return x+y;’);로 함수객체를 만드는것은 함수의 본문이 복잡하면 굉장히 힘들다. 그래서 함수를 쉽게작성할 수 있도록 function sum(x,y) {return x+y;} 이런식으로 작성하면 javascript해석기는 함수객체를 만들어주고 이런식의 작성을 함수 리터럴(literal)이라고 한다. 그리고 객체를 만들때  var a = {} 이런식으로 만드는것을 객체 리터럴, var a = []; 이런식을 배열 리터럴이라고 한다. 우리가 명시적으로  new Object, new array등으로 만들수도 있지만 보다 편리하게 어떤 값을 만들수있도록 해주는 처리를 리터럴(literal)이라고 한다.function sum(x,y) {     return x+y;}undefinedsum(1,2);3var sum2 = new Function('x','y','return x+y;'); // new를 통해서 function이라고하는 생성자함수를 호출한것이다. 앞의 두'x','y',는 함수를 정의할때 매개변수를 정의하는것과 같은 의미이고 마지막 'return x+y;' 가 본문{}에 해당되는 것이다.undefinedsum2(1,2);35. apply와this함수가 가지고있는 프로퍼티중에 EcamaScript에서 정의하고있는 메소드중의 하나가 apply와 call이다.switch는 괄호안의 어떤값이 들어가면 값과 같은 케이스 안에들어있는 구간이 break를 만날때까지 실행된다. if문과 대체제의 관계에 있고 이것은 for문과 while문이 대체제역할에 있는것과 같다.함수를 apply를이용해 호출했을때 내부적으로 this의 값은 어떻게 변경되는지 알아보자. func();를 호출하게 되면 함수에서의 this의 값은 전역객체window를 의미하기 때문에 window를 실행하게 된다. func.apply(o);는 객체이기 때문에 프로퍼티를 가지고 있을수 있고 Ecmascript의 스펙으로 정의되어 있는 표준 메소드인 apply를 가지고있다. apply를 호출할때 첫번째 인자로 함수호출 컨테스트 o를 주게되면 func()함수가 실행되게 되면서 this의값이 o가된다. 그래서 o를실행하고 braek가되어 값을 반환하게된다. func.apply(p);도 마찬가지로 p를 반환할 것이다.var o = {}var p = {}function func(){    switch(this){        case o:            document.write('o&lt;br /&gt;');            break;        case p:            document.write('p&lt;br /&gt;');            break;        case window:            document.write('window&lt;br /&gt;');            break;              }}func();func.apply(o);func.apply(p);window, o, p라는 객체와 함수가 있었다. 함수를 어떻게 호출하느냐에 따라 즉 맥락에 따라 window에 소속되기도 하고 o와 p에 소속되기도 했다.",
        "url": "/javascript-basic20"
    }
    ,
    
    "javascript-basic19": {
        "title": "Javascript - JavaScript 객체지향 - 전역객체",
            "author": "AhnSang0915",
            "category": "",
            "content": "Javascript    JavaScript 기본     JavaScript 숫자와 문자     JavaScript 변수, 비교    JavaScript 조건문    JavaScript 반복문    JavaScript 함수    JavaScript 배열    JavaScript 객체(Object)    JavaScript 모듈    JavaScript UI와 API    JavaScript 정규표현식    JavaScript 함수지향 - 유효범위    JavaScript 함수지향 - 값으로서의 함수와 콜백    JavaScript 함수지향 - 클로저    JavaScript 함수지향 - arguments    함수지향 - 함수의 호출    객체지향 - 객체지향 프로그래밍 소개    객체지향 - 생성자와 new    객체지향 - 전역객체    객체지향 - this    객체지향 - 상속    객체지향-표준 내장객체의 확장    JavaScript 객체지향-ObjectJavaScript 객체지향 - 전역객체1. 전역객체란?전역객체(Global object)는 특수한 객체다. 모든 객체는 이 전역객체의 프로퍼티다. func();와 window.func();는 모두 실행이 된다. 모든 전역변수와 함수는 사실 window 객체의 프로퍼티다. 객체를 명시하지 않으면 암시적으로 window의 프로퍼티로 간주된다. 생략이 가능하다는 말이다.function func(){    alert('Hello?');    }func();window.func();모든 전역변수와 함수는 window객체의 프로퍼티다. 객체를 명시하지 않으면 암시적으로 window의 프로퍼티로 간주한다. 아래 예제는 전역변수 o에 객체메소드를 지정했다. 그렇기 떄문에 o.func();와 window.o.func();가 모두 실행이 되는걸 알수있다.var o = {'func':function(){    alert('Hello?');}}o.func();window.o.func();전역객체 APIECMAScript에서는 전역객체의 API.를 정의해두었다. 그 외의API는 호스트 환경에서 필요에 따라서 추가로 정의하고 있다. 이를테면 웹브라우저 자바스크립트에서는 alert()이라는 전역객체의 메소드가 존재하지만 node.js에는 존재하지 않는다. 또한 전역객체의 이름도 호스트환경에 따라서 다른데, 웹브라우저에서 전역객체는 window이지만 node.js에서는 global이다.",
        "url": "/javascript-basic19"
    }
    ,
    
    "javascript-basic18": {
        "title": "Javascript - JavaScript 객체지향 - 생성자와 new",
            "author": "AhnSang0915",
            "category": "",
            "content": "Javascript    JavaScript 기본     JavaScript 숫자와 문자     JavaScript 변수, 비교    JavaScript 조건문    JavaScript 반복문    JavaScript 함수    JavaScript 배열    JavaScript 객체(Object)    JavaScript 모듈    JavaScript UI와 API    JavaScript 정규표현식    JavaScript 함수지향 - 유효범위    JavaScript 함수지향 - 값으로서의 함수와 콜백    JavaScript 함수지향 - 클로저    JavaScript 함수지향 - arguments    함수지향 - 함수의 호출    객체지향 - 객체지향 프로그래밍 소개    객체지향 - 생성자와 new    객체지향 - 전역객체    객체지향 - this    객체지향 - 상속    객체지향-표준 내장객체의 확장    JavaScript 객체지향-ObjectJavaScript 객체지향 - 생성자와 new1.자바스트립트의 객체지향Javascript는 어떠한 객체지향 언어와도 같지않다. Javascript만의 독특한 성질을 갖고있고, Javascript의 계열에 속하는 언어들은 prototype-based programming이라 부른다. Javascript도 여기에 속해있는 언어다. 전통적인 함수형 언어의 특성을 그대로 갖고있는게 아니고 객체지향언어가 갖고있는 문법을 비슷하게 사용하면서 사실은 함수형언어의 특성을 갖고있다. 객체지향 프로그래밍을 간단하게 이야기하면 서로 연관되어있는 변수와 메소드를 하나의 객체라고하는 그릇에 넣는것이다. 그리고 서로 연관되어있지 않은 것들은 별도의 객체에다 분리를 시켜놓는 것이 객체지향 프로그래밍의 기본적인 형태라고 할 수 있다. 연관되어 있는 로직들을 객체화 시키게되면 각각의 로직들은 하나하나가 독립된 프로그램처럼 독립성을 갖게된다. 독립성을 갖게된다는것은 여러 완제품의 부품으로 사용될 수 있다는 것이다. 우리가 객체지향 프로그래밍으로 도달하고자하는 목표는 좋은 부품을 만드는 것이라고 할 수 있겠다.2. 객체 생성객체를 만들어 보자. {}를 사용하면 비어있는 객체를 만드는 것이고, oject라는 이름의 object를 만드는 것이다. 비어있는 상자라고 생각하자.  person.name 이라고하면 object라는 그릇에 name이라는 변수를 담은것이다. 그변수의 내용은 문자열 ‘ansang’이 되는것이다. 그런데 우리는 객체에 담겨있는 변수를 변수라고 하지않고 프로퍼티(property)라고 부를것이다. 그리고 우리는 또다른 프로퍼티로 person.introduc 를 넣었다. 프로퍼티 안에 함수를 담게되면 우리는 메소드라고 부르기로했다. 객체 내의 변수를 프로퍼티(property) 함수를 메소드(method)라고 부른다는 것이다. 아래 예제를 실행을 시키면 함수가 실행이 되는데 ‘My name is ‘+this.name 의 this는 함수가 속해있는 객체, person이 담고있는 객체를 의미하는 것이다. person이 담고이있는 객체는 person.name = ‘egoing’으로 this.name은 ‘ansang’을 의미하게 된다. 그런데 아래 코드는 객체를 만들었는데 객체안에 들어갈 여러 프로퍼티가 객체와 분리가 되어있다. 그렇다보니 그 과정에서 중간에 다른 코드가 끼어든다거나 여러가지 이유로 인해서 객체를 정의하는 부분이 집중도가 떨어질 수 있다.var person = {} //비어있는 객체 person.name = 'ansang';person.introduce = function(){    return 'My name is '+this.name; }document.write(person.introduce());위와같은 문제를 방지하는 것이 우리가 직접 객체를 시작하고 닫는 기호 사이에 프로퍼티와 메소드를 직접 정의해 주는것이다.var person = {    'name' : 'ansang',    'introduce' : function(){        return 'My name is '+this.name;    }}document.write(person.introduce());만약에 person이라는 객체를 여러개 만들어서 여러사람에대한 정보를 담을수 있는 person객체를 만든다고 하면 아래처럼 만들면 될까?var person1 = {    'name' : 'ansang',    'introduce' : function(){        return 'My name is '+this.name;    }}var person2 = {    'name' : 'ansanghyun',    'introduce' : function(){        return 'My name is '+this.name;    }1,2로 두개의 객체를 만들었다. 문제는 name을 정의하는 부분과 introduce메소드 부분이 중복되어있다. name은 각각의 데이터가 다르기때문에 완전한 중복이라고는 보기힘들지만 메소드 부분은 완벽히 같은 내용으로 중복되어있다. 이것들이 같은 취지의 객체라고 한다면 그 객체가 가지고있는 메소드를 찾아서 똑같이 바꿔줘야하는 이슈가 생긴다. 이것은 프로그래머들이 혐오하는 중복이 발생한 것이다. 중복이 있다는것은 가독성이 떨어지고 코드의 양이 많아져 유지보수가 힘들어진다는 것이다. 이문제를 해결할 수 있는 방법은 중복을 제거하는 것이고 그방법은 생성자,new라는 것이다.3.생성자와 new생성자생성자(constructor)는 객체를 만드는 역할을 하는 함수다. 자바스크립트에서 함수는 재사용 가능한 로직의 묶음이 아니라 객체를 만드는 창조자라고 할 수 있다.아래는 개발자 도구에서 실행한 코드이다. new를 붙이고 함수를 호출하게 되면 함수는 그냥 함수라고 하지 않고 생성자라고 부른다. 이생성자는 객체의 생성자이고 비어있는 객체를 만들어 p에 반환한다. 그래서 p에는 person {}의 비어있는 객체가 만들어졌다.function person () {} //함수를 만들었다. 함수는 어떠한 값도 담고있지 않다.undefinedvar p0 = person(); //함수에 변수를 지정했다.undefinedp0                  //p0의 값이 없다고 나온다.undefinedvar p = new person(); // new를 추가하고 실행하면 아래와같은 객체가 만들어진게 보인다. undefinedpperson {} // var p = {} 과 같다고 볼수있다. (완전히 같진 않지만 지금 단계에서는.)자바스크립트에서는 원시타입(숫자, 불린값, null과 undefined)를 제외한 모든 값이 객체이다.객체를 생성하는 방법에는 2가지가 있는데 객체리터럴과 생성자로 객체를 만들 수 있는데 아래 예제는 객체 리터럴{}로 객체를 생성한 것과 같은 방법이라고 할 수 있다.function Person(){}var p = new Person();p.name = 'egoing';p.introduce = function(){    return 'My name is '+this.name; }document.write(p.introduce());아래 예제는 객체리터럴로 객체를 생성해 introduce 메소드 부분이 중복된 상황이다.function Person(){}var p1 = new Person();p1.name = 'egoing';p1.introduce = function(){    return 'My name is '+this.name; }document.write(p1.introduce()+\"&lt;br /&gt;\"); var p2 = new Person();p2.name = 'leezche';p2.introduce = function(){    return 'My name is '+this.name; }document.write(p2.introduce());위의 중복된 상황을 해결하기 위해 new를 사용해 생성자를 사용해 코드를 바꾸었다. 생성자함수( new 연산자와 함께 호출하여 객체(인스턴스)를 생성하는 함수를 말한다. 생성자 함수에 의해 생성된 객체를 인스턴스(instance)라 한다.) 코드를 통해서 알 수 있듯이 생성자 함수는 일반함수와 구분하기 위해서 첫글자를 대문자로 표시한다. Person이라는 함수를 작성했고 var p1 = new Person 함수의 앞에 new를 배치해 Person이라는 함수는 생성자가 된것이다. 인자로 ‘ansang’을 배치해 그값은 name에 들어간다 그리고 name은 this.name = ‘ansang’ 이된다. 즉 이객체의 프로퍼티의 값이 ansang이 된것이다. 그리고 현재 객체의 introduce라고하는 프로퍼티에 함수를 정의해 메소드를 만들었다. 생성자 함수가 다실행된 후에 p1에 담겨지게 된다. p1,p2에 new Person(‘ansang’);, new Person(‘sanghyun’); 를통해 생성자에 전달해 introduce라는 부분이 간단해졌다. 우리가 Person이라는 생성자가 만들어 놓은 빈 객체가 가져야할 프로퍼티와 메소드를 생성자 함수안에 기술하는것으로 인해서 그객체가 가지고있 정보와 객체가 할수 있는 일,이러한 것들을 이렇게 세팅해 주고 있는데 이런것들을 초기화 라고하고 줄여서init또는 initialize라고 한다. 즉 중요한 점은 생성자를 통해 객체를 초기화를 했다는 것이다.function Person(name){    this.name = name;     this.introduce = function(){        return 'My name is '+this.name;     }   }var p1 = new Person('ansang');document.write(p1.introduce()+\"&lt;br /&gt;\"); var p2 = new Person('sanghyun');document.write(p2.introduce());",
        "url": "/javascript-basic18"
    }
    ,
    
    "javascript-basic17": {
        "title": "Javascript - JavaScript 객체지향 - 객체지향 프로그래밍 소개",
            "author": "AhnSang0915",
            "category": "",
            "content": "Javascript    JavaScript 기본     JavaScript 숫자와 문자     JavaScript 변수, 비교    JavaScript 조건문    JavaScript 반복문    JavaScript 함수    JavaScript 배열    JavaScript 객체(Object)    JavaScript 모듈    JavaScript UI와 API    JavaScript 정규표현식    JavaScript 함수지향 - 유효범위    JavaScript 함수지향 - 값으로서의 함수와 콜백    JavaScript 함수지향 - 클로저    JavaScript 함수지향 - arguments    함수지향 - 함수의 호출    객체지향 - 객체지향 프로그래밍 소개    객체지향 - 생성자와 new    객체지향 - 전역객체    객체지향 - this    객체지향 - 상속    객체지향-표준 내장객체의 확장    JavaScript 객체지향-ObjectJavaScript 객체지향 프로그래밍 소개객체지향 프로그래밍객체지향 프로그래밍이(Object-Oriented Programming)란 OOP라고도 하고 핵심키워드는 객체이다. 객체지향 프로그래밍에서의 객체를 추상적으로 말하면 상태와 행위로 구분해 서로연관되어있는 상태와 행위를 그룹화 해놓은 것을 객체라고 할수 있다. 이 객체들을 마치 레고 블럭처럼 조립해서 하나의 프로그램을 만드는 것이 객체지향 프로그래밍이라고 할 수 있다. 다시 말해서 객체지향 프로그래밍은 객체를 만드는 것이다. 따라서 객체지향 프로그래밍의 시작은 객체란 무엇인가를 이해하는 것이라고 할 수 있다. 문법과 설계객체지향 프로그래밍 교육은 크게 두 가지로 구분된다.문법하나는 객체지향을 편하게 할 수 있도록 언어가 제공하는 기능을 익히는 것이다. 이러한 기능들은 if, for문처럼 문법적인 구성을 가지고 있다. 이 문법을 이해하고, 숙지해야 객체를 만들 수 있다. 객체를 만드는 법에 대한 학습이라고 할 수 있다. 우리 수업은 여기에 초점이 맞춰져 있다.설계두번째는 좋은 객체를 만드는 법이다. 현실에서 우리가 관심이있는 어떤 특성, 어떤관점을 소프트웨어화 시켜서 문제를 해결하는것이 프로그램, 프로그래밍이다.위의 그림은 런던의 지도이다. 이미지중 어떤것이 가장 보기 편할까. 마지막의 이미지가 보기 제일 편하지 않을까? 역과 역사이이의 환승역이라던지 노선들을 간단하게 추상화(abstract)시켜 보여주고 있다. 복잡함을 제외하고 사용자의 유일한 관심사에 초점을 맞춰 편의성을 높였다. 지하철 노선도가 디자인의 추상화라고 한다면 프로그램을 만든다는 것은 소프트웨어의 추상화라고 할 수 있다. 객체 지향 프로그래밍은 좀 더 현실을 잘 반영하기 위한 노력의 산물이다. 이것은 단순히 객체 지향의 문법을 이용해서 객체를 만든다고 달성되는 것이 아니다. 고도의 추상화 능력이 필요하다. 좋은 설계는 문법을 배우는 것보다 훨씬 어려운 일이다. 심지어 이것은 지식을 넘어서 지혜의 영역이다. 좋은 설계를 위한 조언들은 많지만 이러한 조언들은 조언자의 입을 떠나는 순간 생명력을 잃어버린다. 지식은 전수되지만 지혜는 전수되지 않기 때문이다. 스스로 경험하고 깨우쳐서 자기화시켜야 한다. 필자도 그 긴 여정을 따라가고 있는 견습생에 불과하다.객체지향의 설계 원칙이나 객체 지향의 철학적인 의미는 대단히 중요하다. 하지만 이러한 것들을 지금 언급한다면 미궁 속에 빠지게 될 것이다. 그래서 우리가 할 것은 일단은 지식부터 익히자는 것이다. 언어가 지원하는 객체지향 문법을 배우고, 이것들이 어떻게 동작하는지를 충분히 이해한 다음에 비로소 설계 원칙도 이야기할 수 있고, 객체와 사물의 비유도 시도해 볼 수 있을 것이다. 여기서는 몇 가지 객체지향이 추구하는 지향점을 가볍게 이야기하고 다음 토픽부터 구체적인 문법을 알아볼 것이다.부품화객체지향 프로그래밍을 구성하고 있는 컨셉들은 상당히 많다. 하나의 프로그램이 여러개의 로직으로 이루어져 있다. 그 로직을 그룹화 시켜놓고 로직과 관련된 변수와 메소드들을 그룹화 해놓은게 객체이다. 이렇게 함으로서 재활용성을 높일수 있다. 그럼 이 객체를 다른곳에 사용한다는 것은 이객체가 다른 곳, 여러곳에서 일종의 부품으로서 사용된다는 것이다.아래는 초창기의 컴퓨터이다.본체와 모니터, 키보드가 하나로 단일화되어 있다. 어딘가 고장나면 컴퓨터를 바꿔야할수도 있다.하지만 위의 이미지처럼 부품을 나누어 놓는다면 고장난 부품만 고치면 될것이다. (이미지 생활코딩 참조)객체 지향은 부품화의 정점이라고 할 수 있다. 하지만 우리는 아직 객체 지향을 배우지 않았다. 그래서 우리가 배운 것 중에서 부품화의 특성을 보여줄 수 있는 기능을 생각해보면 좋을 것 같다. 메소드는 부품화의 예라고 할 수 있다. 메소드를 사용하는 기본 취지는 연관되어 있는 로직들을 결합해서 메소드라는 완제품을 만드는 것이다. 그리고 이 메소드들을 부품으로 해서 하나의 완제품인 독립된 프로그램을 만드는 것이다. 메소드를 사용하면 코드의 양을 극적으로 줄일 수 있고, 메소드 별로 기능이 분류되어 있기 때문에 필요한 코드를 찾기도 쉽고 문제의 진단도 빨라진다.그런데 프로그램이 커지면 엄청나게 많은 메소드들이 생겨나게 된다. 메소드와 변수를 관리하는 것은 점점 어려운 일이 되기 시작한다. 급기야는 메소드가 없을 때와 같은 상황에 봉착하게 된다. 메소드는 프로그래밍의 역사에서 중요한 도약이었지만, 이 도약이 성숙하면서 새로운 도약지점이 보이기 시작한 것이다.그 도약 중의 하나가 객체 지향 프로그래밍이다. 이것의 핵심은 연관된 메소드와 그 메소드가 사용하는 변수들을 분류하고 그룹핑하는 것이다. 바로 그렇게 그룹핑 한 대상이 객체(Object)다. 비유하자면 파일과 디렉토리가 있을 때 메소드나 변수가 파일이라면 이 파일을 그룹핑하는 디렉토리가 객체라고 할 수 있다. 이를 통해서 더 큰 단위의 부품을 만들 수 있게 되었다. 객체를 만드는 법에 대해서 호기심이 생기지 않는가? 이런 호기심을 유발시키는 것이 이번 토픽의 목적이다. 객체를 만드는 법은 다음 토픽에서 알아보고 지금은 부품화에 대해서 조금 더 생각해보자.은닉화, 캡슐화제대로된 부품이라면 그것이 어떻게 만들어졌는지 모르는 사람도 그 부품을 사용하는 방법만 알면 쓸 수 있어야한다. 모니터가 어떻게 동작하는지는 몰라도 컴퓨터와 모니터를 연결하는 방법을 알면 모니터를 설치해 사용할 수 있는것과 같다. 즉 내부동작 방법을 단단한 케이스(객체)안으로 숨기고 사용자에게 그 부품의 사용방법(메소드)만을 노풀하고 있는 것이다. 이러한 컨셉을 정보의 은닉화(Information Hiding), 또는 캡슐화(Encapsulation)라고 부른다. 자연스럽게 사용자에게는 그 부품을 사용하는 방법이 중요한 것이 된다.인터페이스좋은부품의 또다른 특징은 인터페이스이다. 잘만든 부품은 서로 교환할 수 있어야 한다. 모니터를 바꾼다고 가정해보자 서로다른 회사의 모니터를 교환하려고 하면 회사가 다르더라도 모니터를 연결할 수 있어야 한다. 이것은 컴퓨터와 모니터를 연결해주는 케이블이 표준화 되어있기 때문에 가능한 것이다.컴퓨터와 모니터를 만드는 업체들은 HDMI케이블 규격을 공유한다. 각각의 부품은 미리 정해진 약속에 따라 신호의 입출력을 가능하게 해주는 연결점의 모양을 표준에 맞게 만들면 된다. 이러한 연결점을 인터페이스Interface)라고 한다. 즉 인터페이스는 부품들 간의 약속이다. 프로그래밍에서도 인터페이스에 해당하는것을 소프트웨어 적으로 제공하고 있다.  이러한 약속을 프로그램밍 적으로는 어떻게 구현하는가도 알아보자.지금까지 객체를 부품으로 비유해서 설명 했다. 그런데 비유는 비유일 뿐이다. 비유는 의도한 유사점 뿐만 아니라 의도하지 않은 차이점까지도 전달될 가능성이 있기 때문이다. 비유의 함정이라고 할 수 있다. 소프트웨어는 하드웨어가 아니다. 하드웨어가 할 수 없는 것을 소프트웨어는 할 수 있다. 그 중의 하나가 복제와 상속이다. 이러한 개념을 구체적인 문법 없이 설명하는 것은 효용이 크지 않을 뿐만 아니라 자칫 흥미를 저해할 위험이 있기 때문에 여기서는 설명하지 않았다. 소프트웨어가 있기 이전부터 하드웨어가 이룩한 성취를 잘 수용하면서 동시에 소프트웨어 다운 소프트웨어를 만드는 것은 우리게게 주워진 숙제라고 할 수 있다",
        "url": "/javascript-basic17"
    }
    ,
    
    "javascript-basic16": {
        "title": "Javascript - JavaScript 함수지향 - 함수의 호출",
            "author": "AhnSang0915",
            "category": "",
            "content": "Javascript    JavaScript 기본     JavaScript 숫자와 문자     JavaScript 변수, 비교    JavaScript 조건문    JavaScript 반복문    JavaScript 함수    JavaScript 배열    JavaScript 객체(Object)    JavaScript 모듈    JavaScript UI와 API    JavaScript 정규표현식    JavaScript 함수지향 - 유효범위    JavaScript 함수지향 - 값으로서의 함수와 콜백    JavaScript 함수지향 - 클로저    JavaScript 함수지향 - arguments    함수지향 - 함수의 호출    객체지향 - 객체지향 프로그래밍 소개    객체지향 - 생성자와 new    객체지향 - 전역객체    객체지향 - this    객체지향 - 상속    객체지향-표준 내장객체의 확장    JavaScript 객체지향-ObjectJavaScript 함수지향 - 함수의 호출1. apply 소개Javascript에서 함수는 일종의 객체이다. 객체는 속성을 갖고있고 그 속성의 값을 가지고있으면 속성(property)라고 부르고 함수를 갖고있다면 메소드(method)라고 부른다.\tfunction func(){ }func();//func라는 함수는 객체이고 메소드를 갖고있다. func.apply func.call이라는 메소드에 접근할수 있다. 이것들이 하는역할은 func라는 객체를 호출하는 역할을 한다.아래는 크롬 개발자 도구에서 실행한 코드이다. sum함수를 정의하고  arg1,arg2의 인자를 갖고있다. 여기서 특이한점은 sum(1,2), sum(4,2)를 실행한 결과와 sum.apply(null, [1,2]); sum.apply(null, [4,2]);를 한결과가 같다 이말은 .apply에 두번째 인자로 배열을 넣은 값들이 arg1, arg2가 되었다는 말이다. 다음 주제에서 왜 이렇게 복잡한 방법으로 함수를 호출하는지 그 이유를 배워보자.\tfunction sum(arg1, arg2) {    return arg1+arg2 ; }undefinedsum(1,2);3sum(4,2);6sum.applyƒ apply() { [native code] } // apply라고 하는 메소드가 브라우저에서 제공하는 메소드이기때문에 코드를 보여줄수 없다는 말이다. 내장된 코드는 네이티브 코드라는 메세지를 보여주게 되어있다.sum.apply(null, [1,2]);3sum.apply(null, [4,2]);62. apply 사용apply를 사용하는 구체적인 이유를 알아보자. 우선 아래 코드는 함수를 정의하고 있다. _sum이라는 변수를 0으로 초기화 시켰고, for in 문으로 this라는 객체에 담겨있는 값들을 하나씩 꺼내 _sum이라는 지역변수에 하나씩 더해 바깥으로 리턴해주고있다. this가 무엇인지는 javascript에서 상당히 중요하다. 이맥락에서 this가 무엇인지는 정해져 있지 않다. 이전의 예제와는 다르게 sum.apply(o1), 그리고 o2를 주었다. 이말은 sum이라는 메소드를 호출할때의 대상을 o1, o2로 준것이다. sum.apply(o1)을 하게되면 o1이 sum이라고 하는 함수의 this가 된다. 독립되어있는 함수가 sum.apply를 하고 o1, o2를 인자로 전달하게되면 o1.sum, o2.sum이라는 메소드가 된다는 것이다.o1 = {val1:1, val2:2, val3:3}o2 = {v1:10, v2:50, v3:100, v4:25}function sum(){ // sum.apply(o1)을 하게되면 var this = o1; 이되는거라고 생각하자.    var _sum = 0;     for(name in this){ //이 맥락에서 this는 정해져 있지 않다.        _sum += this[name];    }    return _sum;}alert(sum.apply(o1)) // 6alert(sum.apply(o2)) // 185위 코드를 aaply를 사용하지 않으면 아래 코드처럼 될것이다. 이렇게 작성하고 출력하게 되면 6과 185이후에 sum함수의 내용도 같이 출력이 된다. 우리가 sum이라는 함수를 o1, o2의 속성으로 추가했기 때문이다. sum : sum 의 왼쪽 sum은 o1, o2 객체의 속성(property)명이 되고 오른쪽 sum은 미리 만들어놓은 함수(function) sum이다. 그리고 객체를 호출하는데 객체의 접근방법은 속성명[property 또는 키값], 속성명.property 또는 키값으로 호출할수 있지만, 메서드의 경우 속성명.메소드명()로 접근한다. 따라서 o1.sum(),o2.sum()로 호출하고 이렇게 호출하면 for in문이 this를 열거하는 과정에서 sum이라는 함수도 더하고 있기때문에 숫자열을 더하고 문자열까지 더해 출력하게 되는것이다.function sum(){    var _sum = 0;    for(name in this){         _sum += this[name];    }    return _sum;}o1 = {val1:1, val2:2, val3:3, sum:sum}o2 = {v1:10, v2:50, v3:100, v4:25, sum:sum}alert(o1.sum());alert(o2.sum());위 출력에서 함수내용을 출력하지 않으려면  if(typeof this[name] !=== ‘function’ )를 사용해 출력에 제한을 주면 되겠다. 조건문을 사용해 typeof로 함수와 같지 않은경우만 더할것이라고 추가하면 함수의 차례가 오면 그부분을 스킵할 수 있게된다.function sum(){    var _sum = 0;    for(name in this){        if(typeof this[name] !=== 'function' )        _sum += this[name];    }    return _sum;}o1 = {val1:1, val2:2, val3:3, sum:sum}o2 = {v1:10, v2:50, v3:100, v4:25, sum:sum}alert(o1.sum());alert(o2.sum());물론 위의 방법대로 해도 사용할 수 있겠지만 복잡하기 때문에 apply를 사용하게되면 함수가 호출되는 시점에서 this값을 프로그래밍적으로 변경해 함수가 o1이라는 객체의 속성인것처럼 실행되게 할수있다.",
        "url": "/javascript-basic16"
    }
    ,
    
    "javascript-basic15": {
        "title": "Javascript - JavaScript 함수지향 - arguments",
            "author": "AhnSang0915",
            "category": "",
            "content": "Javascript    JavaScript 기본     JavaScript 숫자와 문자     JavaScript 변수, 비교    JavaScript 조건문    JavaScript 반복문    JavaScript 함수    JavaScript 배열    JavaScript 객체(Object)    JavaScript 모듈    JavaScript UI와 API    JavaScript 정규표현식    JavaScript 함수지향 - 유효범위    JavaScript 함수지향 - 값으로서의 함수와 콜백    JavaScript 함수지향 - 클로저    JavaScript 함수지향 - arguments    함수지향 - 함수의 호출    객체지향 - 객체지향 프로그래밍 소개    객체지향 - 생성자와 new    객체지향 - 전역객체    객체지향 - this    객체지향 - 상속    객체지향-표준 내장객체의 확장    JavaScript 객체지향-ObjectJavaScript 함수지향 - arguments1. arguments 소개arguments객체는 배열과 유사하다. arguments는 함수안에서 사용할 수 있도록 그 이름이나 특성이 약속되어 있는 일종의 배열이다. 몇개의 인자가 들어올지 모를떄 인자를 정의하지 않고 그함수 안에 arguments를 사용하여 결과를 알아내면 되겠다.아래의 예제는 매개변수가 없는 sum이라는 함수가 있다. javacsript는 관대한 언어이다. 매개변수가 없거나, 인자의 수와 매개변수의 수가 다르더라도 문제가 생기지 않는다.아래 for문에서의 arguments는 Javascript와 약속되어있는 특수한 이름의 변수명이다. arguments라는 배열이 담겨져 있다. 이 배열의 역할을 사용자가 전달한 인자(1,2,3,4)를 담는것이다. 그래서arguments.length는 4가되고 4만큼 for문이 반복되게된다.document.write(i+’ : ‘+arguments[i]+’&lt;\\br /&gt;’);는 0 : 1(인덱스0) 부터 차례로 표시하게되고, 그후 _sum의 변수에 +=(a+=1;는a=a+1;과 같다) arguments[i];를 담았다. 이말은 (1,2,3,4)의 값을 _sum = _sum + arguments[i]이다. 즉, sum_에 1234를 차례로 더한다는 것이다. _sum의 초기값은 0이기 때문에 10이된다.\tfunction sum(){    var i, _sum = 0;     // i 루프를 위한 변수 _sum 출력할 결과를 담아낼 변수    for(i = 0; i &lt; arguments.length; i++){       //arguments javascript와 약속되어있는 특수한 이름의 변수명        document.write(i+' : '+arguments[i]+'&lt;br /&gt;');        _sum += arguments[i];    }       return _sum;}document.write('result : ' + sum(1,2,3,4)); 2. 매개변수의 수 - function length함수명.length는 몇개의 매개변수를 갖고있는지 알려주고, arguments.length는 함수를 호출할때 몇개의 인자, 몇개의 arguments를 담고있는지의 정보를 담고있다.function zero(){    console.log(        'zero.length', zero.length,        'arguments', arguments.length    );}function one(arg1){    console.log(        'one.length', one.length,        'arguments', arguments.length    );}function two(arg1, arg2){    console.log(        'two.length', two.length,        'arguments', arguments.length    );}zero(); // zero.length 0 arguments 0 one('val1', 'val2');  // one.length 1 arguments 2 two('val1');  // two.length 2 arguments 1",
        "url": "/javascript-basic15"
    }
    ,
    
    "javascript-basic14": {
        "title": "Javascript - JavaScript 함수지향 - 클로저",
            "author": "AhnSang0915",
            "category": "",
            "content": "Javascript    JavaScript 기본     JavaScript 숫자와 문자     JavaScript 변수, 비교    JavaScript 조건문    JavaScript 반복문    JavaScript 함수    JavaScript 배열    JavaScript 객체(Object)    JavaScript 모듈    JavaScript UI와 API    JavaScript 정규표현식    JavaScript 함수지향 - 유효범위    JavaScript 함수지향 - 값으로서의 함수와 콜백    JavaScript 함수지향 - 클로저    JavaScript 함수지향 - arguments    함수지향 - 함수의 호출    객체지향 - 객체지향 프로그래밍 소개    객체지향 - 생성자와 new    객체지향 - 전역객체    객체지향 - this    객체지향 - 상속    객체지향-표준 내장객체의 확장    JavaScript 객체지향-ObjectJavaScript 함수지향 - 클로저클로저(closure)는 내부함수가 외부함수의 맥락(context)에 접근할 수 있는 것을 가르킨다. 클로저는 자바스크립트를 이용한 고난이도의 테크닉을 구사하는데 필수적인 개념으로 활용된다.1. 내부함수, 외부함수내부함수아래 코드는 함수안에 또다른 함수를 선언한 것이다. 함수 outter은 외부함수가 되고 inner함수는 내부함수가 된다. inner함수는 var inner = fuction {} 과 같게된다.\tfunction outter(){    function inner(){        var title = 'coding everybody';         alert(title);    }    inner();}outter();아래 코드는 outter란 외부함수에 var title = ‘coding everyday’; 라는 지역변수를 만들었다. 그리고 내부함수로 inner을 만들었는데, 이때 이 내부함수 inner에 title이라는 변수를 사용하려고 하는데 이때 inner라는 함수에 지역변수가 존재하지 않는다면 Javascript는 이 inner라는 내부함수를 포함하고 있는 외부함수에서 title이라고하는 변수를 찾게된다. 즉, 내부함수에서 외부함수의 지역변수에 접근할 수 있다.이러한 것을 클로저(closure)라고 한다.function outter(){    var title = 'coding everybody';      function inner(){                alert(title);    }    inner();}outter();2. 클로저란?클로저(closure)는 내부함수와 밀접한 관계를 가지고 있는 주제다. 내부함수는 외부함수의 지역변수에 접근 할 수 있는데 외부함수의 실행이 끝나서 외부함수가 소멸된 이후에도 내부함수가 외부함수의 변수에 접근 할 수 있다. 이러한 메커니즘을 클로저라고 한다. 아래 예제는 이전의 예제를 조금 변형한 것이다. 내부함수inner를 outter함수내에서 호출하는 것이 아니라 반환하도록 했다. 함수 outter는 내부함수 inner를 반환하고 생을 마감했다. 즉, 함수 outter는 실행된 이후 실행이 종료되어 함수 ouuter의 변수 title또한 더이상 유효하지 않게되어 변수 title에 접근할수 없어 보인다. 그러나 아래 코드의 실행 결과는 경고창으로 coding everybody를 출력할 것이다. 이처럼 자신을 포함하고 있는 외부함수보다 내부함수가 더 오래 유지되는 경우, 외부함수 밖에서 내부함수가 호출되더라도 외부함수의 지역 변수에 접근할 수 있는데 이러한 함수를 클로저(closure)라고 부른다.function outter(){    var title = 'coding everybody';      return function(){                alert(title);    }}var inner = outter();inner();즉, 클로저는 반환된 내부함수가 자신이 선언됐을 때의 환경(Lexical environment)인 스코프를 기억하여 자신이 선언됐을 때의 환경(스코프) 밖에서 호출되어도 그 환경(스코프)에 접근할 수 있는 함수를 말한다. 이를 조금 더 간단히 말하면 클로저는 자신이 생성될 때의 환경(Lexical environment)을 기억하는 함수다라고 말할 수 있겠다.3. Private variable소프트웨어가 커지는 과정에서 어떠한 정보가 있을때 그 정보를 아무나 수정하는것을 방지하는 것을 Private variable이라 한다. 소프트웨어가 커지면 여러사람이 코드를 작성하게 된다. 그안에는 과거의 자기자신과 미래의 자기자신이 포함되게된다. 그런경우 많은 데이터가 소프트웨어 안에 존재하게 되는데 그 데이터가 누구나 고칠수있는 데이터가 된다는것은 그데이터가 망가질 가능성이 크다는 것이다. 그런 것을 방지하기 위해 접근하는 방법을 클로저를 사용하여 데이터를 가져오고 수정하는 것을 안전하게 하는것이다.아래는 factory_movie라는 외부함수가 get_title, set_title이라는 두 메소드에 함수를 지정한 객체를 담고있다. 이때 get_title, set_title은 내부 함수가 된다. get_title메소드를 호출하면 title이라는 값을 리턴하는데 그 title의 값은 factory_movie함수에 첫번째 인자이다. 첫번째 매개변수가 title이고 이 매개변수는 함수안에서 지역변수로 사용이 된다. 그렇기 때문에 factory_movie(title)은 지역변수이고 지역변수는 내부함수에서 접근이 가능하기 때문에 get_title을 호출하면 factory_movie의 첫번째 매개변수인 title이 값이 되기때문에 factory_movie함수의 (title)에 전달된 값을 리턴해준다. 그리고 set_title메소드는 첫번째 인자로 _title을 갖고 그리고 _title이라는 값은 다시 title이되고 그값은 내부변수를 의미하기때문에 factory_movie의 (title)을 변경하게 된다. 그다음 ghost와 matix라는 변수에 리턴값을 담았다. alert(ghost.get_title()); 는 ‘Ghost in the shell’을 출력하고, alert(matrix.get_title());는 ‘Matrix’를 출력한다. 이말은 ghost와 matix가 같은 객체를 담고 있지만 그 객체가 담고있는 get_title이라는 메소드가 접근하는 title이라고하는 외부변수에 담겨있는 값은 서로 다르다는 것이다. ghost.set_title(‘공각기동대’);는 ghost라는 변수 안에 set_title이라는 메소드를 호출하고 ‘공각기동대’ 를 인자로 사용하겠다는 말이다. ‘공각기동대는’ _title이되고 _title은 title이 되기 때문에 이 타이틀의 값은 factory_movie함수의 지역변수를 바꾸게 된다. alert(ghost.get_title());를 호출하게 되면 ‘공각기동대’를 출력하고, alert(matrix.get_title());를 호출하면 ‘Matrix’를 실행하게 된다. 즉, 우리가 factory_moviex통해 두개의 ghost와 matix변수를 만들었고, 그두개의 변수는 자신들이 실행된 그 시점에서의 외부함수의 지역변수에 접근할 수있었고 그지역변수의 값은 유지되고 있기때문에 ghost라는 함수에 set_title을 통해서 그내용을 ‘공각기동대’로 바꾼다 라는것은 ghost가 접근할수있는 title의 값만을 바꾸는것이지 matrix라는 변수가 접근할수 있는 title의 값에는 어떠한 영향도 미치지 않는다는 것이다.function factory_movie(title){    return {        get_title : function (){            return title;        },        set_title : function(_title){            title = _title        }    }}ghost = factory_movie('Ghost in the shell');matrix = factory_movie('Matrix'); alert(ghost.get_title());alert(matrix.get_title()); ghost.set_title('공각기동대'); alert(ghost.get_title());alert(matrix.get_title());이코드의 진짜 효용은 private variable이라는 것이다.  ghost와 matix변수에 객체를 담았다. 이객체의 get_title, set_title은 언제든지 접근할 수 있는 메소드이다. 누구나 접근할수 있다는 것이다. get_title, set_title이 내부적으로 사용하고 이있는 변수는 title이다. 이title은 외부 함수의 지역변수인 title이다.이지역변수인 title은 factory_movie라는 함수가 어떠한 값을 리턴했을때 factory_movie함수 자체는 실행이 끝났기 때문에 그지역변수인 title은 factory_movie의 내부함수인 get_title, set_title을 통해서만 접근할 수 있는 변수가 되는것이다. 즉, 우리가 title이라는 변수 값을 private variable로 만들고 그값을 수정할때는 set_titl을 통해서만 수정할 수 있고, 그변수의 값을 가져올때는 get_title를 통해서만 가져올 수 있게 하면 title이라는 변수가 안전하게 저장,수정될 수 있다는 것이다.4. 클로저의 응용클로저를 활용하는 것에서 실수하기 쉬운 예제를 보자. Javascript에서는 오로지 함수의 괄호 안에서만 지역변수로서 할당되고 그 외 모든 장소는 전역변수로 취급을 받는다. 우리가 예상하는 결과는 0,1,2,3,4 일것이다. 하지만 그렇지 않다. 첫번째 for문이 반복되는 동안 점점 증가되는 i의 값이 arr라는 배열에 저장될 것 같지만, 실제로 저장되는 것은 함수 그 자체이다. i는 반복이 끝난후 5라는 값이되고 return i 의 값은 5가된다. 그리고 다음 for in문에서 arr[index]는 해당 인덱스의 값으로서의 함수이고 ()를 붙였음으로 해당 함수가 호출된다. i 값은 첫번째 for문을 돌아 5가된 상태이기 때문에 5, 5, 5, 5, 5가 출력된다.var arr = []for(var i = 0; i &lt; 5; i++){    arr[i] = function(){        return i;    }}for(var index in arr) {    console.log(arr[index]());}그렇다면 정상출력 0, 1, 2, 3, 4을 얻기위해선 어떻게 해야할까? 위의 코드에서 달라진 점은 그전의 코드를 외부 함수로 감싸주어서 원래 함수는 내부 함수가 된다는 것아다. 그리고 외부 함수는 내부 함수를 값으로 반환하는데 그 자리에서 바로 그 외부 함수를 호출하기 때문에 내부 함수가 값으로서 반환되어 바로 변수에 할당이 된다.var arr = []for(var i = 0; i &lt; 5; i++){    arr[i] = function(id) {        return function(){            return id;        }    }(i);}for(var index in arr) {    console.log(arr[index]());}/* 결과01234*/위의 두 예제에서 첫번째 for문을 비교한 것이다.var arr = [];for(var i = 0; i &lt; 5; i++){  arr[i] = function(){    return i;  }}  arr[0] = function(){    return i;  }  arr[1] = function(){    return i;  }  arr[2] = function(){    return i;  }  arr[3] = function(){    return i;  }  arr[4] = function(){    return i;  }for(var i = 0 ; i &lt; 5; i++){  arr[i] = function(id){  //외부함수.    return function(){    //내부함수.      return id;    }  }(i);  //외부함수 호출}  arr[0] = function(){      return 0;  }  arr[1] = function(){      return 1;  }  arr[2] = function(){      return 2;  }  arr[3] = function(){      return 3;  }  arr[4] = function(){      return 4;  }",
        "url": "/javascript-basic14"
    }
    ,
    
    "javascript-basic13": {
        "title": "Javascript - JavaScript 함수지향 - 값으로서의 함수와 콜백",
            "author": "AhnSang0915",
            "category": "",
            "content": "Javascript    JavaScript 기본     JavaScript 숫자와 문자     JavaScript 변수, 비교    JavaScript 조건문    JavaScript 반복문    JavaScript 함수    JavaScript 배열    JavaScript 객체(Object)    JavaScript 모듈    JavaScript UI와 API    JavaScript 정규표현식    JavaScript 함수지향 - 유효범위    JavaScript 함수지향 - 값으로서의 함수와 콜백    JavaScript 함수지향 - 클로저    JavaScript 함수지향 - arguments    함수지향 - 함수의 호출    객체지향 - 객체지향 프로그래밍 소개    객체지향 - 생성자와 new    객체지향 - 전역객체    객체지향 - this    객체지향 - 상속    객체지향-표준 내장객체의 확장    JavaScript 객체지향-ObjectJavaScript 함수지향 - 값으로서의 함수와 콜백1. 값으로서의 함수Javascript에서는 함수도 객체이다. 함수를 일단 값이라고 생각하자. 값의 특징은 어떠한 변수에 담을수 있다. var a = “value” a라는 변수에 값으로 value를 넣은것이다. 함수가 일종의 값이라는 것은 함수 역시 어떤 변수에 담을수 있다는 것이다. Javascript의 함수가 다른 언어의 함수와 다른 점은 함수가 값이 될 수 있다는 점이다. 예제를 보자.\tfunction a(){} // var a = function () {}위 예제에서 a라고하는 함수를 정의했다. 위처럼 함수를 정의하는 것은 a라고하는 변수에 담겨진 값이라는 것이다. 아래 예제에선 객체에 변수를 담았다. a라는 객체에 b라는 key와 function(){}이란 value를 담은것이다. 이처럼 객체 안에 함수를 담게되면 함수는 값이기 때문에 b는 객체안에서 변수와 같은 역할을 하고있다. 객체안에서 변수의 역할을 하는것을 속성(Property)라고 하고 그 속성에 저장된 값이 함수라면 그함수는 이러한 맥락에선 메소드(method)라고 한다.a = {    b:function(){    }};또한 함수는 값이기 때문에 다른 함수의 인자로 전달 될수도 있다. increase는 num이라는 매개변수에 +1을해 리턴, decrease는 -1알한 값을 리턴해준다. cal이라는 함수는 func, num이라는 매개변수를 갖고있고 func의 함수에 num이라는 값을 호출하고있다. alert(cal(increase, 1));을 하게되면 cal의 매개변수가 increase, 1이 인자가 된다. 즉, increase라는 함수에 1이라는 인자가 전달되기 때문에 2가된다.function cal(func, num){    return func(num)}function increase(num){    return num+1}function decrease(num){    return num-1}alert(cal(increase, 1));alert(cal(decrease, 1));2. 값으로서의 함수와 콜백 - 함수의 용도2함수는 함수의 리턴 값으로도 사용할 수 있다. 아래 코드를 보자. cal라는 함수를 호출할때 첫번째 인자로 ‘plus’ 라는값을 주면 객체를 담고있는 함수에 ‘plus’라는 인자가 들어가게 되고 function cal(‘plus’), return funcs(‘plus’)가 된다. alert(cal(‘plus’) (2, 1))에서 (cal(‘plus’)는 function(left, right){return left + right} 이부분이 되고, alert(cal(‘plus’) (2, 1)) 에서 (2, 1)은 함수를 호출하겠다는 말이고 인자로 2, 1을 전달하겠다는 것이다. 결과는 3이된다.function cal(mode){    var funcs = {        'plus' : function(left, right){return left + right},        'minus' : function(left, right){return left - right}    }    return funcs[mode];}alert(cal('plus')(2,1));alert(cal('minus')(2,1));당연히 배열의 값으로도 사용할 수 있다. process라는 배열을 정의했고 배열안의 요소 3개가 모두 함수이다. for반복문에서  i = 0 일때 process라는 배열의 index 0의 요소의 함수를 호출하고 첫번째 인자로 1을 전달한다. 이후 input의 값은 11이되고 index 다시 반복문으로 돌아와 1의 요소의 함수를 호출하게 된다. 이때 input의 값은 배열의 첫번쨰 요소에서 얻은 11이 된다. 값은 121이 되고 이 값은 다시 input의 값이 된다. 이후배열의 세번째 요소로 121의 값이 전달되고 60.5의 결과가 나온다.var process = [    function(input){ return input + 10;},    function(input){ return input * input;},    function(input){ return input / 2;}];var input = 1;for(var i = 0; i &lt; process.length; i++){    input = process[i](input);}alert(input);3. 값으로서의 함수와 콜백 - 콜백이란?콜백은 어떠한 함수가 수신하는 인자가 함수인 경우를 콜백이라고 한다. 처리의 위임값으로 사용될 수 있는 특성을 이용하면 함수의 인자로 함수로 전달할 수 있다. 값으로 전달된 함수는 호출될 수 있기 때문에 이를 이용하면 함수의 동작을 완전히 바꿀 수 있다. 인자로 전달된 함수 sortNumber의 구현에 따라서 sort의 동작방법이 완전히 바뀌게 된다.아래 예제에서 배열의 내용을 정렬하려면 numbers.sort();라는 명령을 내리는 것이다. 여기서 .앞의 numbers는 배열객체가 되고 우리가 아래처럼 [20, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1]를 작성해 Javascript에 제출을하면 배열객체를 만들어 numbers라고하는 변수에 담아준다. 그리고 배열객체에는 sort라고하는 함수가 정의되어 있기때문에 numbers.sort();를 통해서 배열이 가지고있는 명령어 sort를 호출하게 되는데 여기서 sort는 함수라고 하지않고 객체에 속해있기 때문에 메소드라고 한다. 이러한 numbers객체 또는 sort메소드는 Javascript에서 기본적으로 제공하는 기능이기 때문에 이러한 기능을 내장 객체 내장 메소드, 또는 빌트인 객체 빌트인 메소드라고 한다. 그리고 우리가 만드는 객체나 메소드, 함수같은 것들은 우리가 만드는 것이기 때문에 사용자정의 객체, 사용자정의 메소드 라고한다.&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;script src=\"//code.jquery.com/jquery-1.11.0.min.js\"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;script type=\"text/javascript\"&gt;    var numbers = [20, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1];    numbers.sort(); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;위의 코드를 실행하면 배열안의 내용을 정렬해주고 결과는 [1, 10, 2, 20, 3, 4, 5, 6, 7, 8, 9] 가 출력된다. 이유는 숫작의 크기로 비교한게 아니고 문자로 비교를 했기 때문이다. 앞의 숫자가 1인것들이 우선순위를 갖고 나머지를 정렬했기 때문이다. 우리가 원하는 결과를 얻기 위해선 아래의 방법을 이용해야 한다.&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;script src=\"//code.jquery.com/jquery-1.11.0.min.js\"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;script type=\"text/javascript\"&gt;    var numbers = [20, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1];    var sortfunc = function(a, b) {        console.log(a, b);        if(a &gt; b) {            return 1;        } else if (a&gt;b){            return -1;        } else {            return 0;        }    }    console.log(numbers.sort(sortfunc)); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;위의 코드를 단순하게 하면 아래처럼 된다. 아래의 함수에서 sortfunc가 콜백함수가 되고 콜백 함수 라는것은 콜백함수를 수신받는 sort메소드가 sortfunc를 인자로 전달받아 내부적으로 호출하는 것을 통해서 sort함수가 동작하는 기본적인 동작방법을 변경할수 있게 된다. 즉, 값으로서 함수를 사용할수 있기때문에 함수의 동작방법을 값을 전달하는 것을 통해 바꿀수 있는게 콜백 이다. 그리고 콜백이 가능한 것은 Javascript의 함수가 값이기 때문에 가능한 것이다.&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;script src=\"//code.jquery.com/jquery-1.11.0.min.js\"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;script type=\"text/javascript\"&gt;    var numbers = [20, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1];    var sortfunc = function(a, b) {        return a-b; // 역순 b-a     }    console.log(numbers.sort(sortfunc)); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;4. 비동기 콜백과  Ajax예를 들어 우리가 홈페이지를 운영하는데 만명정도의 구독자가 있다고 치자. 우리가 글을쓰면 만명에게 메일이 전송되게 되어있다. 한명에게 메일을 보내는데 1초가 걸리면 만명에게 보내는데에는 만초가 걸리게 된다. 글을 작성하고 이메일을 전송후 작성완료까지 3시간을 기다려야 한다면 이런 서비스를 사용하기는 힘들것이다.이렇게 순서대로 실행하는 것을 동기적 처리라고한다. 그런데 우리가 글작성을하고 이메일을 발송하지 않고 발송 예약후 작성완료를 하게 되면 시간이 훨씬 줄어들게 된다. 그리고 내부적으로 사용자에게 노출되지 않는 프로그램이 작동하면서 이메일 발송예약이 들어와 있는지 아닌지를 확인해 들어와있다면 프로그램이 만명에게 이메일 발송하는 작업을 3시간동안 백그라운드에서 진행하면 될것이다. 이렇게 처리하는 방식을 비동기적인 처리라고한다. 우리는 이 비동기적 처리를 Ajax(Asynchronous javascript and xml) 로 사용할 수 있다.우리가 아래와 같은 객체를 만든 파일을 만들었다고 가정하고 예제를 보자.{\"title\":\"JavaScript\",\"author\":\"egoing\"}생활코딩의 동영상을 보고 이해하는것이 좋겠다…(아직 이해못함.)&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;script src=\"//code.jquery.com/jquery-1.11.0.min.js\"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;script type=\"text/javascript\"&gt;    $.get('./datasource.json.js', function(result){ //$는 jquery가 제공하는 특수한 객체이다. 여기에 get이라는 메소드를 사용해 json타입 파일을 호출하는 것이다.        console.log(result);    }, 'json');&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;",
        "url": "/javascript-basic13"
    }
    ,
    
    "javascript-basic12": {
        "title": "Javascript - JavaScript 함수지향 - 유효범위",
            "author": "AhnSang0915",
            "category": "",
            "content": "Javascript    JavaScript 기본     JavaScript 숫자와 문자     JavaScript 변수, 비교    JavaScript 조건문    JavaScript 반복문    JavaScript 함수    JavaScript 배열    JavaScript 객체(Object)    JavaScript 모듈    JavaScript UI와 API    JavaScript 정규표현식    JavaScript 함수지향 - 유효범위    JavaScript 함수지향 - 값으로서의 함수와 콜백    JavaScript 함수지향 - 클로저    JavaScript 함수지향 - arguments    함수지향 - 함수의 호출    객체지향 - 객체지향 프로그래밍 소개    객체지향 - 생성자와 new    객체지향 - 전역객체    객체지향 - this    객체지향 - 상속    객체지향-표준 내장객체의 확장    JavaScript 객체지향-ObjectJavaScript 함수지향 - 유효범위1. 전역변수와 지역변수유효범위(Scope)는 변수의 수명을 의미한다. 아래의 예제를 보자. vscope라는 변수에 global이라는 데이터를 할당했다. fscope라는 함수는 함수 안에 선언되어 있지 않은, 함수 바깥쪽에 선언되어있는 vscope에 접근할 수 있다. 결과는 global이다.var vscope = 'global';function fscope(){    alert(vscope);}fscope();아래를 실행하게 되면 결과는 ‘함수안 local’과 ‘함수밖 global’이 출력된다. fscope 함수안에 vscope라는 변수가 할당되어 있기 때문에 vscope는 자기자신과 가까이에 있는 vscope를 가르키기 때문에 ‘local’이라는 값을 출력하게 된다. 함수안의 fscope 함수안에 정의 되어 있는 vscope는 지역변수(local variables) 이고, 함수밖에  정의되어 있는 vscope변수는 전역변수(global variables)라고 한다.즉 지역변수의 유효범위는 함수 안이고, 전역변수의 유효범위는 에플리케이션 전역인데, 같은 이름의 지역변수와 전역변수가 동시에 정의되어 있다면 지역변수가 우선한다는 것을 알 수 있다.var vscope = 'global';function fscope(){    var vscope = 'local';    alert('함수안 '+vscope);}fscope();alert('함수밖 '+vscope);var을 쓴것과 쓰지않은것의 차이점을 알아보자. var을쓰면 전역변수를 호출하게되고 var을 쓰지않으면 vscope가 지역변수가 되어 global을 local로 변경하게된다. 즉,  var을 사용하지 않은 지역변수는 전역변수가 된다. fscope라는 함수에 var쓰고 변수를 지정하게 되면 fscope함수에 지역변수를 지정한것이다. 그렇기 때문에 전역 변수의 값이 local로 변경 된 것이다. 그렇기 때문에 출력은 local이 되게 된다.var vscope = 'global';function fscope(){    var vscope = 'local';   }fscope();alert(vscope);// var을 쓸때 global// var을 쓰지 않을때 local아래 예제는 어떻게 될까? 마찬가지로 global을 출력하게 된다. 이유는 이미 var vscope으로 인해 지역변수가 생성이되었다. 그렇기 때문에 vscope를 사용해도 지역변수가 되는것이지 전역변수가 변경되지는 않는다.var vscope = 'global';function fscope(){    var vscope = 'local';    vscope = 'local';   }fscope();alert(vscope);// global2. 유효범위의 효용아래 두개의 예제는 변수 i를 지역변수로 사용했을 때와 전역변수로 사용했을 때의 차이점을 보여준다. 전역변수는 각기 다른 로직에서 사용하는 같은 이름의 변수값을 변경시켜서 의도하지 않은 문제를 발생시킨다.같은 이름을 사용했지만 var을 사용하는것과 사용하지 않는것의 차이가 있다. for문 안에들어있는 i의 값이 선언된것은 어떤 함수에 소속되지 않은 것이다. 그렇기 때문에 전역변수이고 함수 a를 호출하게 되면 변수 i의 값을 0으로 바꿔주고 있다. 그런데 var을 붙이지 않은것은 전역변수를 의미하게 된다. a함수와 for문이 가르키고 있는 i가 같기때문에 a가 실행될때마다 i의값이 매번 0으로 초기화된다. 따라서 무한반복하는 현상이 나타나고 같은이름의 변수를 중복해서 사용했지만 각각의 취지가 다를 때 이런현상이 일어난다.function a (){    var i = 0; //결과 01234    // i=0; // 결과 무한반복}for(var i = 0; i &lt; 5; i++){    a();    document.write(i);}3. 전역변수를 사용하는 법불가피하게 전역변수를 사용해야 하는 경우는 하나의 객체를 전역변수로 만들고 객체의 속성으로 변수를 관리하는 방법을 사용한다.아래의 예제는 MYAPP이라는 전역변수 하나를 만들어서 속성을 지정해 만들었다. 이처럼 전역변수 하나만을 만들고 나머지 다른 전역변수들은 바로 그 전역변수의 소속에 해당되게 만들면 변수의 이름이 충돌할 가능성이 낮아진다.var MYAPP = {}MYAPP.calculator = { //calculator 속성    'left' : null,    'right' : null}MYAPP.coordinate = {    'left' : null,    'right' : null} MYAPP.calculator.left = 10;MYAPP.calculator.right = 20;function sum(){    return MYAPP.calculator.left + MYAPP.calculator.right;}document.write(sum());아래의 예제는 함수안에 변수를 지정해 함수의 지역변수로 만들었다. 함수를 정의하고 바로 호출하는 기법을 익명함수라고 한다. 이러한 기법을 이용해 전역변수가 하나도 존재하지않는 방식을 사용할 수도있다.(function(){    var MYAPP = {}    MYAPP.calculator = {        'left' : null,        'right' : null    }    MYAPP.coordinate = {        'left' : null,        'right' : null    }    MYAPP.calculator.left = 10;    MYAPP.calculator.right = 20;    function sum(){        return MYAPP.calculator.left + MYAPP.calculator.right;    }    document.write(sum());}())4. 유효범위의 대상Javascript는 함수에 대한 유효범위만을 제공한다. 다시말해 Javascript 에선 for문이나 if문에서 중괄호 안에서 선언된 변수는 지역변수로서의 의미를 갖지 않는다. 많은 언어들이 블록(대체로 {,})에 대한 유효범위를 제공하는 것과 다른 점이다. 아래 예제의 결과는 coding everybody이다.for(var i = 0; i &lt; 1; i++){    var name = 'coding everybody';}alert(name);자바에서는 아래의 코드는 허용되지 않는다. name은 지역변수로 for 문 안에서 선언 되었는데 이를 for문 밖에서 호출하고 있기 때문이다.for(int i = 0; i &lt; 10; i++){    String name = \"egoing\";}System.out.println(name);5. 정적 유효범위자바스크립트는 함수가 선언된 시점에서의 유효범위를 갖는다. 이러한 유효범위의 방식을 정적 유효범위(static scoping), 혹은 렉시컬(lexical scoping)이라고 한다. 이는 이후에 살펴볼 클로저와 연관되어 있다.전역변수 var i = 5가 정의되어 있고 a 함수는 var i = 10이라는 지역변수를 정의하고 있다. a라고 하는 함수를 호출했을 때 함수의 내부적으로 i의 값이 10이 된다. 그 상태에서 b를 호출하게 되면 i는 b 함수 안에 i라고 하는 지역변수가 존재하는지 찾게 된다. 없다면 전역변수를 찾게 되는데 b를 호출하고 있는 함수는 a이다.그렇다면 a 함수에 정의된 변수 a를 호출하게 될까? 아니다. 왜냐하면, 함수 b가 선언된 시점에서 i의 전역변수가 사용되는 것이지 b가 호출된 시점에서 b가 담겨있는 함수의 지역변수가 사용되는 것이 아니다. 즉, 사용될 때 가 아니고 정의 될 때의 전역변수가 사용되게 된다는 말이다. 이러한 것을 정적 유효범위 또는 렉시컬(lexical scoping)유효범위라고 한다.var i = 5; // 전역변수 function a(){    var i = 10; // 지역변수    b();} function b(){    document.write(i);} a(); // 5",
        "url": "/javascript-basic12"
    }
    ,
    
    "javascript-basic11": {
        "title": "Javascript - JavaScript 정규표현식",
            "author": "AhnSang0915",
            "category": "",
            "content": "Javascript    JavaScript 기본     JavaScript 숫자와 문자     JavaScript 변수, 비교    JavaScript 조건문    JavaScript 반복문    JavaScript 함수    JavaScript 배열    JavaScript 객체(Object)    JavaScript 모듈    JavaScript UI와 API    JavaScript 정규표현식    JavaScript 함수지향 - 유효범위    JavaScript 함수지향 - 값으로서의 함수와 콜백    JavaScript 함수지향 - 클로저    JavaScript 함수지향 - arguments    함수지향 - 함수의 호출    객체지향 - 객체지향 프로그래밍 소개    객체지향 - 생성자와 new    객체지향 - 전역객체    객체지향 - this    객체지향 - 상속    객체지향-표준 내장객체의 확장    JavaScript 객체지향-ObjectJavaScript 정규표현식정규표현식(Reguler expression)은 문자열 안에서 어떠한 문자가 있는지 없는지, 그문자를 다른 문자로 치환하는 것들을 도와주는 방법이다. 정보와 관련된 언어에서는 정규표현식이 매우 중요하다. 정규표현식의 공부는 양이 많아 따로 해야한다 링크를 통해 공부하고 아래내용을 보는게 좋겠다.1. 패턴만들기정규 표현식은 두가지 사용방법으로 이루어진다. 하나는 컴파일(compile) 다른 하나는 실행(execution)이다. 우선 컴파일부터 알아보자. 우리가 문자열을 변수에 담을때 var str = “a”; 의 식으로 하게된다. 마찬가지로 우리가 정규표현식을 만들때 정규표현식 리터럴이라는것을 이용해 만든다.//정규표현식 리터럴var pattern = /a/;또하나의 방법은 정규표현식 객체 생성자를 사용하는 방법이다. 두방법 모두 정규표현식 객체를 pattern이라는 변수에 담은것이다. 우리가 찾고자하는 정보를 pattern이라는 변수에 저장을 한것이다.var pattern = new RegExp('a');2. RegExp객체의 사용우리가 어떤일을 할때 두가지 방법이 있다. 작업을 할 대상을 선택하고 그리고 그대상에 대하 어떤작업을 할지 정한다. 먼저 해야할 것은 작업할 대상을 찾는것이다. 이작업을 할수 있게 해주는게 정규표현식이다.정규표현식 메소드 실행정규표현식을 컴파일해서 객체를 만들었다면 이제 문자열에서 원하는 문자를 찾아내야 한다.RegExp.exec()문자열 a를 찾고싶다고할때 pattern변수안에 정규표현식 a를 지정하고 RegExp.exec()로 실행을 시킬수 있다.RegExp는 정규표현식을 의미하고 exec는 실행을 의미한다. 즉, 우리가 지정한 정규표현식을 실행하는데 그실행의 대상을 첫번째 인자로 전달하고, 그정보가 있는지 없는지 찾으려고 하는 정보가 (‘abcdef’) 이고 이것이 두번째 인자가 된다. 실행결과는 문자열 a를 값으로 하는 배열을 리턴한다.var pattern = /a/;console.log(pattern.exec('abcdef')); // [\"a\"]이번엔 변수에 정규표현식 a.을 담았다. 결과는 ab가되는데 이것은 정규표현식에서 .이 문자 1개를 의미하기 때문이다.var pattern = /a./;console.log(pattern.exec('abcdef')); // [\"ab\"]인자 ‘bcdef’에는 a가 없기 때문에 null을 리턴한다.var pattern = /a/;console.log(pattern.exec('bcdefg')); // nullRegExp.test()우리가 필요한 정보를 추출해내야 할때 사용한다. 우리가 찾는 어떤 정보가 있는지 없는지를 존재 유무를 테스트 한다.test는 인자 안에 패턴에 해당되는 문자열이 있으면 true, 없으면 false를 리턴한다var pattern = /a/;console.log(pattern.test('abcdef')); // truecnosole.log(pattern.test('bcdefg')); // false3. String과 정규표현식String.match()RegExp.exec()와 비슷하다.var pattern = /a/;console.log('abcdef'.match(pattern)); // [\"a\"]console.log('bcdefg'.match(pattern)); // nullString.replace()String.replace()는 문자열에서 패턴을 검색해서 이를 변경한 후에 변경된 값을 리턴한다.pattern a를 찾아 A로 치환해주었다.console.log('abcdef'.replace(pattern, 'A'));  // Abcdef4. 옵션(i, g)정규표현식 패턴을 만들 때 옵션을 설정할수있다. 찾고자하는 값 뒤에 옵션을 넣어주면 되고, 옵션에 따라 검출되는 데이터가 달라진다.i는 대소문자 구분을 없애주는 역할을 한다.var xi = /a/;console.log(\"Abcde\".match(xi)); // nullvar oi = /a/i;console.log(\"Abcde\".match(oi)); // [\"A\"];g는 문자열에 포함되어 있는 패턴에 해당되는 문자열들을 모두 리턴해준다.var xg = /a/;console.log(\"abcdea\".match(xg)); // [\"a\"]var og = /a/g;console.log(\"abcdea\".match(og)); // [\"a\",\"a\"]두가지 모두 사용도 가능하다.var og = /a/ig;console.log(\"AabcdAa\".match(ig)); // [\"A\",\"a\",\"A\",\"a\"]5. 캡쳐그룹을 지정하고 지정된 그룹을 가져와 사용하는 기능, 또는 사용할 수 있는 개념을 캡쳐라고 부른다.var pattern = /(\\w+)\\s(\\w+)/; // 문자열 공백 문자열var str = \"coding everybody\"; //coding$1 everybody$2var result = str.replace(pattern, \"$2, $1\"); //$2,(공백)$1로 치환.console.log(result);//everybody, coding6. 치환아래 코드는 본문 중의 URL을 링크 html 태그로 교체한다. \\b는 단어를 식별한다. ?:로 https를 캡쳐로 지정하지 않고 뒤에 ?로 https, http가 모두 해당되게 했다. 뒤에 //는 escape를 사용해 문자화 시켰고 그뒤의 a-z는 a부터 z까지 0-9 는 0에서 9까지 그리고 그뒤에 주소에 들어갈만한 특수문자들 까지 해당되게 해줬다. 그리고 replace라는 메소드가 실행될때 urlPattern해당되는 텍스트를 찾을때마다 두번째인자로 전달된 함수가 replace라는 메소드 내부로 호출된다. 호출될때 javascript는 호출된 시점에서 검색된 문자열을 첫번째 인자(url)로 전달되게 약속되어있다. 그리고 그 텍스트를 가공을하고 리턴을 해주면 우리가 변경하고싶은 내용으로 변경되게 된다.var urlPattern = /\\b(?:https?):\\/\\/[a-z0-9-+&amp;@#\\/%?=~_|!:,.;]*/gim;var content = '생활코딩 : http://opentutorials.org/course/1 입니다. 네이버 : http://naver.com 입니다. ';var result = content.replace(urlPattern, function(url){    return '&lt;a href=\"'+url+'\"&gt;'+url+'&lt;/a&gt;';});console.log(result);//생활코딩 : &lt;a href=\"http://opentutorials.org/course/1\"&gt;http://opentutorials.org/course/1&lt;/a&gt; 입니다. 네이버 : &lt;a href=\"http://naver.com\"&gt;http://naver.com&lt;/a&gt; 입니다.",
        "url": "/javascript-basic11"
    }
    ,
    
    "javascript-basic10": {
        "title": "Javascript - JavaScript UI와 API",
            "author": "AhnSang0915",
            "category": "",
            "content": "Javascript    JavaScript 기본     JavaScript 숫자와 문자     JavaScript 변수, 비교    JavaScript 조건문    JavaScript 반복문    JavaScript 함수    JavaScript 배열    JavaScript 객체(Object)    JavaScript 모듈    JavaScript UI와 API    JavaScript 정규표현식    JavaScript 함수지향 - 유효범위    JavaScript 함수지향 - 값으로서의 함수와 콜백    JavaScript 함수지향 - 클로저    JavaScript 함수지향 - arguments    함수지향 - 함수의 호출    객체지향 - 객체지향 프로그래밍 소개    객체지향 - 생성자와 new    객체지향 - 전역객체    객체지향 - this    객체지향 - 상속    객체지향-표준 내장객체의 확장    JavaScript 객체지향-ObjectJavaScript UI와 API1. UI란?UI(User Interface)는 컴퓨터의 시스템과 사용자의 접점에 존재하며 중개자에 해당하는 것을 UI라고 한다. 사용자를 대면하는 접점을 하는 지점을 UI라고하고 물리적, 하드웨어적 UI가 있고 소프트웨어적 UI가 있다. 노트북이나 키보드에 있는 버튼이 하드웨어적 UI라 할수있고 브라우저의 각종 버튼이 소프트웨어적 UI라 할수 있겠다.2. API란?API란 Application Programming Interface의 약자로 프로그램이 동작하는 환경을 제어하기 위해서 환경에서 제공되는 조작 장치이다. 이 조작 장치는 프로그래밍 언어를 통해서 조작할 수 있다. 일반 사용자는 UI를 사용해 원하는 결과를 얻고 개발자는 API를 이용해 자신이 하고자하는 프로그래밍을 하게된다.Javascript의 APIJavascript의 API는 크게 Javascript 자체의 API와 Javascript가 동작하는 호스트 환경의 API로 구분된다. 현재 우리가 공부하는건 Javascript자체의 API이고 앞으로 나아가 더 공부를 하게되면 호스트 환경에서의 API도 공부해야한다.Javascript API 문서Javascript가 제공하는 기본적인 API를 볼수있는 사이트이다. 여기서 필요한 API를 찾아 사용하면 된다.  ECMAScript.  Javascript사전.  Javascript 레퍼런스 MDN.  jscript 레퍼런스.호스트 환경의 API 문서호스트 환경에서의 API를 볼수있는 사이트이다. 지금 우리는 기본적인 Javascript의 API를 공부하고 있어 당장은 필요하지 않지만 앞으로 심화과정에 들어가면 사용할 일이 있을것이다.  웹브라우저 API.  Node.js API.  Google Apps Script API.",
        "url": "/javascript-basic10"
    }
    ,
    
    "javascript-basic9": {
        "title": "Javascript - JavaScript 모듈",
            "author": "AhnSang0915",
            "category": "",
            "content": "Javascript    JavaScript 기본     JavaScript 숫자와 문자     JavaScript 변수, 비교    JavaScript 조건문    JavaScript 반복문    JavaScript 함수    JavaScript 배열    JavaScript 객체(Object)    JavaScript 모듈    JavaScript UI와 API    JavaScript 정규표현식    JavaScript 함수지향 - 유효범위    JavaScript 함수지향 - 값으로서의 함수와 콜백    JavaScript 함수지향 - 클로저    JavaScript 함수지향 - arguments    함수지향 - 함수의 호출    객체지향 - 객체지향 프로그래밍 소개    객체지향 - 생성자와 new    객체지향 - 전역객체    객체지향 - this    객체지향 - 상속    객체지향-표준 내장객체의 확장    JavaScript 객체지향-ObjectJavaScript 모듈1. 모듈이란?프로그램은 작고 단순한 것에서 크고 복잡한 것으로 진화한다. 이과정에 필요한 것은 코드의 재활용성, 유지보수의 편의성등이 있다. 어떤 프로그램을 구성하고 있는 수만은 로직들을 재사용 할 수 있는 단위로 조각조각 나누어 구획화를 시켜 별도의 모듈이라는 형태로 떼어내 이것을 또다른 프로그램의 부품으로 사용하는 기법, 그런 부품들을 모듈이라 하고 이러한 기법을 모듈화 라고 한다. 아래는 모듈화를 통해 얻을 수 있는 효과이다.  자주 사용되는 코드를 별도의 파일로 만들어서 필요할 때마다 재활용할 수 있다.  코드를 개선하면 이를 사용하고 있는 모든 애플리케이션의 동작이 개선된다.  코드 수정 시에 필요한 로직을 빠르게 찾을 수 있다.  필요한 로직만을 로드해서 메모리의 낭비를 줄일 수 있다.  한번 다운로드된 모듈은 웹브라우저에 의해서 저장되기 때문에 동일한 로직을 로드 할 때 시간과 네트워크 트래픽을 절약 할 수 있다. (브라우저에서만 해당)Javascript에서는 모듈이라는 개념이 분명하게 존재하지 않는다. Javascript에서는 모듈이라는 기능 자체를 제공하지 않는다. 구동 환경(호스트 환경)에 따라서 Javascript로직 구성을 모듈형식으로 구성해 사용한다.2.모듈화모듈화를 알기 전에 모듈이 없다는 가정을 해보자. 그리고 funcion함수가 엄청 복잡하다고 가정하고, 함수 호출도 여러번하며 html파일이 아래 welcome이라는 함수를 여러 html에서 호출한다고 생각해보자. 그렇다면 welcome이라는 함수를 해당 페이지에 두는것은 덩치가 엄청 커질것이다. 이런경우 내가 필요한 코드와 그렇지 않은 코드를 분류하는게 힘들어 질 것이다. welcome이라는 함수를 별도의 파일로 빼고 그 별도의 파일을 읽어 오는것을 통해 welcome이라는 함수를 사용할 수 있다면 복잡한 코드가 한줄로 바뀔 수 있다.&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;    &lt;meta charset=\"utf-8\"/&gt;&lt;/head&gt;&lt;body&gt;    &lt;script&gt;        function welcome(){            return 'Hello world'        }        alert(welcome());    &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;아래 예제에서 별도의 파일로 js를 불러오는 형식을 알아보자. 아래 내용을 코드를 에디터를 활용해 실행해보자. greeting.js 라는 파일에 위 예제에서 사용한 function함수를 저장하고 불러오는 형식이다.&lt;script type=”text/javascript” src=”greeting.js”&gt;&lt;/script&gt; 그다음 welcom함수를 호출하면 greeting.js파일에서 불러오게 된다. 다른 html파일에서도 마찬가지로 위 코드로 불러와 함수를 사용할 수 있다.&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;    &lt;meta charset=\"utf-8\"/&gt;    &lt;script type=\"text/javascript\" src=\"greeting.js\"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;    &lt;script&gt;        alert(welcome());    &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;3.node.js의 모듈화모듈을 로드하는 방법은 호스트 환경에 따라서 달라진다. Node.js에서는 아래와 같은 방법으로 모듈을 로드한다.var PI = Math.PI;  exports.area = function (r) {return PI * r * r;};  exports.circumference = function (r) {return 2 * PI * r;};var circle = require('./node.circle.js');console.log( 'The area of a circle of radius 4 is '           + circle.area(4));4.라이브러리라이브러리는 자주 사용되는 로직을 재사용되기 편리하도록 잘 정리한 일련의 코드들의 집힘을 의미한다고 할 수 있다. 오픈 소스를 통해 만들어진 수많은 라이브러리가 있기 때문에 우리가 만들고자 하는 프로그래밍의 핵심적인 부분이 아니라면 공개되어있는 좋은 라이브러리를 선택하고 잘 사용하는 것은 프로그래밍의 핵심이라고 할 수 있다. Javascript로 웹 브라우저를 제어하는 방법은 기본적으로 웹 브라우저가 제공하는 기능, Javascript가 제공하는 기능을 이용해 모든 것을 다 할 수 있다. 다르게 말하면 웹 브라우저와 Javascript가 제공하지 않는 기능은 전혀 사용할 수 없다. 왜냐하면, 브라우저가 허용하는 기능만을 쓸 수 있기 때문이다. 브라우저의 기능이 너무 다양하고 파편화되어 있기 때문에 라이브러리를 사용한다. 라이브러리는 어떤 목적을 정해놓고 목적을 쉽게 달성할 수 있게 만들어놓은 프로그래밍의 집합이기 때문이다. 우리가 사용해볼 라이브러리는 query다.5. 라이브러리 사용하기jQuery를 이용한 예제와 사용방법을 알아볼 것이다. 하지만 jQuery에 대한 공부를 하는것 보다 어떻게 사용하는지에 대한 예제 이기 때문에 jQuery강의를 보고 공부를 해야한다. 아래 코드list에있는 empty를 한번에 coding paratice gym으로 바꾸는 예제이다. 아래의 상태에서&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt;    &lt;meta charset=\"UTF-8\"&gt;    &lt;meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\"&gt;    &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt;    &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt;    &lt;ul id=\"list\"&gt;        &lt;li&gt;empty&lt;/li&gt;        &lt;li&gt;empty&lt;/li&gt;        &lt;li&gt;empty&lt;/li&gt;        &lt;li&gt;empty&lt;/li&gt;    &lt;/ul&gt;&lt;/body&gt;&lt;/html&gt;아래 예제 처럼 변경해준다. 아래 jQuery를 사용한 3줄의 코드로 작업을 수행하게 되었다.&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt;    &lt;meta charset=\"UTF-8\"&gt;    &lt;meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\"&gt;    &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt;    &lt;title&gt;Document&lt;/title&gt;    &lt;script type=\"text/javascript\" src=\"./jquery.js\" &gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;    &lt;ul id=\"list\"&gt;        &lt;li&gt;empty&lt;/li&gt;        &lt;li&gt;empty&lt;/li&gt;        &lt;li&gt;empty&lt;/li&gt;        &lt;li&gt;empty&lt;/li&gt;    &lt;/ul&gt;    &lt;input type=\"button\" value=\"execute\" id=\"execute_btn\"/&gt;    &lt;script type=\"text/javascript\"&gt;        $('#execute_btn').click(function(){            $('#list li').text('coding practice gym');        });    &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;하지만 jQuery를 사용하지 않으면 아래 예제처럼 쉽지않은 프로그래밍을 해야한다.&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;body&gt;    &lt;ul id=\"list\"&gt;        &lt;li&gt;empty&lt;/li&gt;        &lt;li&gt;empty&lt;/li&gt;        &lt;li&gt;empty&lt;/li&gt;        &lt;li&gt;empty&lt;/li&gt;    &lt;/ul&gt;    &lt;input id=\"execute_btn\" type=\"button\" value=\"execute\" /&gt;    &lt;script type=\"text/javascript\"&gt;    function addEvent(target, eventType,eventHandler, useCapture) {        if (target.addEventListener) { // W3C DOM            target.addEventListener(eventType,eventHandler,useCapture?useCapture:false);        } else if (target.attachEvent) {  // IE DOM            var r = target.attachEvent(\"on\"+eventType, eventHandler);        }    }    function clickHandler(event) {        var nav = document.getElementById('list');        for(var i = 0; i &lt; nav.childNodes.length; i++) {            var child = nav.childNodes[i];            if(child.nodeType==3)                continue;            child.innerText = 'Coding everybody';        }    }    addEvent(document.getElementById('execute_btn'), 'click', clickHandler);    &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;이번 강의에선 라이브러리가 중요하다는 것을 알아야 한다. 세세하게 어떻게 하는지 알려고 하는 것보단 라이브러리의 장점과 편의성에 초점을 맞추고 이후 나오는 내용에서 자세히 알아볼 시간이 있을 것이다.",
        "url": "/javascript-basic9"
    }
    ,
    
    "javascript-basic8": {
        "title": "Javascript - JavaScript 객체(Object)",
            "author": "AhnSang0915",
            "category": "",
            "content": "Javascript    JavaScript 기본     JavaScript 숫자와 문자     JavaScript 변수, 비교    JavaScript 조건문    JavaScript 반복문    JavaScript 함수    JavaScript 배열    JavaScript 객체(Object)    JavaScript 모듈    JavaScript UI와 API    JavaScript 정규표현식    JavaScript 함수지향 - 유효범위    JavaScript 함수지향 - 값으로서의 함수와 콜백    JavaScript 함수지향 - 클로저    JavaScript 함수지향 - arguments    함수지향 - 함수의 호출    객체지향 - 객체지향 프로그래밍 소개    객체지향 - 생성자와 new    객체지향 - 전역객체    객체지향 - this    객체지향 - 상속    객체지향-표준 내장객체의 확장    JavaScript 객체지향-ObjectJavaScript 객체(Object)1. 객체의 소개와 문법배열은 연관되어 있는 데이터들을 담아내기 위한 그릇이다. 마찬가지로 객체도 연관된 데이터를 담아내는 것에 있어서 유사하다. 하지만 똑같은 그릇이 있다고 쳤을 때 객체도 그릇에 담아내는 것은 같지만 index의 값으로 숫자나 문자를 쓸 수도 있고, 인덱스로 우리가 원하는 데이터를 지정할 수 있다는 것이 둘의 차이점이라고 할 수 있다. 다른 언어에서는 연관배열(associative array) 또는 맵(map), 딕셔너리(Dictionary)라는 데이터 타입이 객체에 해당한다.객체의 생성객체를 만드는 법을 알아보자. 배열은 대괄호로 시작해 대괄호로 끝나지만,객체는 중괄호로 시작해 중괄호로 끝나게 된다. 아래는 데이터값으로 숫자를 썻지만 문자나 다른 데이터를 할당하는 것도 가능하다. 아래 예제에서 ansang은 key(index)가 되고 10은 value(데이터 값)가 된다.var grades = {'ansang': 10, 'sanghyun': 6, 'ansanghyun': 80};            // key : value  key : value  key : value 위의 상태에서 객체를 대표하는 변수를 grades로 지정하고 grades를 호출하면 아래와 같은 값이 나오게 된다.gradesodject {ansang: 10, sanghyun: 6, ansanghyun: 80}아래는 객체를 만드는 다른 방법이다.var grades = {};grades['ansang'] = 10; //key는 ansang value는 10grades['sanghyun'] = 6; //key는 sanghyun value는 6grades['ansanghyun'] = 80; //key는 ansanghyun value는 80위에서 객체를 호출하는 방법은 아래와 같다. 아무래도 garade.ansang가 간편하지만, 프로그래밍 적인 기재가 불가능하다 이 경우 garade.’an’+’sang’로 호출하게 되면 SyntaxError가 나오게 된다. 즉 . 뒤의 내용을 프로그래밍 적으로 만들 수 없다. []안에 들어가는 값은 프로그래밍 적으로 생성이 가능하기 때문에 필요에 따라 대괄호 안에 작성하는 게 편리하거나 써야만 하는 상황이 있을 수 있다.grades['ansang'] //value 10garade.ansang //value 10grades['an'+'sang'] //value 102.객체와 반복문 for in객체에 저장된 데이터를 기준으로 반복하는 작업을 알아보자. 배열은 저장된 데이터들이 순서를 가지고 있다. 그래서 배열에선 순서 자체가 중요한 정보이다. 하지만 객체엔 순서가 없고, key와 value로 이루어져 있기 때문에 저장된 순서는 없기 때문에 저장된 값이 순서에 따라서 나오지 않을 것 이라는 걸 인지해야 한다.var grades = {'ansang' : 10, 'sanghyun' : 6, 'ansanghynu' : 80}for(key in grandes) {    document.write(\"key : \"+key+\" value : \" + grades[key] + \"&lt;br /&gt;\");}/*출력key : ansang value : 10key : snaghyun value : 6key : ansanghyun value : 80*/또는 key부분을 변수로 바꿔도 된다. 아래는 var name으로 바꿔보았다.var grades = {'ansang' : 10, 'sanghyun' : 6, 'ansanghynu' : 80}for(var name in grandes) {    document.write(\"key : \"+name+\" value : \" + grades[name] + \"&lt;br /&gt;\");}/*출력key : ansang value : 10key : snaghyun value : 6key : ansanghyun value : 80*/더 보기 편하게 리스트 형태로 만들어보자. html에서의 ul태그와 li태그를 사용해본다.  &lt;ul&gt;    &lt;script type=\"text/javascript\"&gt;        var grades = {'ansang': 10, 'sanghyun': 6, 'ansanghynu': 80};            for(var name in grades) {            document.write(\"&lt;li&gt;key : \"+name+\" value : \"+grades[name]+\"&lt;/li&gt;\");            }        &lt;/script&gt;  &lt;/ul&gt;        /* 출력        -key : ansang value : 10        -key : snaghyun value : 6        -key : ansanghyun value : 80        */배열도 for in문으로 사용할수 있다. 배열에선 var name으로 지정한 값이 index가 됨으로 console.log(name)에서 012라는 index가 추출되고 console.log(arr[name])에선 abc라는 데이터가 출력된다.var arr = ['a', 'b', 'c']for(var name in arr) {    console.log(name);}//출력 //0//1//2for(var name in arr) {    console.olg(arr[name]);}3. 객체 지향 프로그래밍객체 지향 프로그래밍이란 서로 연관되어있는 데이터와 처리형식을 하나의 그릇안에 그룹핑 해놓은 프로그래밍을 객체 지향 프로그래밍 이라한다.객체에 담길 수 있는 값이 무엇지에 대해 알아보자. 아래 예제는 객체 안에 객체와 함수를 담았다. list라는 key 값에 {‘ansang’ : 10, ‘sanghyun’ : 8, ‘ansanghyun’ : 80}라는 value를 넣었고 이 value는 객체이다. show라는 key값에 function(){ alert(‘Hello World’)}; 라는 value를 담았다. javascript에서는 함수도 일종의 값이고 함수도 변수에 저장될 수 있기 때문에 마찬가지로 값으로서의 함수도 객체 안에 저장될 수 있다(고하는데 아직 뭔 소린지 모르겠음).grades에 담긴var grades = {    'list' : {'ansang' : 10, 'sanghyun' : 8, 'ansanghyun' : 80},    'show' : function(){        alert('Hello World');    }}alert(grades['list']['ansang']); //ansang이라는 key가 갖고있는 10이라는 value에 접근alert(grades['show']); // 함수에 접근this라는 키워드를 알아보자. this라는 것은 javascript에서 약속되어있는 변수이다. this 변수는 함수가 속해있는 객체를 가르치는 변수이다. 함수가 소속되어있는 객체를 가르친다는 말이다.아래 예제는 grades라는 객체가 갖고있는 key 값 중 show를 호출해 show 함수가 가진 this변수로 list객체{‘ansang’ : 10, ‘sanghyun’ : 8, ‘ansanghyun’ : 80}를 출력하게 된다.var grades = {    'list' : {'ansang' : 10, 'sanghyun' : 8, 'ansanghyun' : 80},    'show' : function(){        alert(this.list);    }}grades['show']();이번엔 개발자 도구에서 console.log(name, this.list[name]);를 사용해 key와 value를 호출해보자. value를 호출하는 방법은 위에서 배웠듯,  grades[‘ansang’] , garade.ansang 두가지가 있다. for in 문을 사용했기 때문에 list[name]을 사용하면 value 값을 불러올 수 있다.var grades = {    'list' : {'ansang' : 10, 'sanghyun' : 8, 'ansanghyun' : 80},    'show' : function(){        for(var name in this.list){            console.log(name, this.list[name]); // ,를 쓰게되면 여러 값을 출력할 수 있다.        }    }}grades.show();",
        "url": "/javascript-basic8"
    }
    ,
    
    "javascript-basic7": {
        "title": "Javascript - JavaScript 배열",
            "author": "AhnSang0915",
            "category": "",
            "content": "Javascript    JavaScript 기본     JavaScript 숫자와 문자     JavaScript 변수, 비교    JavaScript 조건문    JavaScript 반복문    JavaScript 함수    JavaScript 배열    JavaScript 객체(Object)    JavaScript 모듈    JavaScript UI와 API    JavaScript 정규표현식    JavaScript 함수지향 - 유효범위    JavaScript 함수지향 - 값으로서의 함수와 콜백    JavaScript 함수지향 - 클로저    JavaScript 함수지향 - arguments    함수지향 - 함수의 호출    객체지향 - 객체지향 프로그래밍 소개    객체지향 - 생성자와 new    객체지향 - 전역객체    객체지향 - this    객체지향 - 상속    객체지향-표준 내장객체의 확장    JavaScript 객체지향-ObjectJavaScript 배열1. 배열의 문법배열배열(array)이란 연관된 데이터를 모아서 통으로 관리하기 위해 사용하는 데이터의 형식이다. 변수는 하나의 데이터를 저장하기 위한 것이라면 배열은 여러 개의 데이터를 하나의 변수에 저장하기 위해 사용한다. 아래 코드는 name이라는 변수에 ‘Ahnsang’이라는 데이터를 할당한 것이다.var name = 'Ahnsang'alert(name);배열의 생성위에선 변수에 하나의 데이터를 할당 했다. 이제 배열로 여러개의 데이터를 변수에 할당하는 방법을 공부해 보자.여러개의 데이터를 할당 하려면 변수명 = 뒤에 [] 대괄호를 사용해 여러개의 데이터를 작성할 수 있다.var member = ['Ahnsang', 'SangHyun', 'AhnSangHyun']이 각각의 데이터를 요소,또는 원소(Element)라고 부르고 이제 이 원소들을 호출할것이다. 요소는 순서대로 0,1,2의 고유한 값,식별자를 가지게 된다. 색인 이라고도 하고 index라고도한다.var member = ['Ahnsang', 'SangHyun', 'AhnSangHyun']alert(member[0]);alert(member[1]);alert(member[2]);코드를 실행하면 차례대로 ‘Ahnsang’, ‘SangHyun’, ‘AhnSangHyun’ 세개의 데이터를 차례로 경고창에 출력해준다.2. 배열의 효용성배열이 없다면 변수에 하나의 데이터만 할당할수 있기 때문에 불편할 것이다. 아래의 예제를 보자.함수는 여러개의 입력값을 받을 수 있지만, 하나의 출력만 할 수 있다.function get_member1(){    return 'Ahnsang';}document.write(get_member1()); function get_member2(){    return 'SangHyun';}document.write(get_member2());  function get_member3(){    return 'AhnSangHyun';}위 코드처럼 배열을 사용하지 않으면 각각의 회원정보를 반환하는 함수로 표한해야한다. 배열을 사용해 코드를 만들어 보자. return 안에 배열을 사용해 각각의 색인으로 원하는 정보를 호출할 수 있다.function get_members() {    return ['Ahnsang', 'SangHyun', 'AhnSangHyun']}var members = get_members();document.write(members[0]);document.write(members[1]);document.write(members[2]);3. 배열의 사용 - 배열과 반복문우리가 배열을 사용해 index값을 호출할때 그 값을 일일히 기억해서 호출한다는것은 불가능하다. 배열이 몇백 몇천개가 사용될수도 있기 때문이다. 그렇기 때문에 배열이란 결국 배열에 담겨있는 값을 하나하나 꺼내서 그꺼내진 값을 가공하는게 배열의 핵심적인 요소라고 할수있다.아래 예제에서 출력값을 대문자로 출력하려고 .toUpperCase();라는 javascript내장함수를 사용해 출력했다.‘AHNSANG’,’SANGHYUN’,’AHNSANGHYUN’을 출력하게 될것이다.function get_members() {    return ['Ahnsang', 'SangHyun', 'AhnSangHyun']}var members = get_members();document.write(members[0].toUpperCase()+\"&lt;br /&gt;\");document.write(members[1].toUpperCase()+\"&lt;br /&gt;\");document.write(members[2].toUpperCase()+\"&lt;br /&gt;\");위 예제 처럼 우리가 직접 손으로 배열을 호출을 하기엔 무리가 있다. 이때 사용할 수 있는 방법이 배열과 반복문을 결합하는 것이다. 그전에 한가지 예제를 더 보자. 아래 예제는 배열의 값이 몇개인지 나타내 주는 함수이다. 경고창 내용은 3을 출력하게 된다.var a = ['Ahnsang', 'SangHyun', 'AhnSangHyun']alert (a.length);이제 배열과 반복문을 결합한 예제를 보자. i란변수를 지정하고 시작은 0에서 1씩 증가해 2로 끝나게 된다. 이렇게 나온 0, 1, 2는 index 값으로 사용하고, members[index값]에 i의 값이 어가게 되어 차례로 출력할 수 있게 된다.’AHNSANG’,’SANGHYUN’,’AHNSANGHYUN’을 출력하게 될것이다.function get_members() {    return ['Ahnsang', 'SangHyun', 'AhnSangHyun']}var members = get_members();for(var i = 0; i &lt; 3; i++) {    document.write(members[i].toUpperCase()+\"&lt;br /&gt;\");}그런데 여기서 배열의 갯수가 늘어난다면 우리는 반복문의 조건을 수정해야한다. 이것도 함수를 사용해 더 편리하게 만들어 보면, 우리는 members라는 변수에 get_members라는 함수를 호출했다. 그 함수안에 return의 배열이 들어있기 때문에 members.length함수를 사용하면 배열안의 요소의 갯수를 호출해 사용할 수 있다.function get_members() {    return ['Ahnsang', 'SangHyun', 'AhnSangHyun']}var members = get_members();for(var i = 0; i &lt; members.length; i++) {    document.write(members[i].toUpperCase()+\"&lt;br /&gt;\");}4. 배열의 제어배열은 복수의 데이터를 효율적으로 관리, 전달하기 위한 목적으로 고안된 데이터 타입이다. 따라서 데이터의 추가/수정/삭제와 같은 일을 편리하게 할 수 있도록 돕는 다양한 기능을 가지고 있다. 몇가지 중요한 기능들만 살펴보자.배열의 조작 - 추가 push배열의 끝에 원소를 추가하는 방법을 알아보자. push는 인자로 전달된 값을 배열에 추가하는 javascript 내장함수 이다. 아래 코드를 실행하면 “f”가 추가된 배열이 출력된다.var li = ['a', 'b', 'c', 'd', 'e'];li.push('f');alert(li);아래의 함수와 위의 함수는 같다.function numbering() {    var i = 0;    while(1 &lt; 10) {        document.write(i);        i += i;    }}아래 함수는 이름을 정하지도 않고 변수도 붙이지 않았다. 함수를 정의하고 함수를 괄호로 묶었다. 그다음에 호출할때 사용하는 기호 ();로 호출하게 되면 정의와 호출을 하나의 문장으로 같이하는 함수로 익명함수라고 한다. 일회 성으로 호출할때 이런 함수를 사용한다.(function(){    i = 0;    while(i &lt; 10){        document.write(i);        i += 1;    }   }) ();배열의 추가 concatconcat(concatenate)은 복수의 원소를 배열에 추가하는 방법이다. 추가한 출력은 [‘a’, ‘b’, ‘c’, ‘d’, ‘e’,’f’, ‘g’] 가된다.var li = ['a', 'b', 'c', 'd', 'e'];li = li.concat(['f', 'g']);alert(li);배열의 추가 unshiftunshift는 배열의 시작점에 원소를 추가하는 방법이다. 출력은 [‘z’,’a’, ‘b’, ‘c’, ‘d’, ‘e’] 가되고 index도 0~5로 변경된다.var li = ['a', 'b', 'c', 'd', 'e'];li.unshift('z');alert(li);배열의 추가 splicesplice는 배열의 특정구간을 추출하거나, 특정구간에 특정 배열을 추가하는 방법이다. 문법은 아래와 같고,array.splice(index, howmany, element1, ...., elementN);아래 표를 보면서 이해해보자.            인자명      데이터형      필수/옵션      설명                  index      number      필수      배열에 추가할 특정 배열의 위치를 가르키는 index              howmany      number      필수      index에서부터 제거될 원소들의 수. index부터 index+howmany에 해당하는 원소들은 삭제된다. 이 값이 0이면 어떠한 원소도 삭제되지 않는다.              element1,…,elementN      number      옵션      index와 index+howmany 사이에 추가될 값      아래와 같이 splice를 이용해 배열에 ‘x’,’y’를 추가하는 코드가 있다. splice뒤에 오는 1은 [a,b,c] 배열에서 ‘b’를 가르키고 0은 ‘b’를 제거하지 않고 index 1번 위치에 ‘x’,’y’를 추가하겠다는 말이다.이러면 배열은 [‘a’,’x’,’y’,’b’,’c’] 가된다.var a = ['a','b','c']a.splice(1,0,['x','y'])이번엔 기존 배열을 삭제하고 추가하는 예제를 보자. index 1번자리에 있는 ‘b’의 자리에서 2개의 원소를 삭제하고 [‘x’,’y’]를 순서대로 넣어주겠다는 말이다. 변경된 배열은 [‘a’ , ‘x’, ‘y’]가 된다.var a = ['a','b','c']a.splice(1,2,['x','y'])몇가지 예제를 더보자.var numbers = [1,2,3,4,5,6,7,8,9,10];alert(numbers.splice(2)); //2번 index를 포함 이후의 모든 요소를 제거한다.alert(numbers); // [1,2] var numbers = [1,2,3,4,5,6,7,8,9,10];alert(numbers.splice(2, 4)); // array, [3,4,5,6] var numbers = [1,2,3,4,5,6,7,8,9,10];alert(numbers.splice(2, 4, 'three', 'four', 'five', 'six')); // array, [3,4,5,6]alert(numbers); // array, [1,2,three,four,five,six,7,8,9,10]5. 배열의 조작 - 제거, 정렬제거 shiftshift는 배열의 첫번째 원소를 제거하는 방법이다. index 0번에 위치한 원소를 제거하고 나머지 값들을 한칸씩 앞으로 당겨온다. 만약 배열의 length가 0이면 undefined을 리턴한다. 아래 예제의 결과는 b, c, d, e다.var li = ['a', 'b', 'c', 'd', 'e'];li.shift();alert(li);제거 poppop은 배열의 마지막 원소를 제거하는 방법이다. 마지막 index에 위치한 원소를 제거하고 마찬가지로 빈 배열이라면 undefined을 리턴한다.var li = ['a', 'b', 'c', 'd', 'e'];li.pop();alert(li);정렬 sort배열을 이용하는 중요한 이유중 하나가 정렬이다. sort는 배열의 정렬을 하고싶을때 사용한다.var li = ['c', 'e', 'a', 'b', 'd'];li.sort();alert(li);하지만 만약 배열이 [‘1’, ‘10’, ‘6’] 인경우엔 정렬이 1, 10, 6이 된다. 데이터를 문자로 보기때문에 앞에 1이 온 10을더 작다고 보는것이다. 이것을 올바르게 정렬하려면 아래와 같은 예제를 사용한다.function sortNumber(a,b){    return a-b; //역순을 구한다면 b-a를 활용한다.}var numbers = [20, 10, 9,8,7,6,5,4,3,2,1];alert(numbers.sort(sortNumber)); // array, [1,2,3,4,5,6,7,8,9,10,20]위 함수 a-b; 부분을 이해하려 찾아보았다. 정확하게 javascript에서 어떤 알고리즘으로 작동하는지 모르지만 이런 식으로 작동할 것이라는 글을 보게 되었다.만약 5,4,6,1,3,2 라는 배열이 있다고 가정하자.a-b에서 양수면 위치를 바꾸고 음수면 유지한다.5-4는 양수로 위치를바꾼다.4,5,6,1,3,24-6은 음수로 유지.4,5,6,1,3,24-1은 양수로 변경.1,5,6,4,3,21-3,1-2도 음수로 자리를 유지하고 index0번위치에 1이 오게된다.이제 1,5,6,4,3,2에서 두번째 자리를 찾는다.5-6은 음수로 유지.1,5,6,4,3,25-4는 양수로 변경.1,4,6,5,3,24-3은 양수로 변경.1,3,6,5,4,23-2는 양수로 변경.1,2,6,5,4,3 두번째 자리를 찾았다.….…이런 식으로 반복해서 찾는다는 글을 봤는데 맞는진 모르겠지만 이렇게 이해하면 좋을 것 같다.정렬 reversereverse는 역순으로 정렬하고 싶을때 사용한다.var li = ['c', 'e', 'a', 'b', 'd'];li.reverse();alert(li);",
        "url": "/javascript-basic7"
    }
    ,
    
    "javascript-basic6": {
        "title": "Javascript - JavaScript 함수",
            "author": "AhnSang0915",
            "category": "",
            "content": "Javascript    JavaScript 기본     JavaScript 숫자와 문자     JavaScript 변수, 비교    JavaScript 조건문    JavaScript 반복문    JavaScript 함수    JavaScript 배열    JavaScript 객체(Object)    JavaScript 모듈    JavaScript UI와 API    JavaScript 정규표현식    JavaScript 함수지향 - 유효범위    JavaScript 함수지향 - 값으로서의 함수와 콜백    JavaScript 함수지향 - 클로저    JavaScript 함수지향 - arguments    함수지향 - 함수의 호출    객체지향 - 객체지향 프로그래밍 소개    객체지향 - 생성자와 new    객체지향 - 전역객체    객체지향 - this    객체지향 - 상속    객체지향-표준 내장객체의 확장    JavaScript 객체지향-ObjectJavaScript 함수1. 함수란?함수(function)란 javascript에서 기본적인 구성 블록중 하나로, 작업을 수행하거나 값을 계산하는 문장 집합같은 절차이다. 함수는 하나의 로직을 재실행 할 수 있도록 하는것으로 코드의 재사용성을 높여준다.함수의 형식함수(function)의 형식은 아래와같다.function 함수명( [인자...[,인자]] ){   코드 내용   return 반환값}함수의 정의와 호출함수(function) 뒤에 함수의 이름이 오고, 소괄호가 따라온다. 우리가 변수를 호출하려면 변수를 정의하고 값을할당한후 그 변수를 호출해야한다. 함수도 마찬가지로 함수를 정의했으면 정의한 함수를 호출해야한다. 변수는 변수 이름만으로 호출하지만 함수는 함수명 뒤 (); 를 붙여줘야한다. ();를 붙이지 않으면 javascript는 변수로 인식하기 때문에 꼭 써줘야한다.function numbering() {    document.write(1);}numbering();다음 예제를 보자. 이 함수의 이름은 numbering이고, 내용은 0부터 9까지를 화면에 출력한다.function numbering(){    i = 0;    while(i &lt; 10){        document.write(i);        i += 1; // i = i + 1; 과 같다    }   }numbering();2. 함수의 효용성만약 함수가 없이 0~9까지의 코드를 출력하려고 하려고 하면 아래와 같이 하면 될것이다.var i = 0while(i &lt; 10&gt;){    document.write(i);    i +=1;}var i = 0while(i &lt; 10&gt;){    document.write(i);    i +=1;}var i = 0while(i &lt; 10&gt;){    document.write(i);    i +=1;}var i = 0while(i &lt; 10&gt;){    document.write(i);    i +=1;}var i = 0while(i &lt; 10&gt;){    document.write(i);    i +=1;}그런데 위의 코드를 0에서19까지로 바꿔야한다면 while(i &lt; 10&gt;) 부분을 while(i &lt; 20&gt;)으로 바꿔줘야 한다. 5번만 호출한다면 어렵지 않겠지만 많은 횟수를 호출하는 상황에선 어려운 작업이 될것이다. 이럴때 함수를 쓰면 1에서19까지를 1000번을 호출해도 아래와 같이 간단히 바꿀수 있다.funtion numbering() {    while(i &lt; 20&gt;){    document.write(i);    i +=1;}for(var i = 1; i &lt; 1000; i++){    numbering();}물론 함수를 사용하지 않고 for문과 while로도 호출이 가능하다.for(var i = 1; i &lt; 1000; i++){    var i = 0;    while(i &lt; 20&gt;){        document.write(i);        i +=1;    }}위의 두코드의 차이점은 반복문은 반복문 안에서만 실행이 되고 함수는 다른 여러곳에서도 호출하여 사용할 수 있다는 점이다. 핵심은 재사용성이고 이말은 이 함수를 사용하고 있는 여러곳 에서 이함수의 내용을 변경, 개선한다고 하면 함수만 변경하면 사용하는 여러곳 에서 변경이되기 때문에 유지보수가 용이하게 된다.3. 함수의 입력과 출력함수의 핵심은 입력과 출력이다. 입력된 값을 연산해서 출력하는 것이 함수의 기본적인 역할이다. 다음은 함수에서 입력과 출력의 역할을 하는 구문들에 대한 설명이다.함수의 출력return함수 내에서 사용한 return은 return 뒤에 따라오는 값을 함수의 결과로 반환한다. 동시에 함수를 종료시킨다. 아래 내용을 보자. 결과는 egoing과 k8805다.function get_member1(){    return 'egoing';} function get_member2(){    return 'k8805';} alert(get_member1());alert(get_member2());아래 함수를 실행시켜보면 ‘egoing’만 출력하고 함수가 종료된다. return뒤의 내용은 출력하지 않는다.function get_member(){    return 'egoing';    return 'k8805';    return 'sorialgi';}alert(get_member());인자인자(argument)는 함수로 유입되는 입력 값을 의미하는데, 어떤 값을 인자로 전달하느냐에 따라서 함수가 반환하는 값이나 메소드의 동작방법을 다르게 할 수 있다. 다음 예를보자.앞에서본 함수와는 다르게 함수명 뒤에 1과 2가 들어가있다. 이말은 get_argument라는 함수를 호출할때 숫자 1과2를 넣어준다는 말이 된다. 숫자가 들어가는 arg는 변수가된다. arg=1, arg=2라는 뜻이 되는것이다. return이지만 2번을 호출했기 떄문에 1000,2000 의 값이 출력 된다.function get_argument(arg){ //arg는 매개변수 또는 parameter라고 부른다.    return arg*1000;} alert(get_argument(1)); // 1과 2를 인자 argument라고 한다.alert(get_argument(2));복수의 인자인자를 여러개의 사용할수도 있다. 첫번째 두번째 인자가 차례로 arg1와 arg2로 들어가게 되고 30 , 50의 값이 출력 되게 된다.function get_arguments(arg1, arg2){    return arg1 + arg2} alert(get_arguments(10, 20));alert(get_arguments(20, 30));4. 다양한 함수 정의 방법함수를 정의하는 다른 방법을 알아보자.우리가 위에서 작성한 함수와는 조금 다르다. function내의 함수 내용이 numbering이라는 변수에 대입되어 변수가 함수를 가지게 된것이다.var numbering = function (){    i = 0;    while(i &lt; 10){        document.write(i);        i += 1;    }   }numbering();아래의 함수와 위의 함수는 같다.function numbering() {    var i = 0;    while(1 &lt; 10) {        document.write(i);        i += i;    }}아래 함수는 이름을 정하지도 않고 변수도 붙이지 않았다. 함수를 정의하고 함수를 괄호로 묶었다. 그다음에 호출할때 사용하는 기호 ();로 호출하게 되면 정의와 호출을 하나의 문장으로 같이하는 함수로 익명함수라고 한다. 일회 성으로 호출할때 이런 함수를 사용한다.(function(){    i = 0;    while(i &lt; 10){        document.write(i);        i += 1;    }   }) ();",
        "url": "/javascript-basic6"
    }
    ,
    
    "javascript-basic5": {
        "title": "Javascript - JavaScript 반복문",
            "author": "AhnSang0915",
            "category": "",
            "content": "Javascript    JavaScript 기본     JavaScript 숫자와 문자     JavaScript 변수, 비교    JavaScript 조건문    JavaScript 반복문    JavaScript 함수    JavaScript 배열    JavaScript 객체(Object)    JavaScript 모듈    JavaScript UI와 API    JavaScript 정규표현식    JavaScript 함수지향 - 유효범위    JavaScript 함수지향 - 값으로서의 함수와 콜백    JavaScript 함수지향 - 클로저    JavaScript 함수지향 - arguments    함수지향 - 함수의 호출    객체지향 - 객체지향 프로그래밍 소개    객체지향 - 생성자와 new    객체지향 - 전역객체    객체지향 - this    객체지향 - 상속    객체지향-표준 내장객체의 확장    JavaScript 객체지향-ObjectJavaScript 반복문1. 반복문 기본문법-while반복문(Loop iterate)은 사람이 하기힘든 반복 작업을 하기위해 사용하고, 몇가지 문법이 있다.whilewhile의 형식은 아래와같다. 조건이 true인 동안에 { } 안의 데이터를 반복하게 된다.while (조건){    반복해서 실행할 코드}2. 반복조건반복조건이 없다면 반복문이 무한대로 실행이되게된다. 반복조건을 설정해 적당한 시기에 반복이 정지하도록 해줘야한다.아래 예제는 i의 시작값을 0으로 정했고 한번씩 반복 할때마다 ‘coding everybody ‘문장이 실행되고 i가 1씩 늘어나게 된다. i의 값이 9가되면 반복을 멈추게 된다.var i = 0;while(i &lt; 10){    document.write('coding everybody &lt;br /&gt;');    i++}3. for문for문의 형식은 아래와 같다. while 과 for문은 둘다 반복문이고 대체가능하다.for(초기화; 반복조건; 반복이 될 때마다 실행되는 코드){    반복해서 실행될 코드}for(var i = 0; i &lt; 10; i++){   // i = i + 1 과 i ++는 같다.    document.write('coding everybody'+i+'&lt;br /&gt;');}i++는 해당 구문을 실행할때마다 i값을 1씩 증가시킨다는 말이다. i=0이라고 시작하면 0부터 시작하게 된다.++i는 해당 구문을 실행할때부터 1을 증가시킨채 실행한다. i=0이라고하면 시작부터 1로 시작한다.4. 반복문의 효용성반복문이 없다면 코드를 복사해서 붙여넣기 하면 된다. 하지만 반복 횟수가 많아지면 많아질수록 힘들어질 것이다. 아래 예제의 두 코드는 같은 내용이다. 어떤 작업이 더 편할까?document.write('coding everybody');document.write('coding everybody');document.write('coding everybody');document.write('coding everybody');document.write('coding everybody');document.write('coding everybody');document.write('coding everybody');document.write('coding everybody');document.write('coding everybody');document.write('coding everybody');document.write('coding everybody');var i = 0;while(i &lt; 10){    document.write('coding everybody &lt;br /&gt;');    i++;}그런데 ‘coding everybody’뒤에 순서를 써야하고 그 양이 많다면 불가능해 질것이다. 반복문으로 코드를 작성하면 간단하다.var i = 0;while(i &lt; 10) {    document.write('coding everybody' + i + &lt;br/&gt;);}5. 반복문의 제어반복문을 강제 정지시키거나 정지후 재시작 하기위한 명령어를 알아보자.breakbreak는 반복문을 중간에 중단시키게 해준다. 아래 예제는 0~4까지 출력하고 중단하게 된다.for(var i = 0; i &lt; 10; i++){    if(i === 5) {        break;    }    document.write('coding everybody'+i+'&lt;br /&gt;');}continuecontinue는 지정된 부분에선 반복을 중단하고 반복을 재시작할 수 있게 해준다. 아래의 코드를 실행해보자.for(var i = 0; i &lt; 10; i++){    if(i === 5) {        continue;    }    document.write('coding everybody'+i+'&lt;br /&gt;');}i===5에서 continue를 하겠다고 했기때문에 i의 값이 5가되었을 때는 실행을 중단하고 다음 i값부터 다시 반복하게 된다.coding everybody 0coding everybody 1coding everybody 2coding everybody 3coding everybody 4coding everybody 6coding everybody 7coding everybody 8coding everybody 96. 반복문의 중첩사용과 디버거반복문안에 반복문을 중첩해 사용할수 있다. 아래 예제에선 i와j를 0~9까지 반복하고 그i와j는 숫자이고 숫자끼리 더해지게 되는데 아래 처럼 문자열과 숫자의 결합하는 경우 javascript는 숫자인 부분을 문자로 변환해 준다.for(var i = 0; i &lt; 10; i++){    for(var j = 0; j &lt; 10; j++ ) {    document.write('coding everybody' + i + j + '&lt;br /&gt;');    }}위코드를 실행해 보면 00~99까지의 i와j가 출력된다.디버거우리가 만든 코드의 버그를 확인하고 코드 실행 순서를 볼 수 있는 기능을 알아보자. F12키를 눌러 개발자도구를 열고 console로 들어가 보고자 하는 줄의 코드를 선택하고 F5를 눌러 새로고침한다.그리고 버튼을 활용해 실행 순서를 확인해 보자.",
        "url": "/javascript-basic5"
    }
    ,
    
    "javascript-basic4": {
        "title": "Javascript - JavaScript 조건문",
            "author": "AhnSang0915",
            "category": "",
            "content": "Javascript    JavaScript 기본     JavaScript 숫자와 문자     JavaScript 변수, 비교    JavaScript 조건문    JavaScript 반복문    JavaScript 함수    JavaScript 배열    JavaScript 객체(Object)    JavaScript 모듈    JavaScript UI와 API    JavaScript 정규표현식    JavaScript 함수지향 - 유효범위    JavaScript 함수지향 - 값으로서의 함수와 콜백    JavaScript 함수지향 - 클로저    JavaScript 함수지향 - arguments    함수지향 - 함수의 호출    객체지향 - 객체지향 프로그래밍 소개    객체지향 - 생성자와 new    객체지향 - 전역객체    객체지향 - this    객체지향 - 상속    객체지향-표준 내장객체의 확장    JavaScript 객체지향-ObjectJavaScript 조건문1. 조건문이란?조건문(Conditional statement)은 if로 시작한다.if뒤에는 반드시 true나 false로 두개의 값중에 하나가 온다. 그뒤 중괄호안에 조건이 들어오게 된다.아래의 예제는 true를 출력할것이다. if뒤가로에 true가 오게되면 중괄호 안의 내용이 실행된다.if(true){    alert('result : true');이번엔 아무것도 출력하지 않는다. if뒤에 false가오면 중괄호 안의 내용을 실행하지 않는다.if(false){    alert('result : true');12345를 출력 할것이다.if(true){    alert(1);    alert(2);    alert(3);    alert(4);}alert(5);5만 출력한다. false기 때문에 중괄호 안의 내용은 실행하지 않는다.if(false){    alert(1);    alert(2);    alert(3);    alert(4);}alert(5);2. else, else ifif만으로는 조건문을 사용하는데에 제약이 있다. else와 else if는 더 다양하게 조건문을 응용할 수 있게 해준다.elseif뒤 true가 있다면 중괄호 안의 내용이 실행이 되고, else는 실행이 되지 않는다. 만약에 참 이라면 if중괄호가 실행후 else는 무시하고 결과는 1이된다.if(true){    alert(1);} else {    alert(2);}if뒤에 false가 있다면 중괄호 안의 내용이 실행이 안되고, 만약에 거짓이라면 else가 실행이 된고 결과는 2다.if(false){    alert(1);} else {    alert(2);}else if아래 코드에 대한 해석을 해보자. 1번에서 if뒤의 false로 2번alert(1)이 실행되지 않고 다음으로 넘어간다. 3번코드 else에선 1번에서 if가 false기 때문에 실행이 되고 else뒤의 if가 true이기 때문에 2라는 값이 출력된다. 4번이 실행 되었기 때문에 5와 7의 else가 실행될수 없다. 그대로 2만 출력 할 것이다.if(false){       //1    alert(1);    //2} else if(true){ //3    alert(2);    //4} else if(true){ //5    alert(3);    //6} else {         //7    alert(4);    //8}아래 코드도 해석해보면 3이 출력된다는 걸 알 수 있다.if(false){    alert(1);} else if(false){    alert(2);} else if(true){    alert(3);} else {    alert(4);}아래 코드도 해석해보면 4가 출력된다는 걸 알 수 있다.if(false){    alert(1);} else if(false){    alert(2);} else if(false){    alert(3);} else {    alert(4);}3. 조건문의 응용변수와 비교연산자if(true) {    alert(1);}위와 같은 코드는 javascript에서 쓸일이 없다. 무조건 1이 출력이 되기 때문이다. 조건문과 변수가 만나 상황에 따라 가변적인 요소가 되어야 조건문이라 할수 있다. prompt라는 구문을 사용해야 하는데 prompt는 사용자가 입력한 값을 가져와서 변수의 값으로 대입해준다. 예제를 통해 더 알아보자.&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;    &lt;meta charset=\"utf-8\"/&gt;&lt;/head&gt;&lt;body&gt;    &lt;script&gt;        id = prompt('아이디를 입력해주세요.') //prompt를 통해 사용자가 입력한 값을 id라는 변수에 적용        if(id=='Ahnsang'){            alert('아이디가 일치 합니다.')        } else {            alert('아이디가 일치하지 않습니다.')        }    &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;위의 예제를 응용해 아이디와 비밀번호 모두 사용하게 해보자. 아이디가 일치하면 비밀번호를 물어볼 필요가 없다. id 변수에 입력한 값이 if id의 조건문에서 아이디가 일치한다면 if password에서 prompt를 통해 비밀번호를 요구한다. 그렇게 되면 입력한 비밀번호가 password라는 변수에 담겨서 입력 값과 111111라는 password와 일치하면 로그인 하셨습니다. 다르다면 비밀번호가 다릅니다라는 메세지가 나오게 된다.&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;    &lt;meta charset=\"utf-8\"/&gt;&lt;/head&gt;&lt;body&gt;    &lt;script&gt;        id = prompt('아이디를 입력해주세요.');        if(id=='Ahnsang'){            password = prompt('비밀번호를 입력해주세요.');            if(password==='111111'){                alert('로그인 했습니다.');            } else {                alert('비밀번호를 확인해 주세요.');            }        } else {            alert('아이디를 확인해 주세요.');        }    &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;4. 논리 연산자논리 연산자는 조건문을 더 간결하고 다양하게 사용할수 있다.&amp;&amp;&amp;&amp;는 좌항과 우항이 모두 참(true)일때 참이된다. 아래 예제에선 1이라는 값이 출력된다. 이러한 연산자를 and연산자라고 한다.if(true &amp;&amp; true){    alert(1);}if(true &amp;&amp; false){    alert(2);}if(false &amp;&amp; true){    alert(3);}if(false &amp;&amp; false){    alert(4);}아래 예제에선 논리연산자 중 and연산자를 활용한 것 이다. 두 변수를 동시에 호출하기 위해 id와 password를 prompt로 호출해주고 &amp;&amp; 연산자로 둘의 값이 모두 참일때만 ‘인증했습니다.’라는 메세지를 출력 하게되고 하나라도 다르다면 ‘인증에 실패 했습니다.’ 라는 값을 출력하게 된다. and연산자는 2개 이상도 사용할 수 있다.&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;    &lt;meta charset=\"utf-8\"/&gt;&lt;/head&gt;&lt;body&gt;    &lt;script&gt;        id = prompt('아이디를 입력해주세요.');        password = prompt('비밀번호를 입력해주세요.');        if(id=='Ahnsang' &amp;&amp; password=='111111'){            alert('인증 했습니다.');        } else {            alert('인증에 실패 했습니다.');        }    &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;||||는 ||의 좌우항 하나라도 참이라면 참이 되고 둘다 거짓일때 거짓이 되는 연산자 이다. 예제는 1, 2, 3이 출력되고 ||는 or연산자 라고 한다.if(true || true){    alert(1);}if(true || false){    alert(2);}if(false || true){    alert(3);}if(false || false){ //둘다 false기 때문에 false    alert(4);}아래 예제는 Ahnsang, Ahnsang1, Ahnsang2 값중 하나라도 변수값에 들어오면 ‘인증 했습니다.’라는 값을 출력하게 될것이다.id = prompt('아이디를 입력해주세요.');if(id==='Ahnsang' || id==='Ahsang1' || id==='Ahnsang2'){    alert('인증 했습니다.');} else {    alert('인증에 실패 했습니다.');}다음예제는 or와 and를 사용하는 방법이다.id 비교를 할 때 괄호를 사용한 것은 사칙 연산을 할 때 괄호부터 계산하는 것과 같은 원리다. 세개의 id중 하나라도 맞고 password가 111111이면 로그인 했습니다 라는 값이 출력된다.id = prompt('아이디를 입력해 주세요')password = prompt('비밀번호를 입력해 주세요.')if(id === 'Ahnsang' || id === 'Ahnsang1' || id === 'Ahnsang2' &amp;&amp; password = '111111') {    alert('로그인 했습니다.')}   else {    alert('로그인 실패 했습니다.')}!!는 부정의 의미로 true나 false 앞에 !를 붙이면 값을 역전시킨다. not 연산자 라고 부른다. 아래 에제에서 !를 사용하면 어떻게 되는지 확인하자. 값은 4이다.if(!true &amp;&amp; !true){ //false false 이기 때문에 &amp;&amp;연산자 에선 실행되지 않는다.    alert(1);}if(!false &amp;&amp; !true){ //true false &amp;&amp;는 둘다 참이어야 실행한다.    alert(2);}if(!true &amp;&amp; !false){ //true false &amp;&amp;는 둘다 참이어야 실행한다.    alert(3);}if(!false &amp;&amp; !false){ //true true기 때문에 실행한다.    alert(4);}5.boolean의 대체제0과 1조건문에 사용될 수 있는 데이터 형이 꼭 불린만 되는 것은 아니다. 관습적인 이유로 0는 false 0이 아닌 값은 true로 간주된다. 아래의 예제는 2를 출력한다.if(0){    alert(1)}if(1){    alert(2)}그외의 false로 간주되는 데이터if(!''){    alert('빈 문자열')}if(!undefined){    alert('undefined');}var a;if(!a){    alert('값이 할당되지 않은 변수'); }if(!null){    alert('null');}if(!NaN){    alert('NaN');}",
        "url": "/javascript-basic4"
    }
    ,
    
    "javascript-basic3": {
        "title": "Javascript - JavaScript 변수, 비교",
            "author": "AhnSang0915",
            "category": "",
            "content": "Javascript    JavaScript 기본     JavaScript 숫자와 문자     JavaScript 변수, 비교    JavaScript 조건문    JavaScript 반복문    JavaScript 함수    JavaScript 배열    JavaScript 객체(Object)    JavaScript 모듈    JavaScript UI와 API    JavaScript 정규표현식    JavaScript 함수지향 - 유효범위    JavaScript 함수지향 - 값으로서의 함수와 콜백    JavaScript 함수지향 - 클로저    JavaScript 함수지향 - arguments    함수지향 - 함수의 호출    객체지향 - 객체지향 프로그래밍 소개    객체지향 - 생성자와 new    객체지향 - 전역객체    객체지향 - this    객체지향 - 상속    객체지향-표준 내장객체의 확장    JavaScript 객체지향-ObjectJavaScript 변수, 비교변수1. 변수의 사용법변수(Variable)는 문자나 숫자같은 값을 담는 컨테이너로 값을 유지할 필요가 있을때 사용한다. 담겨진 값은 다른 값으로 바꿀수 있고 var로 변수를 선언할수 있다. 생략도 가능하지만 var의 의미를 명확하게 이해하기 전에는 var를 사용하는 것이 좋겠다. 예제를 보자.var a = 1;alert(a+1);  //2 var a = 2;alert(a+1);  //3var first = \"coding\";alert(first+\" everybody\"); //coding everyday//변수 a에 coding ,변수 b에 everybody를 활당하는 방법은 아래와 같다.var a = 'coding', b = 'everybody';alert(a);alert(b);2. 변수의 효용변수는 코드의 재활용성을 높여준다. 반복해서 100에서 10을 빼고 더하고 나누는 계산을 해야하는 코드가 있다고 가정해보고 변수가 없다면 100에관한 숫자 데이터를 모두 수정해야 할것이다. 여기서 변수를 적용하면 변수 값만 바꿔주면 된다.//변수를 쓰기 전alert(100+10);alert((100+10)/10);alert(((100+10)/10)-10);alert((((100+10)/10)-10)*10);// 변수 사용 후a = 100; //변할수 있는a = a + 10; //변하지 않는alert(a);a = a / 10;alert(a);a = a - 10;alert(a);a = a * 10;      alert(a);변수를 쓰지 않은 코드보다 쓴 코드가 더 길기때문에 비효율 적으로 보일수 있으나 코드가 천줄 만줄이라고 생각하면 변수를 쓰는게 좋을것이다.코딩을 할때 위의 주석처럼 구획을 나누어 놓는게 좋다. 변할수 있는 부분이 군데군데 들어가 있다면 그것을 찾아서 수정해야한다. 그럴경우 유지보수가 힘들어진다.비교1.연산자비교는 조건문을 쓸때 꼭 필요하다. 비교 기능 자체는 효용이 크지 않지만 조건문을 사용하기 위해 꼭 필요하다.연산자란 간단하게 말해 = 이다. 변수에 값을 대입할때 사용한다.a=1 //변수 대입연산자 값2. 비교 연산자 (==과===)비교 연산자는 말그대로 비교하고 판별할때 사용한다. 좌항과 우항중 뭐가 작고 큰지 또는 같은지 등을 판별한다. 비교연산자의 결과는 true나 false둘중 하나다. true와 false형식을 블린 데이터라고 부르고 역시 조건문에서 중요하게 사용한다.== ==는 동등연산자로 좌항과 우항의 값이 같다면 true 다르다면 false가 된다.=와 ==는 전혀 다르기 때문에 주의해야한다.alert(A==B)             //falsealert(A==A)             //truealert(\"one\"==\"two\")     //false alert(\"one\"==\"one\")     //true=== === 일치 연산자라고 하고 좌항과 우항이 정확하게 같을때 같다면 true 다르다면 false가 된다. 여기서 정확하게는 아래 코드처럼 형식까지 일치해야 한다는 말이다. 1과 ‘1’은 숫자와 숫자를 문자화시킨 데이터이다. 결론은 ==보다 ===를 쓰는것이 좋겠다.alert(1=='1');              //truealert(1==='1');             //false3.===를 사용하자null과 undefined는 값이 없다는 의미의 데이터 형이다. var a; 라는 코드를 쓰고 alert(a); 를 하면 undefined라는 경고창이 나온다. 값이 정의되지 않았다는 뜻이다. 그리고 var a=null; alert(a);를 하면null이라는 경고창이 나온다. 이말은 작성한사람이 의도적으로 값이 없다는것을 지정한것이다.이말은 프로그래밍에서 의도한것과 의도하지 않은것은 전혀 다른것이다.alert(null == undefined);       //truealert(null === undefined);      //falsealert(true == 1);               //truealert(true === 1);              //falsealert(true == '1');             //truealert(true === '1');            //false alert(0 === -0);                //truealert(NaN === NaN);             //false NaN(Not-a-Number)은 이값은 숫자가 아님을 의미한다.                   //그래서 NaN생성의 가능성이 있는 코드는 비교 연산을 실행하면 안되겠다.4.부정과 부등호!=!는 부정을 의미한다. 1==2는 false다 하지만 1!=2는 true가 된다. 같지 않은게 사실이기 때문이다.alert(1!=2);            //truealert(1!=1);            //falsealert(\"one\"!=\"two\");    //truealert(\"one\"!=\"one\");    //false!==!==는 ===에 부정을 부여한 것으로 정확하게 같지 않다는 의미이다.&gt;좌항과 우항을 비교해주는 연산자로 좌항이 더 크다는것을 의미한다. 더크면 true 작으면 false이다.&lt;는 반대의 의미이다.alert(10&gt;20);   //falsealert(10&gt;1);    //truealert(10&gt;10);   //false&gt;=좌항이 우항보다 크거나 같다는 의미이다. &lt;=는 반대의 의미이고 =&gt;, =&lt;식의 표현은 불가하다.alert(10&gt;=20);      //falsealert(10&gt;=1);       //truealert(10&gt;=10);      //true",
        "url": "/javascript-basic3"
    }
    ,
    
    "javascript-basic2": {
        "title": "Javascript - JavaScript 숫자와 문자",
            "author": "AhnSang0915",
            "category": "",
            "content": "Javascript    JavaScript 기본     JavaScript 숫자와 문자     JavaScript 변수, 비교    JavaScript 조건문    JavaScript 반복문    JavaScript 함수    JavaScript 배열    JavaScript 객체(Object)    JavaScript 모듈    JavaScript UI와 API    JavaScript 정규표현식    JavaScript 함수지향 - 유효범위    JavaScript 함수지향 - 값으로서의 함수와 콜백    JavaScript 함수지향 - 클로저    JavaScript 함수지향 - arguments    함수지향 - 함수의 호출    객체지향 - 객체지향 프로그래밍 소개    객체지향 - 생성자와 new    객체지향 - 전역객체    객체지향 - this    객체지향 - 상속    객체지향-표준 내장객체의 확장    JavaScript 객체지향-ObjectJavaScript 숫자와 문자1. 수의 표현 javascript는 큰따옴표나 작은 따옴표가 붙지 않은 숫자는 숫자로 인식한다.정수, 자연수, 실수 모두 사용가능하고 모두 숫자로 인식한다.javascript에선 포괄적으로 number라고 부르고 다른 프로그래밍 언어들 보다 덜 엄격한 편이다.수식으로는 더하기는 + 빼기는 - 나누기는 / 곱셈은 * 으로 표현한다.2. 수의 연산javascript는 계산 기능이 있는데 우리가 흔히 쓰는 수식과는 조금 다르기 때문에 그 방법을 알아두는게 좋겠다.아래 코드에 아직 배우지 않은 부분이 있는데 뒤에서 자세히 배워볼 예정이다.Math.pow(3,2);       // 9,   3의 2승 Math.round(10.6);    // 11,  10.6을 반올림Math.ceil(10.2);     // 11,  10.2를 올림Math.floor(10.6);    // 10,  10.6을 내림Math.sqrt(9);        // 3,   3의 제곱근Math.random();       // 0부터 1.0 사이의 랜덤한 숫자3. 문자””,’‘내에 들어가는 내용은 javascript가 문자로 인식한다.데이터를 입력하면 javascript는 문자와 숫자를 인식하게 된다.숫자를 “A”나 ‘A’로 감싸면 문자로 인식하게 된다.우리가 작성한 데이터 값은 typeof 라는 명령을 사용하면 데이터의 형식을 알수있다.문자는 string 숫자는 number라는 결과가 나온다.alert(typeof \"1\") //결과 : string \"내용' 이런식의 기입은 할수 없음을 알아두자.여러줄로 표시하기 위해서는 \\n을 사용할 수 있다.alert(\"왔냐.\\n 코딩 연습장이다\")또한 데이터를 입력하다 보면 ‘이나 “ ex)alert(‘egoing’s coding everyday’) 등을 사용 해야할 때가 이있는데 이럴땐 \\뒤에 해당 기호를 넣어 문자로 인식하게 할수 있다.alert(\"egoing's coding everyday\") // \"\"사이에 '가 들어 있기 때문에 사용 가능하다.arlert('egoing\\'s coding everyday')// 역슬래쉬 \\뒤의 어떠한 기호는 문자로 해석된다. escape라고 한다.4. 문자의 연산1+1은 2이다 하지만 “1”+”1”은 “11”이된다. 숫자와 문자의 연산은 전혀 다르다.문자를 더하는 표현은 아래와 같다.alert(\"Ahns\"+\" Coding Gym\") //결과 : Ahns Coding Gym문자의 길이를 구할때는 문자 뒤에 .length를 붙여준다.alert(\"Ahns Coding Gym\".length) //결과 : 15 ",
        "url": "/javascript-basic2"
    }
    ,
    
    "javascript-basic": {
        "title": "Javascript - JavaScript 기본",
            "author": "AhnSang0915",
            "category": "",
            "content": "Javascript    JavaScript 기본     JavaScript 숫자와 문자     JavaScript 변수, 비교    JavaScript 조건문    JavaScript 반복문    JavaScript 함수    JavaScript 배열    JavaScript 객체(Object)    JavaScript 모듈    JavaScript UI와 API    JavaScript 정규표현식    JavaScript 함수지향 - 유효범위    JavaScript 함수지향 - 값으로서의 함수와 콜백    JavaScript 함수지향 - 클로저    JavaScript 함수지향 - arguments    함수지향 - 함수의 호출    객체지향 - 객체지향 프로그래밍 소개    객체지향 - 생성자와 new    객체지향 - 전역객체    객체지향 - this    객체지향 - 상속    객체지향-표준 내장객체의 확장    JavaScript 객체지향-ObjectJavaScript 기본1. 주석 (Comment)주석은 JavaScript Code외의 우리가 쓰는 문자로 사용되는 내용을 말한다.코드 내용에대한 부연설명이나 함수에 대한 기능을 작성할수 있고 불필요한 코드의 실행을 막을수 있다.JavaScript주석의 코드 사용 방법한줄 주석의 경우 - // 내용여러 줄의 경우 - /* 내용 */ 로 사용한다// 한줄 주석 사용시/*     여러줄     주석     사용시*/2. 줄바꿈과 여백JavaScript의 경우 명령이 끝났다는걸 알려주기 위해 ;를 표시해준다 줄바꿈을 할 경우엔 JavaScript에서 자동으로 명령이 끝났다고 판단하지만 한줄에 여러 명령을 쓸 경우가 있어 명령어 뒤엔 ;를 붙여주는게 좋다.    &lt;script type=\"text/javascript\"&gt;        var a = 1; //;을 안넣어도 줄이 바뀌면 명령이 끝났다고 인식한다        alert(a);    &lt;/script&gt;위 코드에서 ;기호를 없애도 줄바꿈을 했기 때문에 명령이 끝났다고 인식할 것 이다.하지만    &lt;script type=\"text/javascript\"&gt;        var a = 1; alert(a); //;가 없다면 var a = 1alert(a) 가 될것이다.            &lt;/script&gt;이런 경우엔 ;가 없다면 하나의 명령이 될 것이다.( var 뒤 띄어쓰기를 해야 하고 =양쪽엔 하지 않아도 된다.)그리고 코드를 썼는데 코드가 다닥다닥 붙어 있다면 코드를 보기 힘들 것이다. 가독성이 좋지 않다는 말이다. Tap키를 명령어와 함수 사이에 적절히 사용해 좀 더 보기 좋게 하는 게 좋을 것이다.",
        "url": "/javascript-basic"
    }
    
    
    };
</script>
<script src="assets/js/lunr.js"></script>
<script src="assets/js/search.js"></script>
            </section>

        </article>

    </div>
</main>

<!-- /post -->

<!-- The #contentFor helper here will send everything inside it up to the matching #block helper found in default.hbs -->
<script>
$(function() {
    var $postContent = $(".post-full-content");
    $postContent.fitVids();
});
</script>



        <!-- Previous/next page links - displayed on every page -->
        

        <!-- The footer at the very bottom of the screen -->
        <footer class="site-footer outer">
            <div class="site-footer-content inner">
                <section class="copyright"><a href="https://AhnSang0915.github.io/">My Coding Practice Gym</a> &copy; 2022</section>
                <section class="poweredby">Proudly published with <a href="https://jekyllrb.com/">Jekyll</a> &
                    <a href="https://pages.github.com/" target="_blank" rel="noopener">GitHub Pages</a> using
                    <a href="https://github.com/jekyllt/jasper2" target="_blank" rel="noopener">Jasper2</a></section>
                <nav class="site-footer-nav">
                    <a href="/">Latest Posts</a>
                    
                    
                    <a href="https://ghost.org" target="_blank" rel="noopener">Ghost</a>
                </nav>
            </div>
        </footer>

    </div>

    <!-- The big email subscribe modal content -->
    
    <div id="subscribe" class="subscribe-overlay">
        <a class="subscribe-overlay-close" href="#"></a>
            <div class="subscribe-overlay-content">
                
                <h1 class="subscribe-overlay-title">Search My Coding Practice Gym</h1>
                <p class="subscribe-overlay-description">
                블로그 포스팅 검색 </p>
                <span id="searchform" method="post" action="/subscribe/" class="">
    <input class="confirm" type="hidden" name="confirm"  />
    <input class="location" type="hidden" name="location"  />
    <input class="referrer" type="hidden" name="referrer"  />

    <div class="form-group">
        <input class="subscribe-email" onkeyup="myFunc()" 
               id="searchtext" type="text" name="searchtext"  
               placeholder="Search..." />
    </div>
    <script type="text/javascript">
        function myFunc() {
            if(event.keyCode == 13) {
                var url = encodeURIComponent($("#searchtext").val());
                location.href = "/search.html?query=" + url;
            }
        }
    </script>
</span>
            </div>
    </div>
    

    <!-- highlight.js -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.10.0/components/prism-abap.min.js"></script>
    <script>$(document).ready(function() {
      $('pre code').each(function(i, block) {
        hljs.highlightBlock(block);
      });
    });</script>

    <!-- jQuery + Fitvids, which makes all video embeds responsive -->
    <script
        src="https://code.jquery.com/jquery-3.2.1.min.js"
        integrity="sha256-hwg4gsxgFZhOsEEamdOYGBf13FyQuiTwlAQgxVSNgt4="
        crossorigin="anonymous">
    </script>
    <script type="text/javascript" src="/assets/js/jquery.fitvids.js"></script>
    <script type="text/javascript" src="https://demo.ghost.io/assets/js/jquery.fitvids.js?v=724281a32e"></script>


    <!-- Paginator increased to "infinit" in _config.yml -->
    <!-- if paginator.posts  -->
    <!-- <script>
        var maxPages = parseInt('');
    </script>
    <script src="/assets/js/infinitescroll.js"></script> -->
    <!-- /endif -->

    


    <!-- Add Google Analytics  -->
    <!-- Google Analytics Tracking code -->
 <script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-xxxxxxxx-x', 'auto');
  ga('send', 'pageview');

 </script>


    <!-- The #block helper will pull in data from the #contentFor other template files. In this case, there's some JavaScript which we only want to use in post.hbs, but it needs to be included down here, after jQuery has already loaded. -->
    
        <script>
$(function() {
    var $postContent = $(".post-full-content");
    $postContent.fitVids();
});
</script>

    

    <!-- Ghost outputs important scripts and data with this tag - it should always be the very last thing before the closing body tag -->
    <!-- ghost_foot -->

</body>
</html>
