<!DOCTYPE html>
<html>
<head>

    <!-- Document Settings -->
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />

    <!-- Base Meta -->
    <!-- dynamically fixing the title for tag/author pages -->



    <title>Search Result</title>
    <meta name="HandheldFriendly" content="True" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <!-- Styles'n'Scripts -->
    <link rel="stylesheet" type="text/css" href="/assets/built/screen.css" />
    <link rel="stylesheet" type="text/css" href="/assets/built/screen.edited.css" />
    <link rel="stylesheet" type="text/css" href="/assets/built/syntax.css" />

    <!--    costom.css-->
    <link rel="stylesheet" type="text/css" href="/assets/built/custom.css" />

    <!--    Font Awsome-->
    <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css">

    <!--    웹폰트 추가-->
    <link rel="stylesheet" href="https://fonts.googleapis.com/earlyaccess/nanumgothic.css">

    <!--    syntax.css-->
    <link rel="stylesheet" type="text/css" href="/assets/built/syntax.css" />


    <!-- highlight.js -->
    <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css">
    <style>.hljs { background: none; }</style>

    <!--[if IE]>
        <style>
            p, ol, ul{
                width: 100%;
            }
            blockquote{
                width: 100%;
            }
        </style>
    <![endif]-->
    
    <!-- This tag outputs SEO meta+structured data and other important settings -->
    <meta name="description" content="Learn Coding" />
    <link rel="shortcut icon" href="https://AhnSang0915.github.io/assets/built/images/favicon.png" type="image/png" />
    <link rel="canonical" href="https://AhnSang0915.github.io/search" />
    <meta name="referrer" content="no-referrer-when-downgrade" />

     <!--title below is coming from _includes/dynamic_title-->
    <meta property="og:site_name" content="My Coding Practice Gym" />
    <meta property="og:type" content="website" />
    <meta property="og:title" content="Search Result" />
    <meta property="og:description" content="Learn Coding" />
    <meta property="og:url" content="https://AhnSang0915.github.io/search" />
    <meta property="og:image" content="https://AhnSang0915.github.io/assets/built/images/blog-cover1.jpg" />
    <meta property="article:publisher" content="https://www.facebook.com/" />
    <meta name="twitter:card" content="summary_large_image" />
    <meta name="twitter:title" content="Search Result" />
    <meta name="twitter:description" content="Learn Coding" />
    <meta name="twitter:url" content="https://AhnSang0915.github.io/" />
    <meta name="twitter:image" content="https://AhnSang0915.github.io/assets/built/images/blog-cover1.jpg" />
    <meta name="twitter:label1" content="Written by" />
    <meta name="twitter:data1" content="My Coding Practice Gym" />
    <meta name="twitter:site" content="@" />
    <meta name="twitter:creator" content="@" />
    <meta property="og:image:width" content="2000" />
    <meta property="og:image:height" content="666" />

    <script type="application/ld+json">
{
    "@context": "https://schema.org",
    "@type": "Website",
    "publisher": {
        "@type": "Organization",
        "name": "My Coding Practice Gym",
        "logo": "https://AhnSang0915.github.io/"
    },
    "url": "https://AhnSang0915.github.io/search",
    "image": {
        "@type": "ImageObject",
        "url": "https://AhnSang0915.github.io/assets/built/images/blog-cover1.jpg",
        "width": 2000,
        "height": 666
    },
    "mainEntityOfPage": {
        "@type": "WebPage",
        "@id": "https://AhnSang0915.github.io/search"
    },
    "description": "Learn Coding"
}
    </script>

    <!-- <script type="text/javascript" src="https://demo.ghost.io/public/ghost-sdk.min.js?v=724281a32e"></script>
    <script type="text/javascript">
    ghost.init({
    	clientId: "ghost-frontend",
    	clientSecret: "f84a07a72b17"
    });
    </script> -->

    <meta name="generator" content="Jekyll 3.6.2" />
    <link rel="alternate" type="application/rss+xml" title="Search Result" href="/feed.xml" />


</head>
<body class="page-template">

    <div class="site-wrapper">
        <!-- All the main content gets inserted here, index.hbs, post.hbs, etc -->
        <!-- < default -->
<!-- The tag above means: insert everything in this file
into the {body} of the default.hbs template -->

<!-- The big featured header, it uses blog cover image as a BG if available -->
<header class="site-header outer">
    <div class="inner">
        <nav class="site-nav">
    <div class="site-nav-left">
        
            
                <a class="site-nav-logo" href="https://AhnSang0915.github.io/">My Coding Practice Gym</a>
            
        
        
            <ul class="nav" role="menu">
    <li class="nav-home" role="menuitem"><a href="/">Home</a></li>
    <li class="nav-about" role="menuitem"><a href="/about/">About</a></li>
    <li class="nav-javascript" role="menuitem"><a href="/tag/javascript/">Javascript</a></li>
    <li class="nav-python" role="menuitem"><a href="/tag/python/">Python</a></li>
    <li class="nav-archive" role="menuitem">
        <a href="/archive.html">All Posts</a>
    </li>
    <li class="nav-archive" role="menuitem">
        <a href="/author_archive.html">Tag별 Posts</a>
    </li>
</ul>
        
    </div>
    <div class="site-nav-right">
        <div class="social-links">
            
            
        </div>
        
            <a class="subscribe-button" href="#subscribe">Search</a>
        
    </div>
</nav>

    </div>
</header>

<!-- Everything inside the #post tags pulls data from the post -->
<!-- #post -->

<main id="site-main" class="site-main outer" role="main">
    <div class="inner">

        <article class="post-full  post page no-image">

            <header class="post-full-header">
                <h1 class="post-full-title">Search Result</h1>
            </header>

            

            <section class="post-full-content">
                <form action="/search" method="get" hidden="hidden">
    <label for="search-box"></label>
    <input type="text" id="search-box" name="query">
</form>

<ul class="mylist" id="search-results"></ul>

<script>
    window.store = {
    
    "python-basic7": {
        "title": "Python - Python 리스트와 튜플 사용하기",
            "author": "AhnSang0915",
            "category": "",
            "content": "Python    Python 기본    Python 숫자 계산하기    Python 변수 만들기    Python 출력 방법    Python 불과 비교, 논리 연산자\\    Python 문자열 사용하기    Python 리스트와 튜플 사용하기Python 리스트와 튜플 사용하기1. 리스트 만들기지금까지는 변ㄴ수에 값을 한 개씩만 저장했다. 여러 값을 저장할 수 있는 리스트를 알아보자. 대괄호로 원하는 값들을 묶어주면 된다.a = [38, 21, 53, 62, 19]a[38, 21, 53, 62, 19]리스트에 여러 가지 자료형 저장하기리스트는 문자열, 정수, 실수, 불 등 모든 자료형을 저장할 수 있고 섞어서 저장해도 된다.person = ['ansang', 31, 9.15, True]person['ansang', 31, 9.15, True]빈 리스트 만들기빈리스트는 []또는 list()로 만들수 있다.a = []a# []b = list()b# []range를 사용하여 리스트 만들기range를 사용해 리스트를 만들어 보자. range는 연속된 숫자를 생성한다. range에 10을 지정하면 0에서 9까지의 숫자를 생성한다.range(10)range(0, 10)a = list(range(10))a[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]range는 시작숫자와 끝나는 숫자를 지정할 수도 있다. 이떄도 끝나는 숫자는 생성되지 않는다.b = list(range(5, 12))b[5, 6, 7, 8, 9, 10, 11]증가폭을 다르게 할수도 있다. 이때는 range(시작, 끝, 증가폭)의 형식으로 작성해주면 된다. 음수로 작성하면 해당 값만큼 감소하는 리스트가 생성된다.c = list(range(-4, 10, 2))c[-4, -2, 0, 2, 4, 6, 8]d = list(range(10, 0, -1))d[10, 9, 8, 7, 6, 5, 4, 3, 2, 1]2. 튜플 사용하기튜플은 리스트처럼 요소를 일렬로 저장하지만, 안에 저장된 요소를 변경, 추가, 삭제할 수 없다. 튜플이 있는 이유는 요소가 변경되지 않고 유지되어야할 때 사용한다. 변수에 값을 저장할때 ()로 묶어주거나 괄호로묶지 않고 ,로 값만 콤마로 구분해도 튜플이 된다.a = (1, 2, 3, 4, 5, 6, 7)a# (1, 2, 3, 4, 5, 6, 7)a = 1, 2, 3, 4, 5, 6, 7a# (1, 2, 3, 4, 5, 6, 7)튜플도 리스트 처럼 여러 자료형을 섞어서 저장할 수 있다.person = ('ansang', 31, 9.15, True)person('ansang', 31, 9.15, True)not은 논리값을 뒤집는다. not True는 False가 되고, not False는 True가 된다. 여기서 and, or, not 논리 연산자가 식 하나에 들어있으면 not, and, or순으로 판단한다.not True and False or not False# False and False or True# False or True# True순서가 헷갈릴 때는 괄호로 판단 순서를 명확히 나타내 주는 것이 좋다.((not True) and False) or (not False)# True요소가 한 개 들어있는 튜플 만들기함수 클래스를 사용하다보면 값이 아닌 튜플을 넣어야 하는 경우도 있다. 이때 요소가 하나인 튜플을 사용해야한다.아래와 같이 요소가 한개 있는 튜플을 만들면 그냥 값이된다.a = (38)a38요소가 하나인 튜플을 만들 때는 ()안에 값을 넣은후 ,를 붙여준다. 또는 괄호로 묶지 않고 값 한개에 ,를 붙여도 된다.a = (38,)a# (38,)a = 38,a# (38,)range를 사용하여 튜플 만들기리스트와 마찬가지로 range를 사용해 튜플을 만들어 보자.a = tuple(range(10))a(0, 1, 2, 3, 4, 5, 6, 7, 8, 9)b = tuple(range(5, 12))b(5, 6, 7, 8, 9, 10, 11)c = tuple(range(-4, 10, 2))c(-4, -2, 0, 2, 4, 6, 8)튜플을 리스트로 만들고 리스트를 튜플로 만들기튜플과 리스트는 요소를 변경, 추가, 삭제할 수 있는지 없는지만 다를 뿐 기능과 형태는 같다. 따라서 튜플을 리스트로 만들거나 리스트를 튜플로 만들 수도 있다.a = [1, 2, 3]a[1, 2, 3]tuple(a)(1, 2, 3)반대로 list안에 튜플을 넣으면 새 리스트가 생성된다.b = (4, 5, 6)b(4, 5, 6)list(b)[4, 5, 6]list와 tuple안에 문자열을 넣으면 문자 리스트, 문자 튜플이 생성된다.list('hello')['h', 'e', 'l', 'l', 'o']tuple('hello')('h', 'e', 'l', 'l', 'o')리스트와 튜플을 사용하면 변수 여러개를 한번에 만들 수 있다. 이떄 변수의 갯수와 리스트의 요소 갯수는 같아야한다.a, b, c = [1, 2, 3]d, e, f = (4, 5, 6)print(a, b, c)1 2 3print(d, e, f)4 5 6리스트와 튜플 변수로도 변수 여러개를 만들 수 있다. 다음과 같이 리스트와 튜플의 요소를 변수 여러 개에 할당하는 것을 리스트 언패킹(list unpacking), 튜플 언패킹(tuple unpacking)이라고 한다.x = [1, 2, 3]a, b, c = xprint(a, b, c)1 2 3y = (4, 5, 6)d, e, f = yprint(d, e, f)4 5 6‘입력 값을 변수 두 개에 저장하기’에서 사용한 input().split()은 리스트를 반환한다. 그래서 리스트 언패킹 형식으로 입력 값을 변수 여러 개에 저장할 수 있었다.input().split()10 20['10', '20']x = input().split()10 20a, b = x         # a, b = input().split()과 같음print(a, b)10 20리스트 패킹(list packing)과 튜플 패킹(tuple packing)은 변수에 리스트 또는 튜플을 할당하는 과정을 뜻한다.a = [1, 2, 3]    # 리스트 패킹b = (1, 2, 3)    # 튜플 패킹c = 1, 2, 3      # 튜플 패킹",
        "url": "/python-basic7"
    }
    ,
    
    "python-basic6": {
        "title": "Python - Python 문자열 사용하기",
            "author": "AhnSang0915",
            "category": "",
            "content": "Python    Python 기본    Python 숫자 계산하기    Python 변수 만들기    Python 출력 방법    Python 불과 비교, 논리 연산자\\    Python 문자열 사용하기    Python 리스트와 튜플 사용하기Python 문자열 사용하기1.문자열 사용하기문자열은 영문 문자열뿐만 아니라 한글 문자열도 사용가능하다. 변수에 문자열을 담아보자.hello = '안녕하세요'파이썬에선 문자열을 작은따옴표, 큰따옴표, 작은따옴표3개, 큰따옴표3개로 묶을 수 있다.hello = '안녕하세요'hello = \"안녕하세요\"hello = '''안녕하세요'''hello = \"\"\"안녕하세요\"\"\"여러 줄로 된 문자열 사용하기여러줄로 된 문자열을 표현하는 방법을 알아보자.hello = \"\"\"안녕하세요파이썬 입니다작성하는 사람은접니다.\"\"\"문자열 안에 작은따옴표나 큰따옴표 포함하기문자열에 작은따옴표나 큰따옴표를 포함하고 싶다면 작은따옴표를 큰따옴표로 감싸주거나 큰따옴표를 작은따옴표로 묵어주면되고 작은따옴표에 작은따옴표를 넣거나 큰따옴표에 큰따옴표를 넣고싶다면 \\를 사용하면 된다.single_quote = '''\"안녕하세요.\"'파이썬'입니다.'''# \"안녕하세요.\"  '파이썬'입니다. double_quote1 = \"\"\"\"Hello\"'Python'\"\"\" #\"Hello\" 'Python'double_quote2 = \"\"\"Hello, 'Python'\"\"\" # Hello, 'Python'a = 'Python isn\\'t difficult'# \"Python isn't difficult\"\\n을 사용하면 여러개의 따옴표를 쓰지 않고도 여러 줄로된 문자열을 사용할 수 있다.print('Hello\\nPython')#결과HelloPython",
        "url": "/python-basic6"
    }
    ,
    
    "python-basic5": {
        "title": "Python - Python 불과 비교, 논리 연산자",
            "author": "AhnSang0915",
            "category": "",
            "content": "Python    Python 기본    Python 숫자 계산하기    Python 변수 만들기    Python 출력 방법    Python 불과 비교, 논리 연산자\\    Python 문자열 사용하기    Python 리스트와 튜플 사용하기Python 불과 비교, 논리 연산자1.불과 비교 연산자 사용하기if, while문에서 많이 사용하게되는 논리 연산자와 참(True), 거짓(False)을 나타내는 불리언(boolean)의 사용방법을 알아보자.boolean은 True, False로 표현하며 1, 3.6, ‘Python’처럼 값의 일종이다.비교 연산자의 판단 결과Python에서 비교 연산자와 논리 연산자의 판단 결과로 True, False를 사용한다. 즉, 비교 결과가 맞으면 True, 틀리면 False이다.1&gt;2False1&lt;2True숫자가 같은지 다른지 비교하기두 숫자가 같은지 다른지 비교하는 데에는 ==(equal), !=(not equal)을 사용한다.10==10True10 != 11True문자열이 같은지 다른지 비교하기문자열도 ==와 !=연산자로 비교 할 수 있다. 이때 문자열의 대소문자도 구분해야 한다. 같은 단어여도 대소문자가 다르면 다른 문자열로 판단한다.'Python' == 'Python'True'Python' == 'python'False'Python' != 'python'True부등호 사용하기부등호는 큰지, 작은지, 크거나 작거나 같은지를 판별한다. 기준은 첫번째 값이다.10 &gt; 20    # 10이 20보다 큰지 비교False10 &lt; 20    # 10이 20보다 작은지 비교True10 &gt;= 10    # 10이 10보다 크거나 같은지 비교True10 &lt;= 10    # 10이 10보다 작거나 같은지 비교True객체가 같은지 다른지 비교하기객체가 같은지 다른지 비교할땐 is와 is not을 사용한다. ==, !=는 값 자체를 비교하고 is와 is not은 객체를 비교한다.1과 1.0은 정수와 실수이다. 데이터의 타입은 다르지만 값은 같기때문에 ==는 True가 나온다. 하지만 1과 1.0을 is로 비교해 보면 False가 나온다. 이유는 1은 정수 객체, 1.0은 실수객체이기 때문이다. 객체로서는 다르기 떄문에 is not으로 비교하면 True가 나온다.1 == 1.0True1 is 1.0False1 is not 1.0True정수객체와 실수객체가 서로 다른지 확인하기정수 객체와 실수 객체가 서로 다른지 확인하려면 id함수를 사용한다. id는 객체의 고유한 값(메모리 주소)를 구한다.(이 값은 파이썬을 실행하는 동안에는 계속 유지되며 다시 실행하면 달라진다)id(1)2156471124208id(1.0)2156509782960값 비교에 is를 쓰지 않기값 자체를 비교할때는 ==와 !=를 사용한다. 변수 a가 있는 상태에서 다른 값을 할당하면 메모리 주소가 달라질 수 있기 때문이다. 따라서 다른 객체가 되므로 값이 같더라고 is로 비교하면 False가 나온다. 값을 비교할 때는 is가 아닌 비교 연산자를 사용해야 한다.a = -5a is -5Truea = -6a is -6Falsea == -6True2. 논리 연산자 사용하기논리 연산자는 and, or, not을 사용한다. and는 두값이 모두 True여야 True이다. 하나라도 False이면 False가 나온다.True and True# TrueTrue and False# FalseFalse and True# FalseFalse and False# Falseor는 두 값 중 하나라도 True이면 True, 두값이 모두 False면 False가 된다.True or True#TrueTrue or False# TrueFalse or True# TrueFalse or False# Falsenot은 논리값을 뒤집는다. not True는 False가 되고, not False는 True가 된다. 여기서 and, or, not 논리 연산자가 식 하나에 들어있으면 not, and, or순으로 판단한다.not True and False or not False# False and False or True# False or True# True순서가 헷갈릴 때는 괄호로 판단 순서를 명확히 나타내 주는 것이 좋다.((not True) and False) or (not False)# True논리 연산자와 비교 연산자를 함께 사용하기논리연산자와 비교 연산자를 함께 사용해보자. 이때는 비교 연산자(is, is not, ==, !=, &lt;, &gt;, &lt;=, &gt;=)를 먼저 판단하고 논리 연산자(not, and, or)를 판단하게된다.10 == 10 and 10 != 5    # True and True# True10 &gt; 5 or 10 &lt; 3        # True or False# Truenot 10 &gt; 5              # not True# Falsenot 1 is 1.0            # not False# True정수, 실수, 문자열을 불로 만들기정수, 실수, 문자열을 True, False로 만들어 보자. 정수1은 True 0은 False이다. 문자열의 내용이 ‘False’라도 불로 만들면 Ture가 된다. 문자열의 경우 값이 있으면 True로 나타낸다. 정수0, 0.0이외의 숫자는 모두 True, 빈문자열 ‘’, ““를 제외한 모든 문자열은 True가된다.bool(1)# Truebool(0)# Falsebool(1.5)# Truebool('False')# Truebool('')# Falsebool(\"\")# Falsebool(0)# Falsebool(0.0)# False단락 평가논리 연산에서 중요한 것이 단락 평가(short-circuit evalution)이다. 단락 평가는 첫번째 값만으로 결과가 확실할 때 두 번째 값은 평가하지 않는 방법이다.# 첫 번째 값이 거짓이므로 두 번째 값은 확인하지 않고 거짓으로 결정print(False and True)     # Falseprint(False and False)    # False# 첫 번째 값이 참이므로 두 번째 값은 확인하지 않고 참으로 결정print(True or True)     # Trueprint(True or False)    # TrueTrue and ‘Python’를 확인하면 True가 나올것 같지만 ‘Python’이 나온다. 파이썬에서 논리 연산자는 마지막 단락 평가를 실시한 값을 그대로 반환하기 때문이다. 마지막에 단락평가를 실시한 값이 불이면 불을 반환한다.True and 'Python'# 'Python'True and 'ansang'# 'ansang''Python' and True# True'ansang' and True# True여기서는 문자열 ‘Python’을 True로 쳐서 and 연산자가 두 번째 값까지 확인하므로 두 번째 값이 반환된다.만약 다음과 같이 and 연산자 앞에 False나 False로 치는 값이 와서 첫 번째 값 만으로 결과가 결정나는 경우에는 첫 번째 값이 반환된다.False and 'Python'#False0 and 'Python'    # 0은 False이므로 and 연산자는 두 번째 값을 평가하지 않음#0or 연산자도 마찬가지로 마지막으로 단락 평가를 실시한 값이 반환된다. 다음은 or 연산자에서 첫 번째 값만으로 결과가 결정되므로 첫 번째 값이 반환된다.True or 'Python'# True'Python' or True# 'Python'만약 두번째 값까지 판한해야 한다면 두 번째 값이 반환된다.False or 'Python'# 'Python'0 or False# False",
        "url": "/python-basic5"
    }
    ,
    
    "python-basic4": {
        "title": "Python - Python 출력 방법",
            "author": "AhnSang0915",
            "category": "",
            "content": "Python    Python 기본    Python 숫자 계산하기    Python 변수 만들기    Python 출력 방법    Python 불과 비교, 논리 연산자\\    Python 문자열 사용하기    Python 리스트와 튜플 사용하기Python 출력 방법 알아보기1.값을 여러 개 출력하기print 하나로 여러개의 값을 출력하는 방법을 알아보자.print에 변수나 값 여러개를 ,(콤마)로 구분하여 여러개를 넣을 수 있다.print(1, 2, 3)# 1 2 3print('Hello', 'python')# Hello pythona=20b=30c=40print(a,b,c)# 20 30 40sep로 값 사이에 문자 넣기그런데 값 사이에 공백이 아닌 다른 문자를 넣고 싶을 수도 있다. 이때는 다음과 같이 print의 sep에 문자 또는 문자열을 지정해주면 된다.print(1, 2, 3, sep=', ')    # sep에 콤마와 공백을 지정# 1, 2, 3print(4, 5, 6, sep=',')    # sep에 콤마만 지정# 4,5,6print('Hello', 'Python', sep='')    # sep에 빈 문자열을 지정# HelloPythonprint(1920, 1080, sep='x')    # sep에 x를 지정# 1920x10802. 줄바꿈 활용하기출력되는 값을 줄바꿈 해 출력하는 방법을 알아보자. print의 sep에 개행 문자(\\n)라는 특별한 문자를 지정하면 값을 한 줄에 하나씩 출력할 수 있다.print(1, 2, 3, sep='\\n')123print에서도 여러줄로 출력이 가능하다.다음과 같이 문자열 안에 \\n를 넣으면 1 2 3은 세 줄로 출력이 된다.print('1\\n2\\n3')123제어 문자제어 문자는 화면에 출력되지 않지만 출력 결과를 제어한다고해서 제어 문자라고 부른다. 제어 문자는 \\로 시작하는 이스케이프 시퀀스 이다.  \\n: 다음 줄로 이동하며 개행이라고도 부릅니다.  \\t: 탭 문자, 키보드의 Tab 키와 같으며 여러 칸을 띄웁니다.  \\: \\ 문자 자체를 출력할 때는 \\를 두 번 써야 합니다.end 사용하기print는 기본적으로 출력하는 값 끝에 \\n을 붙인다. 그래서 print를 여러 번 사용하면 값이 여러 줄에 출력된다.print(1)print(2)print(3)# 결과123print를 여러 번 사용해서 print(1, 2, 3)처럼 한 줄에 여러 개의 값을 출력할 수 있다. 이때는 print의 end에 빈 문자열을 지정해주면 된다.print(1, end='')    # end에 빈 문자열을 지정하면 다음 번 출력이 바로 뒤에 오게 됨print(2, end='')print(3)#결과123즉, end는 현재 print가 끝난 뒤 그 다음에 오는 print 함수에 영향을 준다. 만약 1 2 3 사이를 띄워주고 싶다면 end에 공백 한 칸을 지정하면 된다.print(1, end=' ')    # end에 공백 한 칸 지정print(2, end=' ')print(3)# 결과1 2 3",
        "url": "/python-basic4"
    }
    ,
    
    "python-basic3": {
        "title": "Python - Python 변수 만들기",
            "author": "AhnSang0915",
            "category": "",
            "content": "Python    Python 기본    Python 숫자 계산하기    Python 변수 만들기    Python 출력 방법    Python 불과 비교, 논리 연산자\\    Python 문자열 사용하기    Python 리스트와 튜플 사용하기Python 변수 만들기1.변수와 입력 사용하기변수(variable)을 만들고 결과를 저장하는 방법을 알아보자.변수 만들기x = 100 이라고 입력하면 100이 들어있는 변수 x가 만들어진다. 즉, 변수이름 = 값 형식이다. 이렇게 하면 변수가 생성되는 동시에 값이 할당(저장)된다.  영문 문자와 숫자를 사용할 수 있습니다.  대소문자를 구분합니다.  문자부터 시작해야 하며 숫자부터 시작하면 안 됩니다.  _(밑줄 문자)로 시작할 수 있습니다.  특수 문자(+, -, *, /, $, @, &amp;, % 등)는 사용할 수 없습니다.  파이썬의 키워드(if, for, while, and, or 등)는 사용할 수 없습니다.x = 100y = \"Hello, world\"변수의 자료형 알아내기변수도 마찬가지로 type을 넣어 변수(객체)의 타입이 나온다.type(x)&lt;class 'int'&gt;type(y)&lt;class 'str'&gt;변수 여러 개를 한 번에 만들기변수를 한번에 여러개 만드는 방법은 아래와 같다. 변수이름1, 변수이름2, 변수이름3 = 값1, 값2, 값3 형식으로 변수를 ,(콤마)로 구분한 뒤 각 변수에 할당될 값을 지정해주면 된다. 변수와 값의 갯수는 동일하게 맞춰주어야 한다.x, y, z = 10, 20, 30x# 10y# 20z# 30여러개의 변수를 만들때 값이 같다면 = 같은 값을 지정할수 있다.변수1 = 변수2 = 변수3 = 값 형식으로 변수 여러 개를 =로 연결하고 마지막에 값을 할당해주면 같은 값을 가진 변수 3개가 만들어진다.x = y = z = 20x#20y#20z#20두 변수의 값을 바꿀 수 있다. 변수1, 변수2 = 변수2, 변수1 형식으로 두 변수의 값을 바꿀 수 있다.x, y = 10, 20x, y = y, xx# 20y# 10변수를 삭제하려면 del을 사용하면 되고 확인 해 보면 아래와 같이 찾을수 없다고 나온다.del xxTraceback (most recent call last):  File \"&lt;pyshell#20&gt;\", line 1, in &lt;module&gt;    xNameError: name 'x' is not defined값이 들어있지 않은 빈 변수도 만들 수 있다. 변수 = None형식으로 만든다. 파이썬에서 None은 아무것도 없는 상태를 말하고 다른 언어에서는 null이라고 표현한다.x = Nonex# 아무것도 출력되지 않는다.2.변수로 계산하기계산값을 변수로 지정해 저장하는 방법을 알아보자. 변수 a, b에 숫자를 할당한 뒤에 a와 b의 값을 더해서 변수 c에 할당했다. 이렇게 변수는 변수끼리 계산할 수 있고, 계산 결과를 다른 변수에 할당할 수 있다.a=10b=20c=a+bc30산술 연산 후 할당 연산자 사용하기변수의 값을 증가시키는 방법이다. a의 값에20을 더할뿐 결과를 저장히지는 않는다.a=10a+2030a10변수의 값을 저장하려면 결과를 다시 변수에 저장해야 한다.a = 10a += 20 # a = a + 20a30a를 다시 입력하지 않고 결과를 저장하는 방법이다. +=처럼 산술연신자 앞에 할당연산자(+)를 붙이면 연산 결과를 변수에 저장한다. -=, /=, //=, %=, *=도 사용 가능하다.a=10a=a+20a30할당 연산자를 만들때 주의할 점이다. 변수d를 지정하지 않고 코드를 입력하면 아래와 같은 에러가 나온다. 변수를 지정하고 변수를 사용해 계산을 해야한다.d = d +10Traceback (most recent call last):  File \"&lt;pyshell#57&gt;\", line 1, in &lt;module&gt;    d = d +10NameError: name 'd' is not defined. Did you mean: 'id'?값을 실수로 만들기어떤 값을 강제로 실수로 만드는 방법을 알아보자.float는 부동소수점(floating point)에서 따왔으며 값을 실수로 만들어준다. 즉, 실수는 float 자료형이며 type에 실수를 넣어보면 &lt;class ‘float’&gt;가 나온다.float(1+2)#3.0float('5')# 5.0float(5.3)# 5.3type(3.5)      &lt;class 'float'&gt;계산을 하다보면 부호를 붙여야 할 때도 있다. 이때는 값이나 변수 앞에 양수, 음수 부호를 붙이면 된다.x = -10+x-10-x10복소수파이썬에서는 실수부와 허수부로 이루어진 복소수(complex number)도 사용할 수 있다. 이때 허수부는 숫자 뒤에 j를 붙인다(수학에서는 허수를 i로 표현하지만 공학에서는 j를 사용한다).두 실수를 복소수로 만들 때는 complex를 사용하면 된다.1.2+1.3j# (1.2+1.3j)#두 실수를 복소수로 만들 때complex(1.2, 1.3)# (1.2+1.3j)3.입력 값을 변수에 저장하기매번 다른 값을 변수에 할당하는 방법을 알아보자. input()을 사용하면 사용자가 입력한 값을 가져올 수 있다.input()hello, world!'hello, world!'input()안상현'안상현'함수의 결과를 변수에 할당하기input함수의 결과를 변수에 할당했다.x = input()hello world!x'hello world!'위 코드에서 불편한점은 input함수가 실행된 다음에 아무 내용이 없어서 입력을 받는 상태인지 출력이 없는 상태인지 알 수가 없다는 점이다. 이때는 input의 괄호 안에 문자열을 지정해준다.x = input('문자열을 입력하세요')문자열을 입력하세요우리집 강아지는 보름이x'우리집 강아지는 보름이'위 코드는 사용자에게 입력받는 값의 용도를 미리 알려줄 때 사용한다. 다른 말로는 prompt라고도 부른다.두 숫자의 합 구하기숫자 두개를 입력받은 뒤에 두  숫자의 합을 구해보자. 아래 코드를 실행한 결과는 1020이다. input에서 입력받은 값은 항상 문자열 형태이기 때문이다.a = input('첫 번째 숫자를 입력하세요: ')첫 번째 숫자를 입력하세요: 10b = input('두 번째 숫자를 입력하세요: ')두 번째 숫자를 입력하세요: 20print(a + b)1020변수에 값을 input으로 할당하고 데이터 타입을 확인하면 아래와 같이str(string)이 출력되게 된다.a = input()10type(a)# &lt;class 'str'&gt;입력 값을 정수로 변환하기10 + 20의 결과가 30이 나오게 하려면 input에서 입력받은 문자열을 숫자(정수)로 들어주어야 한다. int로 문자열’10’을 정수 10으로 바꿔준다. 만약 실수를 더하려면 int대신 float를 사용한다.a = int(input('첫 번째 숫자를 입력하세요: '))    # int를 사용하여 입력 값을 정수로 변환b = int(input('두 번째 숫자를 입력하세요: '))    # int를 사용하여 입력 값을 정수로 변환 print(a + b)4. 입력 값을 변수 두 개에 저장하기input 한번에 값을 여러 개 입력받는 방법을 알아보자. input에서 split을 사용하여 변수 여러 개에 저장해주면 된다. 공백으로 변수 a와 b의 값을 구분짓는다.a, b = input('문자열 두 개를 입력하세요: ').split()문자열 두 개를 입력하세요: an sangprint(a)anprint(b)sang두 숫자의 합 구하기두 숫자의 합을 구해보는 예제이다. 전 항목에서와 마찬가지로 input으로 입력받은 값은 문자열 이기 때문에 합의 값이 1020이 나온다.a, b = input('숫자 두개를 입력하세요: ').split()숫자 두개를 입력하세요: 10 20print(a + b)1020입력 값을 정수로 변환하기a = int(a)와 같이 int에 변수를 넣은 뒤 다시 변수에 저장해주면 변수가 정수 자료형으로 변환된다.a = int(a)b = int(b)print(a + b)30print안에서 int로 바꾸어 정수값을 얻는 방법도 있다.print(int(a) + int(b))# 30map을 사용하여 정수로 변환하기 map에 int와 input().split()을 넣으면 int로 변환하지 않아도 split의 결과를 모두 int로 변환해준다(실수로 변환할 때는 int 대신 float를 넣는다.).a, b = map(int, input('숫자 두 개를 입력하세요: ').split())숫자 두 개를 입력하세요: 10 20print(a + b)30### 입력받는 값을 콤마를 기준으로 분리하기split에 기준 문자열을 지정하여 공백이 아닌 다른 문자로 값을 분리해 보자.a, b = map(int, input('숫자 두 개를 입력하세요: ').split(','))숫자 두 개를 입력하세요: 10,20print(a + b)30",
        "url": "/python-basic3"
    }
    ,
    
    "python-basic2": {
        "title": "Python - Python 숫자 계산하기",
            "author": "AhnSang0915",
            "category": "",
            "content": "Python    Python 기본    Python 숫자 계산하기    Python 변수 만들기    Python 출력 방법    Python 불과 비교, 논리 연산자\\    Python 문자열 사용하기    Python 리스트와 튜플 사용하기Python 숫자 계산하기1.정수 계산하기파이썬은 파이썬 셸을 통하여 입력한 코드의 결과를 즉스 출력할수 있었다. 파이썬의 숫자의 타입은 정수, 실수, 복소수가 있다. 정수는 말그대로 123같은 숫자를 나타내고 실수는 소수점이 있는 숫자, 복소수는 제곱을 할때 -가 나오는 수를 말한다. 정수는 int, 실수는 float, 복소수는 complex라고 한다.사칙연산사칙연산은 +,-,*(곱하기),/(나누기)를 사용할 수 있다.1+1# 21-1# 01-2# -12*2# 45/2# 2.54/2# 2.0연산자 // (버림 나눗셈)나눗셈후 소수점 이하를 버리는 연산자는 //이다. 정수로 계산을하면 정수로 테이터를 얻을수 있다. 하지만 실수로 계산하면 실수로 나오고 소수점 이하는 버리게되어 .0으로 나오게된다.5 // 2#24 // 2# 25.5 // 2# 2.04 // 2.0# 2.04.1 // 2.1# 1.0연산자 % (나머지를 구하는 연산자)%로 나누기를 하게되면 나머지 값을 구할 수 있다.5 % 2# 1연산자 ** (거듭제곱을 구하는 연산자)**를 사용해 거듭 제곱을 할 수 있다.2**3# 82**10# 1024값을 정수로 만들기계산결과가 실수로 나왔을때 강제로 정수로 만들 수 있다. int뒤에 괄호를 붙이고 숫자 또는 계산식을 넣어주면 된다. int뒤에 문자열을 넣어도 정수로 만들 수 있다. 하지만 정수로된 문자열만 가능하다. 실수 문자열을 넣어주면 아래와 같은 문법오류가 나온다.int(5.20)#5int('10.3')# Traceback (most recent call last):#   File \"&lt;pyshell#14&gt;\", line 1, in &lt;module&gt;#     int('10.3')# ValueError: invalid literal for int() with base 10: '10.3'int(-8.3)#-8객체의 자료형 알아내기객체의 타입을 알아내는 함수는 type이고 ()에 타입을 확인하고 싶은 데이터를 넣는다. &lt;class ‘int’&gt;라고 하는것은 정수라는 이야기고 class는 python에서 객체를 나타내는 표현법이다. 정수로 만드는 방법인 int()의 경우 ()안의 데이터를 int클래스로 된 객체로 만들겠다는 말이다.type(10)      # &lt;class 'int'&gt;몫과 나머지를 함께 구하기몫과 나머지를 함께 구하려면 diwmod를 사용한다.divmod(5, 2)      # (2, 1) 데이터를 괄호로 묶은 형태를 튜플(tuple)이라고 한다.a, b = divmod(5, 2)      print(a, b)      2 12진수, 8진수, 16진수정수는 10진수 이외에도 2진수, 8진수, 16진수로도 표현할 수 있다.      2진수: 숫자 앞에 0b를 붙이며 0과 1을 사용한다.        8진수: 숫자 앞에 0o(숫자 0과 소문자 o)를 붙이며 0부터 7까지 사용한다.        16진수: 숫자 앞에 0x 또는 0X를 붙이며 0부터 9, A부터 F까지 사용한다(소문자 a부터 f도 가능).  0b110# 60o10# 80xF# 152.실수 계산하기소수점이 붙은 것을 실수라한다. 실수의 계산을 알아보자.아래 뺄셈의 경우 다소 어려운 주제이다. 실무에서 실수를 다룰때는 적절한 처리가 필요하다.3.5+2.1# 5.64.3-2.7# 1.59999999999999961.5*3.1# 4.655.5/3.1# 1.7741935483870968실수와 정수를 함께 계산실수와 정수를 함께 계산할 경우 표현 범위가 넓은 실수로 출력된다.4.2+5# 9.2값을 실수로 만들기어떤 값을 강제로 실수로 만드는 방법을 알아보자.float는 부동소수점(floating point)에서 따왔으며 값을 실수로 만들어준다. 즉, 실수는 float 자료형이며 type에 실수를 넣어보면 &lt;class ‘float’&gt;가 나온다.float(1+2)#3.0float('5')# 5.0float(5.3)# 5.3type(3.5)      &lt;class 'float'&gt;복소수파이썬에서는 실수부와 허수부로 이루어진 복소수(complex number)도 사용할 수 있다. 이때 허수부는 숫자 뒤에 j를 붙인다(수학에서는 허수를 i로 표현하지만 공학에서는 j를 사용한다).두 실수를 복소수로 만들 때는 complex를 사용하면 된다.1.2+1.3j# (1.2+1.3j)#두 실수를 복소수로 만들 때complex(1.2, 1.3)# (1.2+1.3j)3.괄호 사용하기곱셈보다 덧셈을 먼저 계산하고 싶다면 괄호로 묶어준다.7 + (10 - 5) * 2# 17",
        "url": "/python-basic2"
    }
    ,
    
    "practice-1": {
        "title": "연습문제 - 나도코딩 예제",
            "author": "AhnSang0915",
            "category": "",
            "content": "Python 연습문제나도코딩 예제예) http://naver.com규칙 1 : http://부분을 제외 규칙 2 : 처음 만나는 점(.) 이후 부분은 제외규칙 3 : 남은 글자 중 처음 세자리 + 글자 갯수 + 글자 내 “e” 갯수 + “!” 로 구성예) 생성된 비밀번호 : nav51!아래 문제의 포인트는 url주소가 naver가 아니더라도 출력이 잘 되야 하는것이다.#내가 푼 답안url = \"http://naver.com\"first = url[7 : url.index(\".\")]first1 = first[:3]len = len(first)e = first.count(\"e\")print(f\"생성된 비밀번호 : {first1}{len}{e}%s\" %\"!\")# 선생님답안url = \"http://naver.com\"rule1 = url.replace(\"http://\", \"\")rule1 = rule1[:rule1.index(\".\")]password = rule1[:3] + str(len(rule1)) + str(rule1.count(\"e\"))+\"!\"print(\"{}의 비밀번호는 {} 입니다.\".format(url, password))",
        "url": "/practice-1"
    }
    ,
    
    "python-basic": {
        "title": "Python - Python 기본",
            "author": "AhnSang0915",
            "category": "",
            "content": "Python    Python 기본    Python 숫자 계산하기    Python 변수 만들기    Python 출력 방법    Python 불과 비교, 논리 연산자\\    Python 문자열 사용하기    Python 리스트와 튜플 사용하기Python 기본Python은 세미콜론(;)을 안붙여도 된다.파이썬은 세미콜론이 없어도 된다. 세미콜론을 붙여도 문법적 오류가 발생하지 않는다. 하지만 필요없는 내용을 코드에 작성할 필요는 없을것 같다.Python의 주석파이썬에서 사람만 알아볼 수 있도록 작성하는 부분을 주석(comment)라고 한다. 즉, 주석은 파이썬 인터프리터가 처리하지 않으므로 프로그램의 실행에는 영향을 주지 않는다. 아래는 파이썬의 주석처리 방법이다.한줄 주석의 경우 주석의 내용 앞에 #를 붙여준다. 일반적으로 #뒤에 한칸을 띄어쓰기하고 사용한다.# print(\"파이썬 공부하자\")파이썬의 여러줄 주석은 ‘'’이나 “\"”을 앞뒤로 붙여주면 된다.'''print(\"파이썬 공부하자\")print(\"파이썬 공부하자\")print(\"파이썬 공부하자\")'''\"\"\"print(\"파이썬 공부하자\")print(\"파이썬 공부하자\")print(\"파이썬 공부하자\")\"\"\"들여쓰기들여쓰기란 코드의 가독성을 높이기 위해 일정한 간격을 띄워서 작성하는 방법이다. 파이썬은 들여쓰기가 문법으로 되어있어 들여쓰기를 하지 않으면 문법 오류가 나오게 된다.if a == 10:print('10입니다.')    # 들여쓰기 문법 에러#IndentationError: expected an indented blockif a == 10:   print('10입니다.')  코드블록특정한 동작을 위해 코드가 모여있는 상태를 코드블록 이라고 한다. 주의할 점은 같은 블록은 들여쓰기 칸수가 같아야고 공백과 tap을 같이 사용하면 안된다.if a == 10:      print('10')      print('입니다.')",
        "url": "/python-basic"
    }
    ,
    
    "javascript-basic25": {
        "title": "Javascript - JavaScript 객체지향 - 참조",
            "author": "AhnSang0915",
            "category": "",
            "content": "Javascript    JavaScript 기본     JavaScript 숫자와 문자     JavaScript 변수, 비교    JavaScript 조건문    JavaScript 반복문    JavaScript 함수    JavaScript 배열    JavaScript 객체(Object)    JavaScript 모듈    JavaScript UI와 API    JavaScript 정규표현식    JavaScript 함수지향 - 유효범위    JavaScript 함수지향 - 값으로서의 함수와 콜백    JavaScript 함수지향 - 클로저    JavaScript 함수지향 - arguments    함수지향 - 함수의 호출    객체지향 - 객체지향 프로그래밍 소개    객체지향 - 생성자와 new    객체지향 - 전역객체    객체지향 - this    객체지향 - 상속    객체지향-표준 내장객체의 확장    JavaScript 객체지향-ObjectJavaScript 객체지향 - 참조1. 복제란?바로 이러한 특징이 소프트웨어를 기존의 산업과 구분하는 가장 큰 특징일 것이다. 프로그래밍에서 복제가 무엇인가를 살펴보자.아래 코드의 결과는 1이다. 2행에서 var b = a; 3행에서 b = 2;기떄문에 2가 아닌가 생각할 수 있지만 그렇지 않다. a와 b는 각각다른 데이터를 갖고있기 때문에 a의 값에는 영향을 주지 않는다. 두 변수는 연결되어 있지 않은 별도의 데이터이다.var a = 1;var b = a;b = 2;console.log(a); //12. 참조객체는 어떻게 동작하는지 알아보자. b = a;라고 했고 b에는 {‘id’:1};이런 값이 들어가게 될것이다. 그상태 에서 b.id로 b의 id값을 2로바꿨다. 그리고 a의 id값을 체크하면 값이 2가된다. 이말은 b의 프로퍼티 값을 변경하면 a의 프로퍼티 값이 변경 된다는 것이다.var a = {'id':1}; //a라는 변수에 di가 1인 객체를 지정var b = a;b.id = 2;console.log(a.id);  // 2아래의 예제는 1을 출력한다. b = {‘id’ : 2};로 새로운 객체를만들어 변수b에 할당을 한것이다. 그렇기 때문에 b라는 변수는 더이상 {‘id’:1};를 의미하지 않고 새롭게 만들어진 {‘id’ : 2};를 의미하게 되는 것이다.var a = {'id':1}; var b = a;b = {'id' : 2};  //객체를 생성한것이다.console.log(a.id); //1//사실상 아래의 코드와 같다.var a = 1;var b = a;b = 2;console.log(a); //1변수에 담겨진 값이 객체인경우 b = a;라고 했을때 b와 a는 똑같은 객체를 바라보게된다. 하지만 데이터가 원시 데이터 타입인 경우 b = a;라고하면 이순간에 a에 담겨있던 값이 복제되어 새로만들어지고 그값이 b에 담겨지게 되는것이다. 즉 참조건 복제건 상관없이, 원시데이터이건 객체건 상관없이 새로운 데이터를 만들어서 그것을 변수에 할당하면 새로운 데이터의 값을 바라보게 되지만 지만 객체는 b = a; 라고 했을 때 객체는 똑같은 객체를 각각의 변수들이 바라보게 되는것이고 원시데이터에서 b = a;라고 했을땐 a가 바라보던 값을 b가 만들어졌을땐 복제한 별개의 값을 바라보게 되는것이다.3. 함수와 참조그럼 일종의 변수할당이라고 할 수 있는 메소드의 매개변수는 어떻게 동작하는가를 살펴보자. 조금 복잡하므로 꼼꼼하게 살펴봐야 한다. 예제를 보자.다음은 원시 데이터 타입을 인자로 넘겼을 때의 동작 모습이다. a에 1이라는 값이 담겨있다. 그리고 함수를 정의했는데 매개변수(parameter)인 b의값을 2로 바꾸고있다. 그리고 함수를 호출할때 a를 전달했다. 이말은 b = a;라는 것과 같다. a=1인상태이고 b=a;, 그리고 b=2; 인것이다. 여기서 a=1이고 함수가 b = a;라는 의미이기 때문에 복제와 같다. a=1의 값이 함수 b에 들어가지만 함수내의 b=2;로 b=2가되고 개별의 데이터인 a는 그대로 1이되게 된다.var a = 1;function func(b){ // b = a; 라는것이다.    b = 2;}func(a);console.log(a);이번에는 변수에 담긴 값이 객체이다. a = {‘id’:1};이고 위 함수와 마찬가지로 b = a;를 의미하고 a는 객체이기 때문에 b와 a는 똑같은 객체를 바라보고 있는 상황이지만 b = {‘id’:2};가 새로운 객체를 만들었고 b에 새로운 객체를 할당했기 때문에 b는 {‘id’:2};를 바라보고 있다. 그렇기 때문에 b와 a가 같은 객체를 바라보지 않게 되는것이다. 따라서 결과는 1이다.var a = {'id':1};function func(b){    b = {'id':2};}func(a);console.log(a.id);  // 1아래는 결과가 다르다. 아래도 마찬가지로 b = a;를 함수로 나타내고 있지만 b.id = 2;로 b와a는 데이터가 객체이기 때문에 같은 객체를 바라보고 있다. b.id = 2;로 a의 값도 바뀌기 때문에 결과는 2가된다.var a = {'id':1};function func(b){    b.id = 2;}func(a);console.log(a.id);  // 2",
        "url": "/javascript-basic25"
    }
    ,
    
    "javascript-basic24": {
        "title": "Javascript - JavaScript 객체지향 - 데이터타입",
            "author": "AhnSang0915",
            "category": "",
            "content": "Javascript    JavaScript 기본     JavaScript 숫자와 문자     JavaScript 변수, 비교    JavaScript 조건문    JavaScript 반복문    JavaScript 함수    JavaScript 배열    JavaScript 객체(Object)    JavaScript 모듈    JavaScript UI와 API    JavaScript 정규표현식    JavaScript 함수지향 - 유효범위    JavaScript 함수지향 - 값으로서의 함수와 콜백    JavaScript 함수지향 - 클로저    JavaScript 함수지향 - arguments    함수지향 - 함수의 호출    객체지향 - 객체지향 프로그래밍 소개    객체지향 - 생성자와 new    객체지향 - 전역객체    객체지향 - this    객체지향 - 상속    객체지향-표준 내장객체의 확장    JavaScript 객체지향-ObjectJavaScript 객체지향-테이터 타입1. 원시 데이터 타입과 객체데이터 타입은 크게 2가지로 구분할 수 있다. 원시 데이터 타입과 객체 데이터 타입이다. 원식 데이터 타입은 기본데이터 타입이라고도 하고 객체 데이터 타입은 참조 데이터 타입이라고도 한다. 객체가 아닌 데이터 타입을 원시 테이터 타입이라고 하고 아래와같다.  숫자  문자열  boolean(true/false)  null  nudefined위 항목의 데이터 타입을 원시 데이터 타입 이라고 하고 이외의 모든 데이터 타입을 객체 데이터 타입이라고 한다.2. 래퍼 객체위와 같은 데이터 타입을 분류하는게 중요한것은 아니고 개발자 입장에서 이러한것이 효용을 갖기 위해서는 원시데이터 타입과 객체가 서로 다르게 동작할 때에 효용이 있는것 이다.아래 코드는 문자열을 변수에 담았다. 문자열의 길이와 문자열의 첫번째 값을 출력한다. 객체가 아닌것은 원시데이터 타입이다. 문자열은 원시데이터 타입인데 아래 console.log를보면 객체처럼 동작하고 있다. 이 .의 정식 명칭은 Object access operator이고 객체접근 연산자 라는 뜻이다. 이 .을썻다는것은 .앞에있는 것이 객체라는 것을 의미한다. 객체이기 때문에 length프로퍼티와 charAt(0)메소드가 존재하는것이다. 이말은 str에 담겨있는 무엇인가가 객체이고 문자열은 객체라는 것이다. Javascript에서 문자열이 원시데이터가 맞긴한데 그문자열을 우리가 제어하기 위해서, 여기서는 문자열의 길이와 첫번째 값을 구하기 위해서는 원시데이터 타입인 문자열이 마치 객체인 것 처럼 동작 해야지만 이런 작업을 할 수 있다. 그런 이유로 인해서 Javascript에서 문자열과 같은 원시데이터 타입은 그것을 객체로서 사용할때 그것을 임시로 객체데이터 타입으로 만들어준다. 우리가 str.length를 할때 그순간에 내부적으로 str = new String(‘coding’); 이라고하는 객체를 생성해 str변수에 담아준것과 같은 작업이 1행과 2행 사이에 생긴다고 보면 된다.var str = 'coding';console.log(str.length);        // 6console.log(str.charAt(0));     // \"C\"‘coding’이라는 문자열을 str변수에 담았고 str.prop로 prop라는 프로퍼티를 지정했다. 거기에 ‘everybody’라는 텍스트를 넣었다. console.log(str.prop);로 출력을 하려고하면 undefined가 출력된다. 이말은 우리가 우리가 str.prop = ‘everybody’를통해 문자열을 객체화 시킨후 그 다음행으로 문제없이 넘어갈 수 있게 되는데 이순간엔 객체가 만들어졌지만 끝난후에 그 객체를 제거하고 원래의 원시 데이터 타입으로 변경했기 때문에 prop라는 값이 존재하지 않는것이다.var str = 'coding';str.prop = 'everybody';console.log(str.prop);      // undefined원시 데이터 타입은 객체처럼 사용하려고 할때 자동으로 만들어지는 객체를 래퍼객체(Wrapper Object)라고 한다. 원시 데이터 타입이 있을 때 그 원시 데이터 타입을 감싸주는 객체가 만들어져 객체화 시켜주는게 래퍼객체이다.  숫자 (Number)  문자열 (String)  boolean(true/false) (Boolean)  null X  nudefined Xnull과 nudefined은 래퍼객체가 존재하지 않는다. 객체화 시키려고 하면 타입에러가 발생할 것이다.",
        "url": "/javascript-basic24"
    }
    ,
    
    "javascript-basic23": {
        "title": "Javascript - JavaScript 객체지향-Object",
            "author": "AhnSang0915",
            "category": "",
            "content": "Javascript    JavaScript 기본     JavaScript 숫자와 문자     JavaScript 변수, 비교    JavaScript 조건문    JavaScript 반복문    JavaScript 함수    JavaScript 배열    JavaScript 객체(Object)    JavaScript 모듈    JavaScript UI와 API    JavaScript 정규표현식    JavaScript 함수지향 - 유효범위    JavaScript 함수지향 - 값으로서의 함수와 콜백    JavaScript 함수지향 - 클로저    JavaScript 함수지향 - arguments    함수지향 - 함수의 호출    객체지향 - 객체지향 프로그래밍 소개    객체지향 - 생성자와 new    객체지향 - 전역객체    객체지향 - this    객체지향 - 상속    객체지향-표준 내장객체의 확장    JavaScript 객체지향-ObjectJavaScript 객체지향-Object1. Object란?Object객체는 객체의 가장 기본적인 형태를 가지고 있는 객체이다. 다시 말해서 아무것도 상속받지 않는 순수한 객체다. Javascript에서는 값을 지정하는 기본적인 단위로 Object를 사용한다. var grades = {'egoing': 10, 'k8805': 6, 'sorialgi': 80};우리는 이전에 property에대해 배울 때 Ultra, Super, Sub라는 생성자 예제를 통해 상속에대해 알아보았다. Sub는 Super를 Super는 Ultra를 상속받았다. Ultra는 최상위에 있는것처럼 보이지만 암시적으로는 사실 Object라는 객체에 상속되어 있는것이다. Object라는 객체의 프로퍼티는 모든 객체가 갖고있는 프로퍼티가 되는것이다. 즉 Object의 prototype은 모든객체가 사용할 수 있는 prototype이 된다는 것이다. 우리가 모든 객체가 가지고 있었으면 하는 기능이 있다면 Object의 prototype에 우리가 직접 기능을 추가하는 것을 통해서 모든객체가 그기능을 갖게 할 수 있다는 것이다.2. Object API사용법Object.keys는 배열이 어떠한 인덱스값을 가지고 있는지 배열로 리턴하는 메소드이다. 따라서 첫번째 결과는 Object.keys(arr)[‘0’, ‘1’, ‘2’] 이된다. toString은 문자열을 리턴해준다고 생각하자. 중요한 것은 Object.keys()와 Object.prototype.toString()에서 prototype이 있고 없고의 차이가 뭔지 알아야한다. prototype이 있는 것은 어떠한 객체를 만든다. 그리고 그객체를 담고있는 식별자. toString이라고 한다. 그런데 prototype이 없는 Object.keys같은 경우에는 Object.keys(arr)처럼 어떠한 인자를 받아서 처리한다. 이러한 차이는 Object라고 하는 것이 생성자 함수인 것이다. 함수는 javascript에서 객체이기 때문에 프로퍼티를 가질수 있다. 그래서 Object.keys가 가능한 것이고 이렇게 정의되었을 것이다 Object.keys = function(){}. toString의 경우는 prototype의 프로퍼티이다. 즉 Object.prototype.toString = function(){} 로 정의되어 있다. 어떠한 메소드가 new Object를 실행을 시키는 순간에 어떠한 객체를 만들고 그객체는 prototype이라고 하는 특수한 프로퍼티에 저장되어있는 객체를 원형으로 하는 객체가 생성이 되는것이다. 그렇게 생성된 객체는 toString이라는 메소드를 사용할 수 있기 때문에 메소드로서 사용하게 되는것이다.//Object.keys()var arr = [\"a\", \"b\", \"c\"];console.log('Object.keys(arr)',Object.keys(arr));//Object.prototype.toString()var o = new Object();console.log('o.toString()',o.toString());var a = new Array(1,2,3);console.log('a.toString()'),a.toString());3. Object 확장우리가 필요한 기능을 모든 객체에서 사용 가능한 Object를 만드는 방법을 알아보자.아래 배열과 객체에서 contain.(인자)메소드로 어떤 인자를 전달하게되면 인자가 해당 되는 값이 그 객체나 배열에 있다면 true 없다면 false를 리턴하게하는 코드를 만들어 보았다. 모든 객체의 부모는 Object이기 때문에 Object라고 적어주고, o와a모두 객체이다. 객체에 어떤 기능, 메소드를 갖도록 추가하고 싶다면 prototype이라고하는 프로퍼티안의 객체를 변경하면 된다. for in문으로 배열과 객체를 차례로 나열하여 값을 확인하는 코드를 작성했다. 아래 코드에서 메소드 안의 this는 그 메소드가 소속되어있는 객체를 의미한다. name에는 각각의 객체에대한 키값이 담기게 된다. 현재 열거되고 있는 value값을 가져오려면 this[name]으로 가져오고 그값과 neddle을 비교하여 두 값이 일치하면 true를 리턴한다. 마지막 value까지 나열했는데 일치하는 값이 없다면 false를 리턴한다.Object.prototype.contain = function(neddle) {    for(var name in this){        if(this[name] === neddle){            return true;        }    }    return false;}var o = {'name' : 'ansang', 'city' : 'suwon'}console.log(o.contain('ansang'));var a = ['ansang', 'sang', 'hyun'];console.log(a.contain('sang'));4. Object 확장의 위험확장의 위험성에 대해 알아보자. 확장을 함으로써 모든 객체에 영향을 주기때문에 주의해야한다.크롬 개발자 도구에서 아래 코드를입력후 for(var name in o){console.log(o[name]);}을 출력한 결과를 보자. 함수까지 출력된 상황이다. 이유는 contain이 포함되었기 때문이다. 개발자 도구에서 다시 코드를 작성해보자. for(var name in o){console.log(name)}의 결과는 name, city, contian이다.for(var name in a){console.log(name)}의 실행결과 역시 0,1,2,contain이다.Object.prototype.contain = function(neddle) {    for(var name in this){        if(this[name] === neddle){            return true;        }    }    return false;}var o = {'name' : 'ansang', 'city' : 'suwon'}console.log(o.contain('ansang'));var a = ['ansang', 'sang', 'hyun'];console.log(a.contain('sang'));// 개발자 도구에서 for(var name in o){console.log(name)}을 출력한 결과for(var name in o){    console.log(o[name]);}VM693:2 ansangVM693:2 suwonVM693:2 ƒ (neddle) {    for(var name in this){        if(this[name] === neddle){            return true;        }    }    return false;}// 개발자 도구에서 for(var name in a){console.log(name);}을 출력한 결과12contain부모로 부터 contain이라는 프로퍼티까지 상속받았기 때문에 위와같은 결과가 나오는 것이다. 그렇다면 이런 문제를 해결할수 있는 메소드를 알아보자. a.hasOwnProperty(name)는 실행되는 객체가 인자로 전달된 값을 자신의 프로퍼티로 가지고 있는지 확인할 수 있는 메소드이다. contain은 부모로부터 상속받은 프로퍼티이기 때문에 어떠한 프로퍼티의 이름이 그객체의 직접적으로 정의되어있는지 확인하는 기능인 hasOwnProperty로 구별할 수 있다.Object.prototype.contain = function(neddle) {    for(var name in this){        if(this[name] === neddle){            return true;        }    }    return false;}var o = {'name' : 'ansang', 'city' : 'suwon'}var a = ['ansang', 'sang', 'hyun'];for(var name in o){    if(o.hasOwnProperty(name)){        console.log(name)    }}//name, cityfor(var name in a){    if(a.hasOwnProperty(name)){        console.log(name)    }}//0,1,25. prototype vs proto이번엔 prototype과 _proto__의 관계를 알아보자. 그전에 함수란 무엇인가를 확인해 보면. 함수는 javascript에서는 객체이다. function Person(){}는 var Person = new Function();으로 표현할수 있다. javascript에서 함수는 객체이기 때문에 프로퍼티를 가질 수 있다. 아래와 같은 함수를정의하면 객체이기 때문에 함수에 해당되는 Person이라고하는 객체가 생성되고 Person의 prototype이라는 객체가 하나 더 생긴다. 두개의 객체는 서로 연관되어 있기 때문에 Person이라고하는 객체는 내부적으로 prototype이라는 프로퍼티가 생기고 그 프로퍼티는 Person의 prototype객체를 의미한다. 그래서  Pserson.prototype이라 함은 Person의 prototype객체를 의미한다. Person의 prototype객체도 자신이 Person의 소속인것을 표시하기 위해서 어딘가에 기록해야한다. 그러기 위해서 Person의 prototype객체 안에 constructor라고하는 프로퍼티를 만들고 이 프로퍼티는 Person을 가르키게 된다. 서로간의 상호참조를 하고있는 것이다. Person은 prototype프로퍼티를 통해서 Person의 prototype객체를 가르키고 Person의 prototype객체는 constructor프로퍼티를 통해서 Person객체를 가르킨다는 것이다. 그다음person.prototype.sum = function(){} 를정의하게 되면 Person의 prototype객체에 sum이라는 함수가 없기때문에 생성하고 함수를 정의한다. var kim=new Person(‘kim’,10,20) 이렇게 객체를 생성하면 kim이라고하는 객체가 생성되고 kim이라는 객체 안에 프로퍼티 값으로 name,first,second 그리고 __proto__가 생성이 된다. kim객체의 __proto_ 프로퍼티는 Person의 prototype객체를 의미한다. 그렇다면 Person.prototype을통해서 Person의 prototype객체에 접근할 수 있고, kim.__proto__를 통해서도 접근 할 수 있다. var lee = new Person(‘lee’,10,10)를 통해서도 같은 접근을 할 수 있다. console.log(kim.name)을하면 name이라는 프로퍼티가 있는지를 확인하고 그값을 출력할 것이다. 만약 name이라는 값이 없다면 __proto__가 가르키는 객체에 name이 있는지 다시 찾아본다. kim.sum()을 하게 되면 kim이라는 객체에는 sum이라는 메소드가 없다. 그렇다면 javascript는 __proto__가 가르키는 Person의 prototype객체에 sum이 있는지 찾는다. 이런식으로 prototype이 동작하는 것이다.function Person(name, first, second){    this.name = name;    this.first = first;    this.second = second;}person.prototype.sum = function(){}var kim = new Person('kim',10,20)var lee = new Person('lee',10,10)console.log(kim.name)kim.sum()",
        "url": "/javascript-basic23"
    }
    ,
    
    "javascript-basic22": {
        "title": "Javascript - JavaScript 객체지향-표준 내장객체의 확장",
            "author": "AhnSang0915",
            "category": "",
            "content": "Javascript    JavaScript 기본     JavaScript 숫자와 문자     JavaScript 변수, 비교    JavaScript 조건문    JavaScript 반복문    JavaScript 함수    JavaScript 배열    JavaScript 객체(Object)    JavaScript 모듈    JavaScript UI와 API    JavaScript 정규표현식    JavaScript 함수지향 - 유효범위    JavaScript 함수지향 - 값으로서의 함수와 콜백    JavaScript 함수지향 - 클로저    JavaScript 함수지향 - arguments    함수지향 - 함수의 호출    객체지향 - 객체지향 프로그래밍 소개    객체지향 - 생성자와 new    객체지향 - 전역객체    객체지향 - this    객체지향 - 상속    객체지향-표준 내장객체의 확장    JavaScript 객체지향-ObjectJavaScript 객체지향-표준 내장객체의 확장1. 표준 내장 객체란?표준 내장 객체(Standard Built-in Object)는 자바스크립트가 기본적으로 가지고 있는 객체들을 의미한다. 내장 객체가 중요한 이유는 프로그래밍을 하는데 기본적으로 필요한 도구들이기 때문에다. 결국 프그래밍이라는 것은 언어와 호스트 환경에 제공하는 기능들을 통해서 새로운 소프트웨어를 만들어내는 것이기 때문에 내장 객체에 대한 이해는 프로그래밍의 기본이라고 할 수 있다. 자바스크립트의 표준 내장객체는 아래와 같다.  Object  Function  Array  String  Boolean  Number  Math  Date  RegExp2. 배열의 확장 1내장객체에 우리가 원하는 기능을 추가하는 방법을 알아보자. 아래 예제는 도시이름이 랜덤하게 값으로 반환되는 코드이다. Math.random함수는 0에서 1사이의 난수(난수란 무작위로 만들어진 수열을 가리킨다. 여기서 무작위란 다음에 나올 수를 절대 예측할 수 없다는 것을 뜻한다.)를 반환하는 함수이다.arr.length * Math.random()은 소수값이 포함되어 있기 때문에 index값을 불러올 수 없다. 그렇기 때문에 Math가 가진 API중에 Math.floor을 사용해 정수로 만들어 줘야한다. Math.floor는 소수점을 없애주는 역할을 한다. 예를들어 0.1은 0, 5.2는 5로 바꿔주는 역할을 한다. 그렇게 하고 우리가 랜덤하게 배열의 인덱스값을 배열에 전달할 수 있게 return arr[index];}를 해준다.var arr = new Array('seoul','new york','ladarkh','pusan', 'Tsukuba');function getRandomValueFromArray(arr){    var index = Math.floor(arr.length * Math.random());    return arr[index];}console.log(getRandomValueFromArray(arr))3. 배열의 확장 2이번엔 Array생성자를 확장해서 모든 배열이 그 배열이 갖고있는 값 중에 어떤 특정한 값을 랜덤하게 획득할 수 있는 기능을 모든 배열의 객체가 획득할 수 있도록 코드를 변경해 보자.  new Array로 새로운 배열을 만들어 낼때 Array.prototype.random = function() { }라는 생성자 함수가 실행이 될것이다. 그생성자가 가지고있는 prototype이라는 프로퍼티 안에 있는 객체가 만들어지는 그 객체의 원형이 되기 떄문에 random이라는 것을 추가한는 것을 통해서 배열객체가 만들어지는 원형, 배열객체의 원형에 random이라는 메소드를 추가하게 되는것이다. 프로토타입을 추가하는걸 통해서 배열 생성자를 통해서 만들어진 객체가 random이라는 메소드를 가지고 있다. random이라는 메소드 안에서 this는 배열객체 자체를 의미한다./*var arr = new Array('seoul','new york','ladarkh','pusan', 'Tsukuba');function getRandomValueFromArray(arr){    var index = Math.floor(arr.length * Math.random());    return arr[index];}console.log(getRandomValueFromArray(arr))*/Array.prototype.random = function() { //배열을 만들기 위한 생성자함수    var index = Math.floor(this.length * Math.random());    return this[index];}var arr = new Array('seoul','new york','ladarkh','pusan', 'Tsukuba');console.log(arr.random());",
        "url": "/javascript-basic22"
    }
    ,
    
    "javascript-basic21": {
        "title": "Javascript - JavaScript 객체지향 - 상속",
            "author": "AhnSang0915",
            "category": "",
            "content": "Javascript    JavaScript 기본     JavaScript 숫자와 문자     JavaScript 변수, 비교    JavaScript 조건문    JavaScript 반복문    JavaScript 함수    JavaScript 배열    JavaScript 객체(Object)    JavaScript 모듈    JavaScript UI와 API    JavaScript 정규표현식    JavaScript 함수지향 - 유효범위    JavaScript 함수지향 - 값으로서의 함수와 콜백    JavaScript 함수지향 - 클로저    JavaScript 함수지향 - arguments    함수지향 - 함수의 호출    객체지향 - 객체지향 프로그래밍 소개    객체지향 - 생성자와 new    객체지향 - 전역객체    객체지향 - this    객체지향 - 상속    객체지향-표준 내장객체의 확장    JavaScript 객체지향-ObjectJavaScript 객체지향 - 상속1. 상속(inheritance)이란?우리가 객체라고 하는 것은 하나의 컨테이너고 변수나 메소드가 하나의 객체 안에 상속되어있다. 이런 객체의 특성으로 인해 객체를 그대로 물려받은 새로운 객체를 만들 수 있다. 이 객체는 부모에 해당 되는 객체의 변수의 메소드에 접근할 수 있게 된다. 즉 상속이란 오리지널 객체가 갖고있는 기능을 상속받는 객체가 동일하게 가질 수 있다는 것이다.Person이라고 하는 생성자를 만들었고 그 생성자에 new를 사용해 새로운 객체를 만들었다. 그 객체는 name이라고 하는 프로퍼티와 introduce라고 하는 프로퍼티를 가지고 있고, name의 값은 person에 인자로 전달된 값이 name으로 사용된다. 아래 코드를 실행하면 ‘My name is ansang’이 출력된다.function Person(name){    this.name = name;    this.introduce = function(){        return 'My name is '+this.name;     }   }var p1 = new Person('ansang');document.write(p1.introduce()+\"&lt;br /&gt;\");아래도 마찬가지로 Person이라고 하는 생성자를 만들었고 그 아래 생성자에 portotype이라고 하는 특수한 프로퍼티에 name이라고 하는 프로퍼티를 준 것이다. 즉 Person이라고 하는 생성자에는 prototype 프로퍼티가 있는데 그 안에 어떤 객체가 들어가있다. 그객체 .name을 하게 되면 어떤 값을 줄 수 있게 되는것이고 그객체 .introduce하고 함수를 할당을 하게 되면 어떤 메소드를 지정할 수 있는 것이다.function Person(name){    this.name = name;}Person.prototype.name=null;Person.prototype.introduce = function(){    return 'My name is '+this.name; }var p1 = new Person('ansang');document.write(p1.introduce()+\"&lt;br /&gt;\");2. 상속의 사용법아래는 우리가 처음에 본 예제에서 Programmer라는 생성자를 추가한 것이다. Programmer라는 생성자를 통해 만든 객체가 Person이라는 생성자를 통해서 만들어진 객체와 동일한 기능성을 갖도록 코드를 작성한 것이다.new Programmer(‘ansang’);를 통해서 Programmer라는 생성자를 호출했다. name이라는 프로퍼티 값을 ansang으로 지정을 했다. p1.introduce을 사용하려고 하는데 생성자 Programmer에는 introduce라는 메소드가 정의되어 있지 않다. introduce메소드는 Person이라고 하는 생성자에 정의되어 있는데 여기서 Programmer.prototype = new Person();로 Person 생성자의 프로퍼티와 메소드를 가져오게 된다. 우리는 Programmer에서 name의 값을 ansang으로 주었고 Programmer.prototype = new Person();에서 prototype 라는 어떠한 객체의 값이 생성자 Person과 같다고 했기 때문에 name은 ansang이되고 introduce메소드를 사용할 수 있는 것이다.function Person(name){    this.name = name;}Person.prototype.name=null;Person.prototype.introduce = function(){    return 'My name is '+this.name; } function Programmer(name){    this.name = name;}Programmer.prototype = new Person(); var p1 = new Programmer('ansang');document.write(p1.introduce()+\"&lt;br /&gt;\");3. 기능의 추가상속을 받는 객체를 만들었다면 기능을 추하가는 기능을 알아보자. Person이라고하는 공통의 부모가 있고 Programmer, Designer라는 객체가 person이라는 객체를 상속받는 형식이다.function Person(name){    this.name = name;}Person.prototype.name=null;Person.prototype.introduce = function(){    return 'My name is '+this.name; } function Programmer(name){    this.name = name;}Programmer.prototype = new Person();Programmer.prototype.coding = function(){    return \"hello world\";}function Designer(name){    this.name = name;}Designer.prototype = new Person();Designer.prototype.design = function(){    return \"beautiful\";} var p1 = new Programmer('ansang');document.write(p1.introduce()+\"&lt;br /&gt;\");document.write(p1.coding()+\"&lt;br /&gt;\");var p2 = new Designer('nibagman');document.write(p2.introduce()+\"&lt;br /&gt;\");document.write(p2.design()+\"&lt;br /&gt;\");여기서 My name is를 My nickname is로 바꾸면 My nickname is ansanghello worldMy nickname is nibagmanbeautiful의 값을 출력하게 된다. 이말은 Person이라는 생성자를 상속받은 객체들의 값도 바뀐다는 말이다.function Person(name){    this.name = name;}Person.prototype.name=null;Person.prototype.introduce = function(){    return 'My nickname is '+this.name; } function Programmer(name){    this.name = name;}Programmer.prototype = new Person();Programmer.prototype.coding = function(){    return \"hello world\";}function Designer(name){    this.name = name;}Designer.prototype = new Person();Designer.prototype.design = function(){    return \"beautiful\";} var p1 = new Programmer('ansang');document.write(p1.introduce()+\"&lt;br /&gt;\");document.write(p1.coding()+\"&lt;br /&gt;\");var p2 = new Designer('nibagman');document.write(p2.introduce()+\"&lt;br /&gt;\");document.write(p2.design()+\"&lt;br /&gt;\");4. prototype그럼 prototype이란 무엇인가? 한국어로는 원형정도로 번역되는 prototype은 말 그대로 객체의 원형이라고 할 수 있다. 함수는 객체다. 그러므로 생성자로 사용될 함수도 객체다. 객체는 프로퍼티를 가질 수 있는데 prototype이라는 프로퍼티는 그 용도가 약속되어 있는 특수한 프로퍼티다. prototype에 저장된 속성들은 생성자를 통해서 객체가 만들어질 때 그 객체에 연결된  다.생성자는 기본적으로 함수이다. 우리가 이 함 수를 호출할 때 new를 사용하면 생성자가 되는 것이고 그렇게 해서 실행된 결과로 새로운 객체를 만들고 이 객체는 o에 들어가게 된다. 그런데 비어있는 객체를 만드는 것만이 생성자의 역할이라고 한다면 그렇게 효율적이지 못하다. 생성자를 사용하는 이유는 우리가 객체를 생성했을 때 그 객체가 가져야 할 방법이나 프로퍼티 값을 가지고 우리에게 주어지기를 바라기 때문이다. 우리가 어떤 객체를 생성했을 때 객체가 가지고 있어야 하는 방법과 프로퍼티 prototype이라는 프로퍼티에 저장이 되는 것이다. 즉 prototype는 어떠한 객체가 정의가 되어있다는 것이다. 그렇게 하고 new를 이용해 생성자 함수를 생성하게 되면 Javascript는 생성자 함수의 prototype에 저장되어있는 객체를 꺼내서 그것을 돌려보내 주게 된다. 코드를 보자. 우리가 Sub.prototype = new Super(); 라고 하면 생성자 function Super(){} 이 만든 객체 Super.prototype = newUltra(); 이 만든 값이 들어가는 것이고 그리고 생성자 function Super(){}의 값은 Super.prototype = newUltra();로 만들어진 객체가 담긴다는 것이다. 생성자 function Ultra(){}의 값은 Ultra.prototype.ultra Prop = true; 이기 때문에 true가 출력된다. 이러한 개념은 prototype chain 이라고 한다.function Ultra(){}Ultra.prototype.ultraProp = true; function Super(){}Super.prototype = new Ultra(); function Sub(){}Sub.prototype = new Super(); var o = new Sub();console.log(o.ultraProp);5. prototype chain전에 본 코드를 아래와 같이 바꾸면 1을 출력하게 된다. 그이유는 javascript가 기본적으로 동작할 떄 o라는 객체가 ultraprop라는 값을 가지고 있는지 확인하고 우리가 o.ultraProp = 1;로 지정했기 때문에 1을 출력하게 된다.function Ultra(){}Ultra.prototype.ultraProp = true; function Super(){}Super.prototype = new Ultra(); function Sub(){}Sub.prototype = new Super(); var o = new Sub();o.ultraProp = 1;console.log(o.ultraProp);아래의 결과는 2가 된다. 코드를 실행하면 o라는 객체에 ultra Prop기 있는지 확인한다. 우리는 var o = new Sub();로 ultraProp에 대해선 정의한 바가 없다. 그래서 이 객체에 직접 ultraProp가 없다는 걸 확인하고, o라는 객체의 생성자를 알아내고(생성자를 알아내는 방법은 따로 있다.) Sub이라는 생성자의 prototype 객체를 확인해 그 객체의 프로퍼티 중에 ultraProp이 있는지 확인하고 그 값을 가져오게 된다.function Ultra(){}Ultra.prototype.ultraProp = true; function Super(){}Super.prototype = new Ultra(); function Sub(){}Sub.prototype = new Super();Sub.prototype.ultraProp = 2; var o = new Sub();console.log(o.ultraProp);아래의 결과는 3이다.function Ultra(){}Ultra.prototype.ultraProp = true; function Super(){}Super.prototype = new Ultra(); function Sub(){}var s = new Super();s.ultraProp = 3;Sub.prototype = s; var o = new Sub();console.log(o.ultraProp);아래의 값은 4이다.function Ultra(){}Ultra.prototype.ultraProp = true; function Super(){}var t = new Ultra();t.ultraProp = 4;Super.prototype = t; function Sub(){}var s = new Super();Sub.prototype = s; var o = new Sub();console.log(o.ultraProp);아래의 값은 true다.function Ultra(){}Ultra.prototype.ultraProp = true; function Super(){}var t = new Ultra();Super.prototype = t; function Sub(){}var s = new Super();Sub.prototype = s; var o = new Sub();console.log(o.ultraProp);주의할점은 어떠한 객체 super를 sub가 상속받고 싶다면 Sub.prototype에는",
        "url": "/javascript-basic21"
    }
    ,
    
    "javascript-basic20": {
        "title": "Javascript - JavaScript 객체지향 - this",
            "author": "AhnSang0915",
            "category": "",
            "content": "Javascript    JavaScript 기본     JavaScript 숫자와 문자     JavaScript 변수, 비교    JavaScript 조건문    JavaScript 반복문    JavaScript 함수    JavaScript 배열    JavaScript 객체(Object)    JavaScript 모듈    JavaScript UI와 API    JavaScript 정규표현식    JavaScript 함수지향 - 유효범위    JavaScript 함수지향 - 값으로서의 함수와 콜백    JavaScript 함수지향 - 클로저    JavaScript 함수지향 - arguments    함수지향 - 함수의 호출    객체지향 - 객체지향 프로그래밍 소개    객체지향 - 생성자와 new    객체지향 - 전역객체    객체지향 - this    객체지향 - 상속    객체지향-표준 내장객체의 확장    JavaScript 객체지향-ObjectJavaScript 객체지향 - this1. 함수와 thisthis는 함수 내에서 함수 호출 맥락(context 어떠한 의미가 고정되어 있지 않고 사용되는 상황에따라 그의미가 달라질 수 있따.)를 의미한다. 맥락이라는 것은 상황에 따라서 달라진다는 의미인데 즉 함수를 어떻게 호출하느냐에 따라서 this가 가리키는 대상이 달라진다는 뜻이다. 함수와 객체의 관계가 느슨한 자바스크립트에서 this는 이 둘을 연결시켜주는 실질적인 연결점의 역할을 한다.아래 코드는 조건문에서 window(전역객체)와 함수안에서의 this가 정확하게 일치한다면 window === this를 출력하는 코드이다. 개발자 도구 콘솔에서 실행시 아래와 같이 나온다. 아래 예제처럼 함수안에서의 this는 전역객체를 의미하는 window를 의미하는 것이다.function func(){    if(window === this){        console.log(\"window === this\");    }}undefinedfunc();// window === this2. 메소드와 this객체의 소속인 메소드의 this는 그 객체를 가르킨다. o라고 하는 변수에 객체를 정의해서 할당했다. 그객체엔 func라는 프로퍼티가 있고 함수이기 때문에 메소드 이다. 함수의 내용은 변수o와 this가 정확하게 같다면 o === this를 출력하는 함수이다. 출력값은 o === this 이다.var o = {    func : function(){        if(o === this){            document.write(\"o === this\");        }    }}o.func();   3. 생성자 this아래 코드는 함수를 호출했을 때와 new를 이용해서 생성자를 호출했을 때의 차이를 보여준다.function Func()의 funcThis = this;는 지역변수로 지정하지 않았기 때문에 전역변수인 funcThis의 값이 this가 된다. 그렇기 때문에 if(function === window)는 true가 된다. 이말은 우리가 함수와 this에서 본 예제와 같이 함수안에서의 this는 전역객체 window를 의미하는 것이다. 그아래 var o2 = new Func();는 new를 사용해 javascript내부적으로 비어있는 객체를 만들었다. 그비어있는 객체는 o2가된다. 그리고 var o2 = new Func();를 실행하면 생성자 function Func()가 실행이되고 this의 값이 funcThis가 되고 그값은 var = funcThis가 된다. 자 정리하자. 우리가 new생성자를 통해 o2에 빈객체를 만들었고 그 new생성자는 function Func(){funcThis = this;}이고 여기서의 funcThis는 var funcThis를 의미한다. 즉 우리가 생성자를 통해 만든 객체는 o2에 들어있고 그 생성자가 가르키는것이 var funcThis이기 때문에 if(funcThis === o2)는 true가 된다. 이것을 통해 알수 있는것은 생성자의 맥락으로, 똑같은 함수지만 생성자로 사용될 때에는 this의 값이 생성될 객체를 의미한다.var funcThis = null;  function Func(){    funcThis = this;}var o1 = Func();if(funcThis === window){    document.write('window &lt;br /&gt;');} var o2 = new Func();if(funcThis === o2){    document.write('o2 &lt;br /&gt;');}위의 예제를 조금 바꿔봤다. if(o2 === this); 를 추가했는데 이렇게 되면 문제가 있다. 우리가 생성자를 호출하게 되면 생성자에대한 호출이 모두 끝나고난 뒤에 그때 비로소 o2라고하는 변수에 우리가 생성한 객체가 할당이 된다. 그전에 객체는 만들어져 있지만 o2라는 변수에 할당되어 있지 않기 때문에 우리는 객체를 할당할수 없다. 따라서 생성자 안에서 o2라는 변수와 this를 확인하면 o2라는 변수에 객체가 담겨있지 않기때문에 undefined이다. this라고 하는것은 객체에대한 초기화가 끝나서var funcThis = null;  function Func(){    if(o2 === this);}var o2 = new Func();if(funcThis === o2){    document.write('o2 &lt;br /&gt;');}//undefined4. 객체로서의 함수이번엔 javascript가 얼마나 유연한지 극명하게 보여주는 주제를 알아보자.아래 예제는 개발자도구에 입력한 내용이다. function sum(x,y) {return x+y;}는 sum이라고하는 함수 객체를 만든것이다. 그런데 우리가 new Function(‘x’,’y’,’return x+y;’);로 함수객체를 만드는것은 함수의 본문이 복잡하면 굉장히 힘들다. 그래서 함수를 쉽게작성할 수 있도록 function sum(x,y) {return x+y;} 이런식으로 작성하면 javascript해석기는 함수객체를 만들어주고 이런식의 작성을 함수 리터럴(literal)이라고 한다. 그리고 객체를 만들때  var a = {} 이런식으로 만드는것을 객체 리터럴, var a = []; 이런식을 배열 리터럴이라고 한다. 우리가 명시적으로  new Object, new array등으로 만들수도 있지만 보다 편리하게 어떤 값을 만들수있도록 해주는 처리를 리터럴(literal)이라고 한다.function sum(x,y) {     return x+y;}undefinedsum(1,2);3var sum2 = new Function('x','y','return x+y;'); // new를 통해서 function이라고하는 생성자함수를 호출한것이다. 앞의 두'x','y',는 함수를 정의할때 매개변수를 정의하는것과 같은 의미이고 마지막 'return x+y;' 가 본문{}에 해당되는 것이다.undefinedsum2(1,2);35. apply와this함수가 가지고있는 프로퍼티중에 EcamaScript에서 정의하고있는 메소드중의 하나가 apply와 call이다.switch는 괄호안의 어떤값이 들어가면 값과 같은 케이스 안에들어있는 구간이 break를 만날때까지 실행된다. if문과 대체제의 관계에 있고 이것은 for문과 while문이 대체제역할에 있는것과 같다.함수를 apply를이용해 호출했을때 내부적으로 this의 값은 어떻게 변경되는지 알아보자. func();를 호출하게 되면 함수에서의 this의 값은 전역객체window를 의미하기 때문에 window를 실행하게 된다. func.apply(o);는 객체이기 때문에 프로퍼티를 가지고 있을수 있고 Ecmascript의 스펙으로 정의되어 있는 표준 메소드인 apply를 가지고있다. apply를 호출할때 첫번째 인자로 함수호출 컨테스트 o를 주게되면 func()함수가 실행되게 되면서 this의값이 o가된다. 그래서 o를실행하고 braek가되어 값을 반환하게된다. func.apply(p);도 마찬가지로 p를 반환할 것이다.var o = {}var p = {}function func(){    switch(this){        case o:            document.write('o&lt;br /&gt;');            break;        case p:            document.write('p&lt;br /&gt;');            break;        case window:            document.write('window&lt;br /&gt;');            break;              }}func();func.apply(o);func.apply(p);window, o, p라는 객체와 함수가 있었다. 함수를 어떻게 호출하느냐에 따라 즉 맥락에 따라 window에 소속되기도 하고 o와 p에 소속되기도 했다.",
        "url": "/javascript-basic20"
    }
    ,
    
    "javascript-basic19": {
        "title": "Javascript - JavaScript 객체지향 - 전역객체",
            "author": "AhnSang0915",
            "category": "",
            "content": "Javascript    JavaScript 기본     JavaScript 숫자와 문자     JavaScript 변수, 비교    JavaScript 조건문    JavaScript 반복문    JavaScript 함수    JavaScript 배열    JavaScript 객체(Object)    JavaScript 모듈    JavaScript UI와 API    JavaScript 정규표현식    JavaScript 함수지향 - 유효범위    JavaScript 함수지향 - 값으로서의 함수와 콜백    JavaScript 함수지향 - 클로저    JavaScript 함수지향 - arguments    함수지향 - 함수의 호출    객체지향 - 객체지향 프로그래밍 소개    객체지향 - 생성자와 new    객체지향 - 전역객체    객체지향 - this    객체지향 - 상속    객체지향-표준 내장객체의 확장    JavaScript 객체지향-ObjectJavaScript 객체지향 - 전역객체1. 전역객체란?전역객체(Global object)는 특수한 객체다. 모든 객체는 이 전역객체의 프로퍼티다. func();와 window.func();는 모두 실행이 된다. 모든 전역변수와 함수는 사실 window 객체의 프로퍼티다. 객체를 명시하지 않으면 암시적으로 window의 프로퍼티로 간주된다. 생략이 가능하다는 말이다.function func(){    alert('Hello?');    }func();window.func();모든 전역변수와 함수는 window객체의 프로퍼티다. 객체를 명시하지 않으면 암시적으로 window의 프로퍼티로 간주한다. 아래 예제는 전역변수 o에 객체메소드를 지정했다. 그렇기 떄문에 o.func();와 window.o.func();가 모두 실행이 되는걸 알수있다.var o = {'func':function(){    alert('Hello?');}}o.func();window.o.func();전역객체 APIECMAScript에서는 전역객체의 API.를 정의해두었다. 그 외의API는 호스트 환경에서 필요에 따라서 추가로 정의하고 있다. 이를테면 웹브라우저 자바스크립트에서는 alert()이라는 전역객체의 메소드가 존재하지만 node.js에는 존재하지 않는다. 또한 전역객체의 이름도 호스트환경에 따라서 다른데, 웹브라우저에서 전역객체는 window이지만 node.js에서는 global이다.",
        "url": "/javascript-basic19"
    }
    ,
    
    "javascript-basic18": {
        "title": "Javascript - JavaScript 객체지향 - 생성자와 new",
            "author": "AhnSang0915",
            "category": "",
            "content": "Javascript    JavaScript 기본     JavaScript 숫자와 문자     JavaScript 변수, 비교    JavaScript 조건문    JavaScript 반복문    JavaScript 함수    JavaScript 배열    JavaScript 객체(Object)    JavaScript 모듈    JavaScript UI와 API    JavaScript 정규표현식    JavaScript 함수지향 - 유효범위    JavaScript 함수지향 - 값으로서의 함수와 콜백    JavaScript 함수지향 - 클로저    JavaScript 함수지향 - arguments    함수지향 - 함수의 호출    객체지향 - 객체지향 프로그래밍 소개    객체지향 - 생성자와 new    객체지향 - 전역객체    객체지향 - this    객체지향 - 상속    객체지향-표준 내장객체의 확장    JavaScript 객체지향-ObjectJavaScript 객체지향 - 생성자와 new1.자바스트립트의 객체지향Javascript는 어떠한 객체지향 언어와도 같지않다. Javascript만의 독특한 성질을 갖고있고, Javascript의 계열에 속하는 언어들은 prototype-based programming이라 부른다. Javascript도 여기에 속해있는 언어다. 전통적인 함수형 언어의 특성을 그대로 갖고있는게 아니고 객체지향언어가 갖고있는 문법을 비슷하게 사용하면서 사실은 함수형언어의 특성을 갖고있다. 객체지향 프로그래밍을 간단하게 이야기하면 서로 연관되어있는 변수와 메소드를 하나의 객체라고하는 그릇에 넣는것이다. 그리고 서로 연관되어있지 않은 것들은 별도의 객체에다 분리를 시켜놓는 것이 객체지향 프로그래밍의 기본적인 형태라고 할 수 있다. 연관되어 있는 로직들을 객체화 시키게되면 각각의 로직들은 하나하나가 독립된 프로그램처럼 독립성을 갖게된다. 독립성을 갖게된다는것은 여러 완제품의 부품으로 사용될 수 있다는 것이다. 우리가 객체지향 프로그래밍으로 도달하고자하는 목표는 좋은 부품을 만드는 것이라고 할 수 있겠다.2. 객체 생성객체를 만들어 보자. {}를 사용하면 비어있는 객체를 만드는 것이고, oject라는 이름의 object를 만드는 것이다. 비어있는 상자라고 생각하자.  person.name 이라고하면 object라는 그릇에 name이라는 변수를 담은것이다. 그변수의 내용은 문자열 ‘ansang’이 되는것이다. 그런데 우리는 객체에 담겨있는 변수를 변수라고 하지않고 프로퍼티(property)라고 부를것이다. 그리고 우리는 또다른 프로퍼티로 person.introduc 를 넣었다. 프로퍼티 안에 함수를 담게되면 우리는 메소드라고 부르기로했다. 객체 내의 변수를 프로퍼티(property) 함수를 메소드(method)라고 부른다는 것이다. 아래 예제를 실행을 시키면 함수가 실행이 되는데 ‘My name is ‘+this.name 의 this는 함수가 속해있는 객체, person이 담고있는 객체를 의미하는 것이다. person이 담고이있는 객체는 person.name = ‘egoing’으로 this.name은 ‘ansang’을 의미하게 된다. 그런데 아래 코드는 객체를 만들었는데 객체안에 들어갈 여러 프로퍼티가 객체와 분리가 되어있다. 그렇다보니 그 과정에서 중간에 다른 코드가 끼어든다거나 여러가지 이유로 인해서 객체를 정의하는 부분이 집중도가 떨어질 수 있다.var person = {} //비어있는 객체 person.name = 'ansang';person.introduce = function(){    return 'My name is '+this.name; }document.write(person.introduce());위와같은 문제를 방지하는 것이 우리가 직접 객체를 시작하고 닫는 기호 사이에 프로퍼티와 메소드를 직접 정의해 주는것이다.var person = {    'name' : 'ansang',    'introduce' : function(){        return 'My name is '+this.name;    }}document.write(person.introduce());만약에 person이라는 객체를 여러개 만들어서 여러사람에대한 정보를 담을수 있는 person객체를 만든다고 하면 아래처럼 만들면 될까?var person1 = {    'name' : 'ansang',    'introduce' : function(){        return 'My name is '+this.name;    }}var person2 = {    'name' : 'ansanghyun',    'introduce' : function(){        return 'My name is '+this.name;    }1,2로 두개의 객체를 만들었다. 문제는 name을 정의하는 부분과 introduce메소드 부분이 중복되어있다. name은 각각의 데이터가 다르기때문에 완전한 중복이라고는 보기힘들지만 메소드 부분은 완벽히 같은 내용으로 중복되어있다. 이것들이 같은 취지의 객체라고 한다면 그 객체가 가지고있는 메소드를 찾아서 똑같이 바꿔줘야하는 이슈가 생긴다. 이것은 프로그래머들이 혐오하는 중복이 발생한 것이다. 중복이 있다는것은 가독성이 떨어지고 코드의 양이 많아져 유지보수가 힘들어진다는 것이다. 이문제를 해결할 수 있는 방법은 중복을 제거하는 것이고 그방법은 생성자,new라는 것이다.3.생성자와 new생성자생성자(constructor)는 객체를 만드는 역할을 하는 함수다. 자바스크립트에서 함수는 재사용 가능한 로직의 묶음이 아니라 객체를 만드는 창조자라고 할 수 있다.아래는 개발자 도구에서 실행한 코드이다. new를 붙이고 함수를 호출하게 되면 함수는 그냥 함수라고 하지 않고 생성자라고 부른다. 이생성자는 객체의 생성자이고 비어있는 객체를 만들어 p에 반환한다. 그래서 p에는 person {}의 비어있는 객체가 만들어졌다.function person () {} //함수를 만들었다. 함수는 어떠한 값도 담고있지 않다.undefinedvar p0 = person(); //함수에 변수를 지정했다.undefinedp0                  //p0의 값이 없다고 나온다.undefinedvar p = new person(); // new를 추가하고 실행하면 아래와같은 객체가 만들어진게 보인다. undefinedpperson {} // var p = {} 과 같다고 볼수있다. (완전히 같진 않지만 지금 단계에서는.)자바스크립트에서는 원시타입(숫자, 불린값, null과 undefined)를 제외한 모든 값이 객체이다.객체를 생성하는 방법에는 2가지가 있는데 객체리터럴과 생성자로 객체를 만들 수 있는데 아래 예제는 객체 리터럴{}로 객체를 생성한 것과 같은 방법이라고 할 수 있다.function Person(){}var p = new Person();p.name = 'egoing';p.introduce = function(){    return 'My name is '+this.name; }document.write(p.introduce());아래 예제는 객체리터럴로 객체를 생성해 introduce 메소드 부분이 중복된 상황이다.function Person(){}var p1 = new Person();p1.name = 'egoing';p1.introduce = function(){    return 'My name is '+this.name; }document.write(p1.introduce()+\"&lt;br /&gt;\"); var p2 = new Person();p2.name = 'leezche';p2.introduce = function(){    return 'My name is '+this.name; }document.write(p2.introduce());위의 중복된 상황을 해결하기 위해 new를 사용해 생성자를 사용해 코드를 바꾸었다. 생성자함수( new 연산자와 함께 호출하여 객체(인스턴스)를 생성하는 함수를 말한다. 생성자 함수에 의해 생성된 객체를 인스턴스(instance)라 한다.) 코드를 통해서 알 수 있듯이 생성자 함수는 일반함수와 구분하기 위해서 첫글자를 대문자로 표시한다. Person이라는 함수를 작성했고 var p1 = new Person 함수의 앞에 new를 배치해 Person이라는 함수는 생성자가 된것이다. 인자로 ‘ansang’을 배치해 그값은 name에 들어간다 그리고 name은 this.name = ‘ansang’ 이된다. 즉 이객체의 프로퍼티의 값이 ansang이 된것이다. 그리고 현재 객체의 introduce라고하는 프로퍼티에 함수를 정의해 메소드를 만들었다. 생성자 함수가 다실행된 후에 p1에 담겨지게 된다. p1,p2에 new Person(‘ansang’);, new Person(‘sanghyun’); 를통해 생성자에 전달해 introduce라는 부분이 간단해졌다. 우리가 Person이라는 생성자가 만들어 놓은 빈 객체가 가져야할 프로퍼티와 메소드를 생성자 함수안에 기술하는것으로 인해서 그객체가 가지고있 정보와 객체가 할수 있는 일,이러한 것들을 이렇게 세팅해 주고 있는데 이런것들을 초기화 라고하고 줄여서init또는 initialize라고 한다. 즉 중요한 점은 생성자를 통해 객체를 초기화를 했다는 것이다.function Person(name){    this.name = name;     this.introduce = function(){        return 'My name is '+this.name;     }   }var p1 = new Person('ansang');document.write(p1.introduce()+\"&lt;br /&gt;\"); var p2 = new Person('sanghyun');document.write(p2.introduce());",
        "url": "/javascript-basic18"
    }
    ,
    
    "javascript-basic17": {
        "title": "Javascript - JavaScript 객체지향 - 객체지향 프로그래밍 소개",
            "author": "AhnSang0915",
            "category": "",
            "content": "Javascript    JavaScript 기본     JavaScript 숫자와 문자     JavaScript 변수, 비교    JavaScript 조건문    JavaScript 반복문    JavaScript 함수    JavaScript 배열    JavaScript 객체(Object)    JavaScript 모듈    JavaScript UI와 API    JavaScript 정규표현식    JavaScript 함수지향 - 유효범위    JavaScript 함수지향 - 값으로서의 함수와 콜백    JavaScript 함수지향 - 클로저    JavaScript 함수지향 - arguments    함수지향 - 함수의 호출    객체지향 - 객체지향 프로그래밍 소개    객체지향 - 생성자와 new    객체지향 - 전역객체    객체지향 - this    객체지향 - 상속    객체지향-표준 내장객체의 확장    JavaScript 객체지향-ObjectJavaScript 객체지향 프로그래밍 소개객체지향 프로그래밍객체지향 프로그래밍이(Object-Oriented Programming)란 OOP라고도 하고 핵심키워드는 객체이다. 객체지향 프로그래밍에서의 객체를 추상적으로 말하면 상태와 행위로 구분해 서로연관되어있는 상태와 행위를 그룹화 해놓은 것을 객체라고 할수 있다. 이 객체들을 마치 레고 블럭처럼 조립해서 하나의 프로그램을 만드는 것이 객체지향 프로그래밍이라고 할 수 있다. 다시 말해서 객체지향 프로그래밍은 객체를 만드는 것이다. 따라서 객체지향 프로그래밍의 시작은 객체란 무엇인가를 이해하는 것이라고 할 수 있다. 문법과 설계객체지향 프로그래밍 교육은 크게 두 가지로 구분된다.문법하나는 객체지향을 편하게 할 수 있도록 언어가 제공하는 기능을 익히는 것이다. 이러한 기능들은 if, for문처럼 문법적인 구성을 가지고 있다. 이 문법을 이해하고, 숙지해야 객체를 만들 수 있다. 객체를 만드는 법에 대한 학습이라고 할 수 있다. 우리 수업은 여기에 초점이 맞춰져 있다.설계두번째는 좋은 객체를 만드는 법이다. 현실에서 우리가 관심이있는 어떤 특성, 어떤관점을 소프트웨어화 시켜서 문제를 해결하는것이 프로그램, 프로그래밍이다.위의 그림은 런던의 지도이다. 이미지중 어떤것이 가장 보기 편할까. 마지막의 이미지가 보기 제일 편하지 않을까? 역과 역사이이의 환승역이라던지 노선들을 간단하게 추상화(abstract)시켜 보여주고 있다. 복잡함을 제외하고 사용자의 유일한 관심사에 초점을 맞춰 편의성을 높였다. 지하철 노선도가 디자인의 추상화라고 한다면 프로그램을 만든다는 것은 소프트웨어의 추상화라고 할 수 있다. 객체 지향 프로그래밍은 좀 더 현실을 잘 반영하기 위한 노력의 산물이다. 이것은 단순히 객체 지향의 문법을 이용해서 객체를 만든다고 달성되는 것이 아니다. 고도의 추상화 능력이 필요하다. 좋은 설계는 문법을 배우는 것보다 훨씬 어려운 일이다. 심지어 이것은 지식을 넘어서 지혜의 영역이다. 좋은 설계를 위한 조언들은 많지만 이러한 조언들은 조언자의 입을 떠나는 순간 생명력을 잃어버린다. 지식은 전수되지만 지혜는 전수되지 않기 때문이다. 스스로 경험하고 깨우쳐서 자기화시켜야 한다. 필자도 그 긴 여정을 따라가고 있는 견습생에 불과하다.객체지향의 설계 원칙이나 객체 지향의 철학적인 의미는 대단히 중요하다. 하지만 이러한 것들을 지금 언급한다면 미궁 속에 빠지게 될 것이다. 그래서 우리가 할 것은 일단은 지식부터 익히자는 것이다. 언어가 지원하는 객체지향 문법을 배우고, 이것들이 어떻게 동작하는지를 충분히 이해한 다음에 비로소 설계 원칙도 이야기할 수 있고, 객체와 사물의 비유도 시도해 볼 수 있을 것이다. 여기서는 몇 가지 객체지향이 추구하는 지향점을 가볍게 이야기하고 다음 토픽부터 구체적인 문법을 알아볼 것이다.부품화객체지향 프로그래밍을 구성하고 있는 컨셉들은 상당히 많다. 하나의 프로그램이 여러개의 로직으로 이루어져 있다. 그 로직을 그룹화 시켜놓고 로직과 관련된 변수와 메소드들을 그룹화 해놓은게 객체이다. 이렇게 함으로서 재활용성을 높일수 있다. 그럼 이 객체를 다른곳에 사용한다는 것은 이객체가 다른 곳, 여러곳에서 일종의 부품으로서 사용된다는 것이다.아래는 초창기의 컴퓨터이다.본체와 모니터, 키보드가 하나로 단일화되어 있다. 어딘가 고장나면 컴퓨터를 바꿔야할수도 있다.하지만 위의 이미지처럼 부품을 나누어 놓는다면 고장난 부품만 고치면 될것이다. (이미지 생활코딩 참조)객체 지향은 부품화의 정점이라고 할 수 있다. 하지만 우리는 아직 객체 지향을 배우지 않았다. 그래서 우리가 배운 것 중에서 부품화의 특성을 보여줄 수 있는 기능을 생각해보면 좋을 것 같다. 메소드는 부품화의 예라고 할 수 있다. 메소드를 사용하는 기본 취지는 연관되어 있는 로직들을 결합해서 메소드라는 완제품을 만드는 것이다. 그리고 이 메소드들을 부품으로 해서 하나의 완제품인 독립된 프로그램을 만드는 것이다. 메소드를 사용하면 코드의 양을 극적으로 줄일 수 있고, 메소드 별로 기능이 분류되어 있기 때문에 필요한 코드를 찾기도 쉽고 문제의 진단도 빨라진다.그런데 프로그램이 커지면 엄청나게 많은 메소드들이 생겨나게 된다. 메소드와 변수를 관리하는 것은 점점 어려운 일이 되기 시작한다. 급기야는 메소드가 없을 때와 같은 상황에 봉착하게 된다. 메소드는 프로그래밍의 역사에서 중요한 도약이었지만, 이 도약이 성숙하면서 새로운 도약지점이 보이기 시작한 것이다.그 도약 중의 하나가 객체 지향 프로그래밍이다. 이것의 핵심은 연관된 메소드와 그 메소드가 사용하는 변수들을 분류하고 그룹핑하는 것이다. 바로 그렇게 그룹핑 한 대상이 객체(Object)다. 비유하자면 파일과 디렉토리가 있을 때 메소드나 변수가 파일이라면 이 파일을 그룹핑하는 디렉토리가 객체라고 할 수 있다. 이를 통해서 더 큰 단위의 부품을 만들 수 있게 되었다. 객체를 만드는 법에 대해서 호기심이 생기지 않는가? 이런 호기심을 유발시키는 것이 이번 토픽의 목적이다. 객체를 만드는 법은 다음 토픽에서 알아보고 지금은 부품화에 대해서 조금 더 생각해보자.은닉화, 캡슐화제대로된 부품이라면 그것이 어떻게 만들어졌는지 모르는 사람도 그 부품을 사용하는 방법만 알면 쓸 수 있어야한다. 모니터가 어떻게 동작하는지는 몰라도 컴퓨터와 모니터를 연결하는 방법을 알면 모니터를 설치해 사용할 수 있는것과 같다. 즉 내부동작 방법을 단단한 케이스(객체)안으로 숨기고 사용자에게 그 부품의 사용방법(메소드)만을 노풀하고 있는 것이다. 이러한 컨셉을 정보의 은닉화(Information Hiding), 또는 캡슐화(Encapsulation)라고 부른다. 자연스럽게 사용자에게는 그 부품을 사용하는 방법이 중요한 것이 된다.인터페이스좋은부품의 또다른 특징은 인터페이스이다. 잘만든 부품은 서로 교환할 수 있어야 한다. 모니터를 바꾼다고 가정해보자 서로다른 회사의 모니터를 교환하려고 하면 회사가 다르더라도 모니터를 연결할 수 있어야 한다. 이것은 컴퓨터와 모니터를 연결해주는 케이블이 표준화 되어있기 때문에 가능한 것이다.컴퓨터와 모니터를 만드는 업체들은 HDMI케이블 규격을 공유한다. 각각의 부품은 미리 정해진 약속에 따라 신호의 입출력을 가능하게 해주는 연결점의 모양을 표준에 맞게 만들면 된다. 이러한 연결점을 인터페이스Interface)라고 한다. 즉 인터페이스는 부품들 간의 약속이다. 프로그래밍에서도 인터페이스에 해당하는것을 소프트웨어 적으로 제공하고 있다.  이러한 약속을 프로그램밍 적으로는 어떻게 구현하는가도 알아보자.지금까지 객체를 부품으로 비유해서 설명 했다. 그런데 비유는 비유일 뿐이다. 비유는 의도한 유사점 뿐만 아니라 의도하지 않은 차이점까지도 전달될 가능성이 있기 때문이다. 비유의 함정이라고 할 수 있다. 소프트웨어는 하드웨어가 아니다. 하드웨어가 할 수 없는 것을 소프트웨어는 할 수 있다. 그 중의 하나가 복제와 상속이다. 이러한 개념을 구체적인 문법 없이 설명하는 것은 효용이 크지 않을 뿐만 아니라 자칫 흥미를 저해할 위험이 있기 때문에 여기서는 설명하지 않았다. 소프트웨어가 있기 이전부터 하드웨어가 이룩한 성취를 잘 수용하면서 동시에 소프트웨어 다운 소프트웨어를 만드는 것은 우리게게 주워진 숙제라고 할 수 있다",
        "url": "/javascript-basic17"
    }
    ,
    
    "javascript-basic16": {
        "title": "Javascript - JavaScript 함수지향 - 함수의 호출",
            "author": "AhnSang0915",
            "category": "",
            "content": "Javascript    JavaScript 기본     JavaScript 숫자와 문자     JavaScript 변수, 비교    JavaScript 조건문    JavaScript 반복문    JavaScript 함수    JavaScript 배열    JavaScript 객체(Object)    JavaScript 모듈    JavaScript UI와 API    JavaScript 정규표현식    JavaScript 함수지향 - 유효범위    JavaScript 함수지향 - 값으로서의 함수와 콜백    JavaScript 함수지향 - 클로저    JavaScript 함수지향 - arguments    함수지향 - 함수의 호출    객체지향 - 객체지향 프로그래밍 소개    객체지향 - 생성자와 new    객체지향 - 전역객체    객체지향 - this    객체지향 - 상속    객체지향-표준 내장객체의 확장    JavaScript 객체지향-ObjectJavaScript 함수지향 - 함수의 호출1. apply 소개Javascript에서 함수는 일종의 객체이다. 객체는 속성을 갖고있고 그 속성의 값을 가지고있으면 속성(property)라고 부르고 함수를 갖고있다면 메소드(method)라고 부른다.\tfunction func(){ }func();//func라는 함수는 객체이고 메소드를 갖고있다. func.apply func.call이라는 메소드에 접근할수 있다. 이것들이 하는역할은 func라는 객체를 호출하는 역할을 한다.아래는 크롬 개발자 도구에서 실행한 코드이다. sum함수를 정의하고  arg1,arg2의 인자를 갖고있다. 여기서 특이한점은 sum(1,2), sum(4,2)를 실행한 결과와 sum.apply(null, [1,2]); sum.apply(null, [4,2]);를 한결과가 같다 이말은 .apply에 두번째 인자로 배열을 넣은 값들이 arg1, arg2가 되었다는 말이다. 다음 주제에서 왜 이렇게 복잡한 방법으로 함수를 호출하는지 그 이유를 배워보자.\tfunction sum(arg1, arg2) {    return arg1+arg2 ; }undefinedsum(1,2);3sum(4,2);6sum.applyƒ apply() { [native code] } // apply라고 하는 메소드가 브라우저에서 제공하는 메소드이기때문에 코드를 보여줄수 없다는 말이다. 내장된 코드는 네이티브 코드라는 메세지를 보여주게 되어있다.sum.apply(null, [1,2]);3sum.apply(null, [4,2]);62. apply 사용apply를 사용하는 구체적인 이유를 알아보자. 우선 아래 코드는 함수를 정의하고 있다. _sum이라는 변수를 0으로 초기화 시켰고, for in 문으로 this라는 객체에 담겨있는 값들을 하나씩 꺼내 _sum이라는 지역변수에 하나씩 더해 바깥으로 리턴해주고있다. this가 무엇인지는 javascript에서 상당히 중요하다. 이맥락에서 this가 무엇인지는 정해져 있지 않다. 이전의 예제와는 다르게 sum.apply(o1), 그리고 o2를 주었다. 이말은 sum이라는 메소드를 호출할때의 대상을 o1, o2로 준것이다. sum.apply(o1)을 하게되면 o1이 sum이라고 하는 함수의 this가 된다. 독립되어있는 함수가 sum.apply를 하고 o1, o2를 인자로 전달하게되면 o1.sum, o2.sum이라는 메소드가 된다는 것이다.o1 = {val1:1, val2:2, val3:3}o2 = {v1:10, v2:50, v3:100, v4:25}function sum(){ // sum.apply(o1)을 하게되면 var this = o1; 이되는거라고 생각하자.    var _sum = 0;     for(name in this){ //이 맥락에서 this는 정해져 있지 않다.        _sum += this[name];    }    return _sum;}alert(sum.apply(o1)) // 6alert(sum.apply(o2)) // 185위 코드를 aaply를 사용하지 않으면 아래 코드처럼 될것이다. 이렇게 작성하고 출력하게 되면 6과 185이후에 sum함수의 내용도 같이 출력이 된다. 우리가 sum이라는 함수를 o1, o2의 속성으로 추가했기 때문이다. sum : sum 의 왼쪽 sum은 o1, o2 객체의 속성(property)명이 되고 오른쪽 sum은 미리 만들어놓은 함수(function) sum이다. 그리고 객체를 호출하는데 객체의 접근방법은 속성명[property 또는 키값], 속성명.property 또는 키값으로 호출할수 있지만, 메서드의 경우 속성명.메소드명()로 접근한다. 따라서 o1.sum(),o2.sum()로 호출하고 이렇게 호출하면 for in문이 this를 열거하는 과정에서 sum이라는 함수도 더하고 있기때문에 숫자열을 더하고 문자열까지 더해 출력하게 되는것이다.function sum(){    var _sum = 0;    for(name in this){         _sum += this[name];    }    return _sum;}o1 = {val1:1, val2:2, val3:3, sum:sum}o2 = {v1:10, v2:50, v3:100, v4:25, sum:sum}alert(o1.sum());alert(o2.sum());위 출력에서 함수내용을 출력하지 않으려면  if(typeof this[name] !=== ‘function’ )를 사용해 출력에 제한을 주면 되겠다. 조건문을 사용해 typeof로 함수와 같지 않은경우만 더할것이라고 추가하면 함수의 차례가 오면 그부분을 스킵할 수 있게된다.function sum(){    var _sum = 0;    for(name in this){        if(typeof this[name] !=== 'function' )        _sum += this[name];    }    return _sum;}o1 = {val1:1, val2:2, val3:3, sum:sum}o2 = {v1:10, v2:50, v3:100, v4:25, sum:sum}alert(o1.sum());alert(o2.sum());물론 위의 방법대로 해도 사용할 수 있겠지만 복잡하기 때문에 apply를 사용하게되면 함수가 호출되는 시점에서 this값을 프로그래밍적으로 변경해 함수가 o1이라는 객체의 속성인것처럼 실행되게 할수있다.",
        "url": "/javascript-basic16"
    }
    ,
    
    "javascript-basic15": {
        "title": "Javascript - JavaScript 함수지향 - arguments",
            "author": "AhnSang0915",
            "category": "",
            "content": "Javascript    JavaScript 기본     JavaScript 숫자와 문자     JavaScript 변수, 비교    JavaScript 조건문    JavaScript 반복문    JavaScript 함수    JavaScript 배열    JavaScript 객체(Object)    JavaScript 모듈    JavaScript UI와 API    JavaScript 정규표현식    JavaScript 함수지향 - 유효범위    JavaScript 함수지향 - 값으로서의 함수와 콜백    JavaScript 함수지향 - 클로저    JavaScript 함수지향 - arguments    함수지향 - 함수의 호출    객체지향 - 객체지향 프로그래밍 소개    객체지향 - 생성자와 new    객체지향 - 전역객체    객체지향 - this    객체지향 - 상속    객체지향-표준 내장객체의 확장    JavaScript 객체지향-ObjectJavaScript 함수지향 - arguments1. arguments 소개arguments객체는 배열과 유사하다. arguments는 함수안에서 사용할 수 있도록 그 이름이나 특성이 약속되어 있는 일종의 배열이다. 몇개의 인자가 들어올지 모를떄 인자를 정의하지 않고 그함수 안에 arguments를 사용하여 결과를 알아내면 되겠다.아래의 예제는 매개변수가 없는 sum이라는 함수가 있다. javacsript는 관대한 언어이다. 매개변수가 없거나, 인자의 수와 매개변수의 수가 다르더라도 문제가 생기지 않는다.아래 for문에서의 arguments는 Javascript와 약속되어있는 특수한 이름의 변수명이다. arguments라는 배열이 담겨져 있다. 이 배열의 역할을 사용자가 전달한 인자(1,2,3,4)를 담는것이다. 그래서arguments.length는 4가되고 4만큼 for문이 반복되게된다.document.write(i+’ : ‘+arguments[i]+’&lt;\\br /&gt;’);는 0 : 1(인덱스0) 부터 차례로 표시하게되고, 그후 _sum의 변수에 +=(a+=1;는a=a+1;과 같다) arguments[i];를 담았다. 이말은 (1,2,3,4)의 값을 _sum = _sum + arguments[i]이다. 즉, sum_에 1234를 차례로 더한다는 것이다. _sum의 초기값은 0이기 때문에 10이된다.\tfunction sum(){    var i, _sum = 0;     // i 루프를 위한 변수 _sum 출력할 결과를 담아낼 변수    for(i = 0; i &lt; arguments.length; i++){       //arguments javascript와 약속되어있는 특수한 이름의 변수명        document.write(i+' : '+arguments[i]+'&lt;br /&gt;');        _sum += arguments[i];    }       return _sum;}document.write('result : ' + sum(1,2,3,4)); 2. 매개변수의 수 - function length함수명.length는 몇개의 매개변수를 갖고있는지 알려주고, arguments.length는 함수를 호출할때 몇개의 인자, 몇개의 arguments를 담고있는지의 정보를 담고있다.function zero(){    console.log(        'zero.length', zero.length,        'arguments', arguments.length    );}function one(arg1){    console.log(        'one.length', one.length,        'arguments', arguments.length    );}function two(arg1, arg2){    console.log(        'two.length', two.length,        'arguments', arguments.length    );}zero(); // zero.length 0 arguments 0 one('val1', 'val2');  // one.length 1 arguments 2 two('val1');  // two.length 2 arguments 1",
        "url": "/javascript-basic15"
    }
    ,
    
    "javascript-basic14": {
        "title": "Javascript - JavaScript 함수지향 - 클로저",
            "author": "AhnSang0915",
            "category": "",
            "content": "Javascript    JavaScript 기본     JavaScript 숫자와 문자     JavaScript 변수, 비교    JavaScript 조건문    JavaScript 반복문    JavaScript 함수    JavaScript 배열    JavaScript 객체(Object)    JavaScript 모듈    JavaScript UI와 API    JavaScript 정규표현식    JavaScript 함수지향 - 유효범위    JavaScript 함수지향 - 값으로서의 함수와 콜백    JavaScript 함수지향 - 클로저    JavaScript 함수지향 - arguments    함수지향 - 함수의 호출    객체지향 - 객체지향 프로그래밍 소개    객체지향 - 생성자와 new    객체지향 - 전역객체    객체지향 - this    객체지향 - 상속    객체지향-표준 내장객체의 확장    JavaScript 객체지향-ObjectJavaScript 함수지향 - 클로저클로저(closure)는 내부함수가 외부함수의 맥락(context)에 접근할 수 있는 것을 가르킨다. 클로저는 자바스크립트를 이용한 고난이도의 테크닉을 구사하는데 필수적인 개념으로 활용된다.1. 내부함수, 외부함수내부함수아래 코드는 함수안에 또다른 함수를 선언한 것이다. 함수 outter은 외부함수가 되고 inner함수는 내부함수가 된다. inner함수는 var inner = fuction {} 과 같게된다.\tfunction outter(){    function inner(){        var title = 'coding everybody';         alert(title);    }    inner();}outter();아래 코드는 outter란 외부함수에 var title = ‘coding everyday’; 라는 지역변수를 만들었다. 그리고 내부함수로 inner을 만들었는데, 이때 이 내부함수 inner에 title이라는 변수를 사용하려고 하는데 이때 inner라는 함수에 지역변수가 존재하지 않는다면 Javascript는 이 inner라는 내부함수를 포함하고 있는 외부함수에서 title이라고하는 변수를 찾게된다. 즉, 내부함수에서 외부함수의 지역변수에 접근할 수 있다.이러한 것을 클로저(closure)라고 한다.function outter(){    var title = 'coding everybody';      function inner(){                alert(title);    }    inner();}outter();2. 클로저란?클로저(closure)는 내부함수와 밀접한 관계를 가지고 있는 주제다. 내부함수는 외부함수의 지역변수에 접근 할 수 있는데 외부함수의 실행이 끝나서 외부함수가 소멸된 이후에도 내부함수가 외부함수의 변수에 접근 할 수 있다. 이러한 메커니즘을 클로저라고 한다. 아래 예제는 이전의 예제를 조금 변형한 것이다. 내부함수inner를 outter함수내에서 호출하는 것이 아니라 반환하도록 했다. 함수 outter는 내부함수 inner를 반환하고 생을 마감했다. 즉, 함수 outter는 실행된 이후 실행이 종료되어 함수 ouuter의 변수 title또한 더이상 유효하지 않게되어 변수 title에 접근할수 없어 보인다. 그러나 아래 코드의 실행 결과는 경고창으로 coding everybody를 출력할 것이다. 이처럼 자신을 포함하고 있는 외부함수보다 내부함수가 더 오래 유지되는 경우, 외부함수 밖에서 내부함수가 호출되더라도 외부함수의 지역 변수에 접근할 수 있는데 이러한 함수를 클로저(closure)라고 부른다.function outter(){    var title = 'coding everybody';      return function(){                alert(title);    }}var inner = outter();inner();즉, 클로저는 반환된 내부함수가 자신이 선언됐을 때의 환경(Lexical environment)인 스코프를 기억하여 자신이 선언됐을 때의 환경(스코프) 밖에서 호출되어도 그 환경(스코프)에 접근할 수 있는 함수를 말한다. 이를 조금 더 간단히 말하면 클로저는 자신이 생성될 때의 환경(Lexical environment)을 기억하는 함수다라고 말할 수 있겠다.3. Private variable소프트웨어가 커지는 과정에서 어떠한 정보가 있을때 그 정보를 아무나 수정하는것을 방지하는 것을 Private variable이라 한다. 소프트웨어가 커지면 여러사람이 코드를 작성하게 된다. 그안에는 과거의 자기자신과 미래의 자기자신이 포함되게된다. 그런경우 많은 데이터가 소프트웨어 안에 존재하게 되는데 그 데이터가 누구나 고칠수있는 데이터가 된다는것은 그데이터가 망가질 가능성이 크다는 것이다. 그런 것을 방지하기 위해 접근하는 방법을 클로저를 사용하여 데이터를 가져오고 수정하는 것을 안전하게 하는것이다.아래는 factory_movie라는 외부함수가 get_title, set_title이라는 두 메소드에 함수를 지정한 객체를 담고있다. 이때 get_title, set_title은 내부 함수가 된다. get_title메소드를 호출하면 title이라는 값을 리턴하는데 그 title의 값은 factory_movie함수에 첫번째 인자이다. 첫번째 매개변수가 title이고 이 매개변수는 함수안에서 지역변수로 사용이 된다. 그렇기 때문에 factory_movie(title)은 지역변수이고 지역변수는 내부함수에서 접근이 가능하기 때문에 get_title을 호출하면 factory_movie의 첫번째 매개변수인 title이 값이 되기때문에 factory_movie함수의 (title)에 전달된 값을 리턴해준다. 그리고 set_title메소드는 첫번째 인자로 _title을 갖고 그리고 _title이라는 값은 다시 title이되고 그값은 내부변수를 의미하기때문에 factory_movie의 (title)을 변경하게 된다. 그다음 ghost와 matix라는 변수에 리턴값을 담았다. alert(ghost.get_title()); 는 ‘Ghost in the shell’을 출력하고, alert(matrix.get_title());는 ‘Matrix’를 출력한다. 이말은 ghost와 matix가 같은 객체를 담고 있지만 그 객체가 담고있는 get_title이라는 메소드가 접근하는 title이라고하는 외부변수에 담겨있는 값은 서로 다르다는 것이다. ghost.set_title(‘공각기동대’);는 ghost라는 변수 안에 set_title이라는 메소드를 호출하고 ‘공각기동대’ 를 인자로 사용하겠다는 말이다. ‘공각기동대는’ _title이되고 _title은 title이 되기 때문에 이 타이틀의 값은 factory_movie함수의 지역변수를 바꾸게 된다. alert(ghost.get_title());를 호출하게 되면 ‘공각기동대’를 출력하고, alert(matrix.get_title());를 호출하면 ‘Matrix’를 실행하게 된다. 즉, 우리가 factory_moviex통해 두개의 ghost와 matix변수를 만들었고, 그두개의 변수는 자신들이 실행된 그 시점에서의 외부함수의 지역변수에 접근할 수있었고 그지역변수의 값은 유지되고 있기때문에 ghost라는 함수에 set_title을 통해서 그내용을 ‘공각기동대’로 바꾼다 라는것은 ghost가 접근할수있는 title의 값만을 바꾸는것이지 matrix라는 변수가 접근할수 있는 title의 값에는 어떠한 영향도 미치지 않는다는 것이다.function factory_movie(title){    return {        get_title : function (){            return title;        },        set_title : function(_title){            title = _title        }    }}ghost = factory_movie('Ghost in the shell');matrix = factory_movie('Matrix'); alert(ghost.get_title());alert(matrix.get_title()); ghost.set_title('공각기동대'); alert(ghost.get_title());alert(matrix.get_title());이코드의 진짜 효용은 private variable이라는 것이다.  ghost와 matix변수에 객체를 담았다. 이객체의 get_title, set_title은 언제든지 접근할 수 있는 메소드이다. 누구나 접근할수 있다는 것이다. get_title, set_title이 내부적으로 사용하고 이있는 변수는 title이다. 이title은 외부 함수의 지역변수인 title이다.이지역변수인 title은 factory_movie라는 함수가 어떠한 값을 리턴했을때 factory_movie함수 자체는 실행이 끝났기 때문에 그지역변수인 title은 factory_movie의 내부함수인 get_title, set_title을 통해서만 접근할 수 있는 변수가 되는것이다. 즉, 우리가 title이라는 변수 값을 private variable로 만들고 그값을 수정할때는 set_titl을 통해서만 수정할 수 있고, 그변수의 값을 가져올때는 get_title를 통해서만 가져올 수 있게 하면 title이라는 변수가 안전하게 저장,수정될 수 있다는 것이다.4. 클로저의 응용클로저를 활용하는 것에서 실수하기 쉬운 예제를 보자. Javascript에서는 오로지 함수의 괄호 안에서만 지역변수로서 할당되고 그 외 모든 장소는 전역변수로 취급을 받는다. 우리가 예상하는 결과는 0,1,2,3,4 일것이다. 하지만 그렇지 않다. 첫번째 for문이 반복되는 동안 점점 증가되는 i의 값이 arr라는 배열에 저장될 것 같지만, 실제로 저장되는 것은 함수 그 자체이다. i는 반복이 끝난후 5라는 값이되고 return i 의 값은 5가된다. 그리고 다음 for in문에서 arr[index]는 해당 인덱스의 값으로서의 함수이고 ()를 붙였음으로 해당 함수가 호출된다. i 값은 첫번째 for문을 돌아 5가된 상태이기 때문에 5, 5, 5, 5, 5가 출력된다.var arr = []for(var i = 0; i &lt; 5; i++){    arr[i] = function(){        return i;    }}for(var index in arr) {    console.log(arr[index]());}그렇다면 정상출력 0, 1, 2, 3, 4을 얻기위해선 어떻게 해야할까? 위의 코드에서 달라진 점은 그전의 코드를 외부 함수로 감싸주어서 원래 함수는 내부 함수가 된다는 것아다. 그리고 외부 함수는 내부 함수를 값으로 반환하는데 그 자리에서 바로 그 외부 함수를 호출하기 때문에 내부 함수가 값으로서 반환되어 바로 변수에 할당이 된다.var arr = []for(var i = 0; i &lt; 5; i++){    arr[i] = function(id) {        return function(){            return id;        }    }(i);}for(var index in arr) {    console.log(arr[index]());}/* 결과01234*/위의 두 예제에서 첫번째 for문을 비교한 것이다.var arr = [];for(var i = 0; i &lt; 5; i++){  arr[i] = function(){    return i;  }}  arr[0] = function(){    return i;  }  arr[1] = function(){    return i;  }  arr[2] = function(){    return i;  }  arr[3] = function(){    return i;  }  arr[4] = function(){    return i;  }for(var i = 0 ; i &lt; 5; i++){  arr[i] = function(id){  //외부함수.    return function(){    //내부함수.      return id;    }  }(i);  //외부함수 호출}  arr[0] = function(){      return 0;  }  arr[1] = function(){      return 1;  }  arr[2] = function(){      return 2;  }  arr[3] = function(){      return 3;  }  arr[4] = function(){      return 4;  }",
        "url": "/javascript-basic14"
    }
    ,
    
    "javascript-basic13": {
        "title": "Javascript - JavaScript 함수지향 - 값으로서의 함수와 콜백",
            "author": "AhnSang0915",
            "category": "",
            "content": "Javascript    JavaScript 기본     JavaScript 숫자와 문자     JavaScript 변수, 비교    JavaScript 조건문    JavaScript 반복문    JavaScript 함수    JavaScript 배열    JavaScript 객체(Object)    JavaScript 모듈    JavaScript UI와 API    JavaScript 정규표현식    JavaScript 함수지향 - 유효범위    JavaScript 함수지향 - 값으로서의 함수와 콜백    JavaScript 함수지향 - 클로저    JavaScript 함수지향 - arguments    함수지향 - 함수의 호출    객체지향 - 객체지향 프로그래밍 소개    객체지향 - 생성자와 new    객체지향 - 전역객체    객체지향 - this    객체지향 - 상속    객체지향-표준 내장객체의 확장    JavaScript 객체지향-ObjectJavaScript 함수지향 - 값으로서의 함수와 콜백1. 값으로서의 함수Javascript에서는 함수도 객체이다. 함수를 일단 값이라고 생각하자. 값의 특징은 어떠한 변수에 담을수 있다. var a = “value” a라는 변수에 값으로 value를 넣은것이다. 함수가 일종의 값이라는 것은 함수 역시 어떤 변수에 담을수 있다는 것이다. Javascript의 함수가 다른 언어의 함수와 다른 점은 함수가 값이 될 수 있다는 점이다. 예제를 보자.\tfunction a(){} // var a = function () {}위 예제에서 a라고하는 함수를 정의했다. 위처럼 함수를 정의하는 것은 a라고하는 변수에 담겨진 값이라는 것이다. 아래 예제에선 객체에 변수를 담았다. a라는 객체에 b라는 key와 function(){}이란 value를 담은것이다. 이처럼 객체 안에 함수를 담게되면 함수는 값이기 때문에 b는 객체안에서 변수와 같은 역할을 하고있다. 객체안에서 변수의 역할을 하는것을 속성(Property)라고 하고 그 속성에 저장된 값이 함수라면 그함수는 이러한 맥락에선 메소드(method)라고 한다.a = {    b:function(){    }};또한 함수는 값이기 때문에 다른 함수의 인자로 전달 될수도 있다. increase는 num이라는 매개변수에 +1을해 리턴, decrease는 -1알한 값을 리턴해준다. cal이라는 함수는 func, num이라는 매개변수를 갖고있고 func의 함수에 num이라는 값을 호출하고있다. alert(cal(increase, 1));을 하게되면 cal의 매개변수가 increase, 1이 인자가 된다. 즉, increase라는 함수에 1이라는 인자가 전달되기 때문에 2가된다.function cal(func, num){    return func(num)}function increase(num){    return num+1}function decrease(num){    return num-1}alert(cal(increase, 1));alert(cal(decrease, 1));2. 값으로서의 함수와 콜백 - 함수의 용도2함수는 함수의 리턴 값으로도 사용할 수 있다. 아래 코드를 보자. cal라는 함수를 호출할때 첫번째 인자로 ‘plus’ 라는값을 주면 객체를 담고있는 함수에 ‘plus’라는 인자가 들어가게 되고 function cal(‘plus’), return funcs(‘plus’)가 된다. alert(cal(‘plus’) (2, 1))에서 (cal(‘plus’)는 function(left, right){return left + right} 이부분이 되고, alert(cal(‘plus’) (2, 1)) 에서 (2, 1)은 함수를 호출하겠다는 말이고 인자로 2, 1을 전달하겠다는 것이다. 결과는 3이된다.function cal(mode){    var funcs = {        'plus' : function(left, right){return left + right},        'minus' : function(left, right){return left - right}    }    return funcs[mode];}alert(cal('plus')(2,1));alert(cal('minus')(2,1));당연히 배열의 값으로도 사용할 수 있다. process라는 배열을 정의했고 배열안의 요소 3개가 모두 함수이다. for반복문에서  i = 0 일때 process라는 배열의 index 0의 요소의 함수를 호출하고 첫번째 인자로 1을 전달한다. 이후 input의 값은 11이되고 index 다시 반복문으로 돌아와 1의 요소의 함수를 호출하게 된다. 이때 input의 값은 배열의 첫번쨰 요소에서 얻은 11이 된다. 값은 121이 되고 이 값은 다시 input의 값이 된다. 이후배열의 세번째 요소로 121의 값이 전달되고 60.5의 결과가 나온다.var process = [    function(input){ return input + 10;},    function(input){ return input * input;},    function(input){ return input / 2;}];var input = 1;for(var i = 0; i &lt; process.length; i++){    input = process[i](input);}alert(input);3. 값으로서의 함수와 콜백 - 콜백이란?콜백은 어떠한 함수가 수신하는 인자가 함수인 경우를 콜백이라고 한다. 처리의 위임값으로 사용될 수 있는 특성을 이용하면 함수의 인자로 함수로 전달할 수 있다. 값으로 전달된 함수는 호출될 수 있기 때문에 이를 이용하면 함수의 동작을 완전히 바꿀 수 있다. 인자로 전달된 함수 sortNumber의 구현에 따라서 sort의 동작방법이 완전히 바뀌게 된다.아래 예제에서 배열의 내용을 정렬하려면 numbers.sort();라는 명령을 내리는 것이다. 여기서 .앞의 numbers는 배열객체가 되고 우리가 아래처럼 [20, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1]를 작성해 Javascript에 제출을하면 배열객체를 만들어 numbers라고하는 변수에 담아준다. 그리고 배열객체에는 sort라고하는 함수가 정의되어 있기때문에 numbers.sort();를 통해서 배열이 가지고있는 명령어 sort를 호출하게 되는데 여기서 sort는 함수라고 하지않고 객체에 속해있기 때문에 메소드라고 한다. 이러한 numbers객체 또는 sort메소드는 Javascript에서 기본적으로 제공하는 기능이기 때문에 이러한 기능을 내장 객체 내장 메소드, 또는 빌트인 객체 빌트인 메소드라고 한다. 그리고 우리가 만드는 객체나 메소드, 함수같은 것들은 우리가 만드는 것이기 때문에 사용자정의 객체, 사용자정의 메소드 라고한다.&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;script src=\"//code.jquery.com/jquery-1.11.0.min.js\"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;script type=\"text/javascript\"&gt;    var numbers = [20, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1];    numbers.sort(); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;위의 코드를 실행하면 배열안의 내용을 정렬해주고 결과는 [1, 10, 2, 20, 3, 4, 5, 6, 7, 8, 9] 가 출력된다. 이유는 숫작의 크기로 비교한게 아니고 문자로 비교를 했기 때문이다. 앞의 숫자가 1인것들이 우선순위를 갖고 나머지를 정렬했기 때문이다. 우리가 원하는 결과를 얻기 위해선 아래의 방법을 이용해야 한다.&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;script src=\"//code.jquery.com/jquery-1.11.0.min.js\"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;script type=\"text/javascript\"&gt;    var numbers = [20, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1];    var sortfunc = function(a, b) {        console.log(a, b);        if(a &gt; b) {            return 1;        } else if (a&gt;b){            return -1;        } else {            return 0;        }    }    console.log(numbers.sort(sortfunc)); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;위의 코드를 단순하게 하면 아래처럼 된다. 아래의 함수에서 sortfunc가 콜백함수가 되고 콜백 함수 라는것은 콜백함수를 수신받는 sort메소드가 sortfunc를 인자로 전달받아 내부적으로 호출하는 것을 통해서 sort함수가 동작하는 기본적인 동작방법을 변경할수 있게 된다. 즉, 값으로서 함수를 사용할수 있기때문에 함수의 동작방법을 값을 전달하는 것을 통해 바꿀수 있는게 콜백 이다. 그리고 콜백이 가능한 것은 Javascript의 함수가 값이기 때문에 가능한 것이다.&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;script src=\"//code.jquery.com/jquery-1.11.0.min.js\"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;script type=\"text/javascript\"&gt;    var numbers = [20, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1];    var sortfunc = function(a, b) {        return a-b; // 역순 b-a     }    console.log(numbers.sort(sortfunc)); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;4. 비동기 콜백과  Ajax예를 들어 우리가 홈페이지를 운영하는데 만명정도의 구독자가 있다고 치자. 우리가 글을쓰면 만명에게 메일이 전송되게 되어있다. 한명에게 메일을 보내는데 1초가 걸리면 만명에게 보내는데에는 만초가 걸리게 된다. 글을 작성하고 이메일을 전송후 작성완료까지 3시간을 기다려야 한다면 이런 서비스를 사용하기는 힘들것이다.이렇게 순서대로 실행하는 것을 동기적 처리라고한다. 그런데 우리가 글작성을하고 이메일을 발송하지 않고 발송 예약후 작성완료를 하게 되면 시간이 훨씬 줄어들게 된다. 그리고 내부적으로 사용자에게 노출되지 않는 프로그램이 작동하면서 이메일 발송예약이 들어와 있는지 아닌지를 확인해 들어와있다면 프로그램이 만명에게 이메일 발송하는 작업을 3시간동안 백그라운드에서 진행하면 될것이다. 이렇게 처리하는 방식을 비동기적인 처리라고한다. 우리는 이 비동기적 처리를 Ajax(Asynchronous javascript and xml) 로 사용할 수 있다.우리가 아래와 같은 객체를 만든 파일을 만들었다고 가정하고 예제를 보자.{\"title\":\"JavaScript\",\"author\":\"egoing\"}생활코딩의 동영상을 보고 이해하는것이 좋겠다…(아직 이해못함.)&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;script src=\"//code.jquery.com/jquery-1.11.0.min.js\"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;script type=\"text/javascript\"&gt;    $.get('./datasource.json.js', function(result){ //$는 jquery가 제공하는 특수한 객체이다. 여기에 get이라는 메소드를 사용해 json타입 파일을 호출하는 것이다.        console.log(result);    }, 'json');&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;",
        "url": "/javascript-basic13"
    }
    ,
    
    "javascript-basic12": {
        "title": "Javascript - JavaScript 함수지향 - 유효범위",
            "author": "AhnSang0915",
            "category": "",
            "content": "Javascript    JavaScript 기본     JavaScript 숫자와 문자     JavaScript 변수, 비교    JavaScript 조건문    JavaScript 반복문    JavaScript 함수    JavaScript 배열    JavaScript 객체(Object)    JavaScript 모듈    JavaScript UI와 API    JavaScript 정규표현식    JavaScript 함수지향 - 유효범위    JavaScript 함수지향 - 값으로서의 함수와 콜백    JavaScript 함수지향 - 클로저    JavaScript 함수지향 - arguments    함수지향 - 함수의 호출    객체지향 - 객체지향 프로그래밍 소개    객체지향 - 생성자와 new    객체지향 - 전역객체    객체지향 - this    객체지향 - 상속    객체지향-표준 내장객체의 확장    JavaScript 객체지향-ObjectJavaScript 함수지향 - 유효범위1. 전역변수와 지역변수유효범위(Scope)는 변수의 수명을 의미한다. 아래의 예제를 보자. vscope라는 변수에 global이라는 데이터를 할당했다. fscope라는 함수는 함수 안에 선언되어 있지 않은, 함수 바깥쪽에 선언되어있는 vscope에 접근할 수 있다. 결과는 global이다.var vscope = 'global';function fscope(){    alert(vscope);}fscope();아래를 실행하게 되면 결과는 ‘함수안 local’과 ‘함수밖 global’이 출력된다. fscope 함수안에 vscope라는 변수가 할당되어 있기 때문에 vscope는 자기자신과 가까이에 있는 vscope를 가르키기 때문에 ‘local’이라는 값을 출력하게 된다. 함수안의 fscope 함수안에 정의 되어 있는 vscope는 지역변수(local variables) 이고, 함수밖에  정의되어 있는 vscope변수는 전역변수(global variables)라고 한다.즉 지역변수의 유효범위는 함수 안이고, 전역변수의 유효범위는 에플리케이션 전역인데, 같은 이름의 지역변수와 전역변수가 동시에 정의되어 있다면 지역변수가 우선한다는 것을 알 수 있다.var vscope = 'global';function fscope(){    var vscope = 'local';    alert('함수안 '+vscope);}fscope();alert('함수밖 '+vscope);var을 쓴것과 쓰지않은것의 차이점을 알아보자. var을쓰면 전역변수를 호출하게되고 var을 쓰지않으면 vscope가 지역변수가 되어 global을 local로 변경하게된다. 즉,  var을 사용하지 않은 지역변수는 전역변수가 된다. fscope라는 함수에 var쓰고 변수를 지정하게 되면 fscope함수에 지역변수를 지정한것이다. 그렇기 때문에 전역 변수의 값이 local로 변경 된 것이다. 그렇기 때문에 출력은 local이 되게 된다.var vscope = 'global';function fscope(){    var vscope = 'local';   }fscope();alert(vscope);// var을 쓸때 global// var을 쓰지 않을때 local아래 예제는 어떻게 될까? 마찬가지로 global을 출력하게 된다. 이유는 이미 var vscope으로 인해 지역변수가 생성이되었다. 그렇기 때문에 vscope를 사용해도 지역변수가 되는것이지 전역변수가 변경되지는 않는다.var vscope = 'global';function fscope(){    var vscope = 'local';    vscope = 'local';   }fscope();alert(vscope);// global2. 유효범위의 효용아래 두개의 예제는 변수 i를 지역변수로 사용했을 때와 전역변수로 사용했을 때의 차이점을 보여준다. 전역변수는 각기 다른 로직에서 사용하는 같은 이름의 변수값을 변경시켜서 의도하지 않은 문제를 발생시킨다.같은 이름을 사용했지만 var을 사용하는것과 사용하지 않는것의 차이가 있다. for문 안에들어있는 i의 값이 선언된것은 어떤 함수에 소속되지 않은 것이다. 그렇기 때문에 전역변수이고 함수 a를 호출하게 되면 변수 i의 값을 0으로 바꿔주고 있다. 그런데 var을 붙이지 않은것은 전역변수를 의미하게 된다. a함수와 for문이 가르키고 있는 i가 같기때문에 a가 실행될때마다 i의값이 매번 0으로 초기화된다. 따라서 무한반복하는 현상이 나타나고 같은이름의 변수를 중복해서 사용했지만 각각의 취지가 다를 때 이런현상이 일어난다.function a (){    var i = 0; //결과 01234    // i=0; // 결과 무한반복}for(var i = 0; i &lt; 5; i++){    a();    document.write(i);}3. 전역변수를 사용하는 법불가피하게 전역변수를 사용해야 하는 경우는 하나의 객체를 전역변수로 만들고 객체의 속성으로 변수를 관리하는 방법을 사용한다.아래의 예제는 MYAPP이라는 전역변수 하나를 만들어서 속성을 지정해 만들었다. 이처럼 전역변수 하나만을 만들고 나머지 다른 전역변수들은 바로 그 전역변수의 소속에 해당되게 만들면 변수의 이름이 충돌할 가능성이 낮아진다.var MYAPP = {}MYAPP.calculator = { //calculator 속성    'left' : null,    'right' : null}MYAPP.coordinate = {    'left' : null,    'right' : null} MYAPP.calculator.left = 10;MYAPP.calculator.right = 20;function sum(){    return MYAPP.calculator.left + MYAPP.calculator.right;}document.write(sum());아래의 예제는 함수안에 변수를 지정해 함수의 지역변수로 만들었다. 함수를 정의하고 바로 호출하는 기법을 익명함수라고 한다. 이러한 기법을 이용해 전역변수가 하나도 존재하지않는 방식을 사용할 수도있다.(function(){    var MYAPP = {}    MYAPP.calculator = {        'left' : null,        'right' : null    }    MYAPP.coordinate = {        'left' : null,        'right' : null    }    MYAPP.calculator.left = 10;    MYAPP.calculator.right = 20;    function sum(){        return MYAPP.calculator.left + MYAPP.calculator.right;    }    document.write(sum());}())4. 유효범위의 대상Javascript는 함수에 대한 유효범위만을 제공한다. 다시말해 Javascript 에선 for문이나 if문에서 중괄호 안에서 선언된 변수는 지역변수로서의 의미를 갖지 않는다. 많은 언어들이 블록(대체로 {,})에 대한 유효범위를 제공하는 것과 다른 점이다. 아래 예제의 결과는 coding everybody이다.for(var i = 0; i &lt; 1; i++){    var name = 'coding everybody';}alert(name);자바에서는 아래의 코드는 허용되지 않는다. name은 지역변수로 for 문 안에서 선언 되었는데 이를 for문 밖에서 호출하고 있기 때문이다.for(int i = 0; i &lt; 10; i++){    String name = \"egoing\";}System.out.println(name);5. 정적 유효범위자바스크립트는 함수가 선언된 시점에서의 유효범위를 갖는다. 이러한 유효범위의 방식을 정적 유효범위(static scoping), 혹은 렉시컬(lexical scoping)이라고 한다. 이는 이후에 살펴볼 클로저와 연관되어 있다.전역변수 var i = 5가 정의되어 있고 a 함수는 var i = 10이라는 지역변수를 정의하고 있다. a라고 하는 함수를 호출했을 때 함수의 내부적으로 i의 값이 10이 된다. 그 상태에서 b를 호출하게 되면 i는 b 함수 안에 i라고 하는 지역변수가 존재하는지 찾게 된다. 없다면 전역변수를 찾게 되는데 b를 호출하고 있는 함수는 a이다.그렇다면 a 함수에 정의된 변수 a를 호출하게 될까? 아니다. 왜냐하면, 함수 b가 선언된 시점에서 i의 전역변수가 사용되는 것이지 b가 호출된 시점에서 b가 담겨있는 함수의 지역변수가 사용되는 것이 아니다. 즉, 사용될 때 가 아니고 정의 될 때의 전역변수가 사용되게 된다는 말이다. 이러한 것을 정적 유효범위 또는 렉시컬(lexical scoping)유효범위라고 한다.var i = 5; // 전역변수 function a(){    var i = 10; // 지역변수    b();} function b(){    document.write(i);} a(); // 5",
        "url": "/javascript-basic12"
    }
    ,
    
    "javascript-basic11": {
        "title": "Javascript - JavaScript 정규표현식",
            "author": "AhnSang0915",
            "category": "",
            "content": "Javascript    JavaScript 기본     JavaScript 숫자와 문자     JavaScript 변수, 비교    JavaScript 조건문    JavaScript 반복문    JavaScript 함수    JavaScript 배열    JavaScript 객체(Object)    JavaScript 모듈    JavaScript UI와 API    JavaScript 정규표현식    JavaScript 함수지향 - 유효범위    JavaScript 함수지향 - 값으로서의 함수와 콜백    JavaScript 함수지향 - 클로저    JavaScript 함수지향 - arguments    함수지향 - 함수의 호출    객체지향 - 객체지향 프로그래밍 소개    객체지향 - 생성자와 new    객체지향 - 전역객체    객체지향 - this    객체지향 - 상속    객체지향-표준 내장객체의 확장    JavaScript 객체지향-ObjectJavaScript 정규표현식정규표현식(Reguler expression)은 문자열 안에서 어떠한 문자가 있는지 없는지, 그문자를 다른 문자로 치환하는 것들을 도와주는 방법이다. 정보와 관련된 언어에서는 정규표현식이 매우 중요하다. 정규표현식의 공부는 양이 많아 따로 해야한다 링크를 통해 공부하고 아래내용을 보는게 좋겠다.1. 패턴만들기정규 표현식은 두가지 사용방법으로 이루어진다. 하나는 컴파일(compile) 다른 하나는 실행(execution)이다. 우선 컴파일부터 알아보자. 우리가 문자열을 변수에 담을때 var str = “a”; 의 식으로 하게된다. 마찬가지로 우리가 정규표현식을 만들때 정규표현식 리터럴이라는것을 이용해 만든다.//정규표현식 리터럴var pattern = /a/;또하나의 방법은 정규표현식 객체 생성자를 사용하는 방법이다. 두방법 모두 정규표현식 객체를 pattern이라는 변수에 담은것이다. 우리가 찾고자하는 정보를 pattern이라는 변수에 저장을 한것이다.var pattern = new RegExp('a');2. RegExp객체의 사용우리가 어떤일을 할때 두가지 방법이 있다. 작업을 할 대상을 선택하고 그리고 그대상에 대하 어떤작업을 할지 정한다. 먼저 해야할 것은 작업할 대상을 찾는것이다. 이작업을 할수 있게 해주는게 정규표현식이다.정규표현식 메소드 실행정규표현식을 컴파일해서 객체를 만들었다면 이제 문자열에서 원하는 문자를 찾아내야 한다.RegExp.exec()문자열 a를 찾고싶다고할때 pattern변수안에 정규표현식 a를 지정하고 RegExp.exec()로 실행을 시킬수 있다.RegExp는 정규표현식을 의미하고 exec는 실행을 의미한다. 즉, 우리가 지정한 정규표현식을 실행하는데 그실행의 대상을 첫번째 인자로 전달하고, 그정보가 있는지 없는지 찾으려고 하는 정보가 (‘abcdef’) 이고 이것이 두번째 인자가 된다. 실행결과는 문자열 a를 값으로 하는 배열을 리턴한다.var pattern = /a/;console.log(pattern.exec('abcdef')); // [\"a\"]이번엔 변수에 정규표현식 a.을 담았다. 결과는 ab가되는데 이것은 정규표현식에서 .이 문자 1개를 의미하기 때문이다.var pattern = /a./;console.log(pattern.exec('abcdef')); // [\"ab\"]인자 ‘bcdef’에는 a가 없기 때문에 null을 리턴한다.var pattern = /a/;console.log(pattern.exec('bcdefg')); // nullRegExp.test()우리가 필요한 정보를 추출해내야 할때 사용한다. 우리가 찾는 어떤 정보가 있는지 없는지를 존재 유무를 테스트 한다.test는 인자 안에 패턴에 해당되는 문자열이 있으면 true, 없으면 false를 리턴한다var pattern = /a/;console.log(pattern.test('abcdef')); // truecnosole.log(pattern.test('bcdefg')); // false3. String과 정규표현식String.match()RegExp.exec()와 비슷하다.var pattern = /a/;console.log('abcdef'.match(pattern)); // [\"a\"]console.log('bcdefg'.match(pattern)); // nullString.replace()String.replace()는 문자열에서 패턴을 검색해서 이를 변경한 후에 변경된 값을 리턴한다.pattern a를 찾아 A로 치환해주었다.console.log('abcdef'.replace(pattern, 'A'));  // Abcdef4. 옵션(i, g)정규표현식 패턴을 만들 때 옵션을 설정할수있다. 찾고자하는 값 뒤에 옵션을 넣어주면 되고, 옵션에 따라 검출되는 데이터가 달라진다.i는 대소문자 구분을 없애주는 역할을 한다.var xi = /a/;console.log(\"Abcde\".match(xi)); // nullvar oi = /a/i;console.log(\"Abcde\".match(oi)); // [\"A\"];g는 문자열에 포함되어 있는 패턴에 해당되는 문자열들을 모두 리턴해준다.var xg = /a/;console.log(\"abcdea\".match(xg)); // [\"a\"]var og = /a/g;console.log(\"abcdea\".match(og)); // [\"a\",\"a\"]두가지 모두 사용도 가능하다.var og = /a/ig;console.log(\"AabcdAa\".match(ig)); // [\"A\",\"a\",\"A\",\"a\"]5. 캡쳐그룹을 지정하고 지정된 그룹을 가져와 사용하는 기능, 또는 사용할 수 있는 개념을 캡쳐라고 부른다.var pattern = /(\\w+)\\s(\\w+)/; // 문자열 공백 문자열var str = \"coding everybody\"; //coding$1 everybody$2var result = str.replace(pattern, \"$2, $1\"); //$2,(공백)$1로 치환.console.log(result);//everybody, coding6. 치환아래 코드는 본문 중의 URL을 링크 html 태그로 교체한다. \\b는 단어를 식별한다. ?:로 https를 캡쳐로 지정하지 않고 뒤에 ?로 https, http가 모두 해당되게 했다. 뒤에 //는 escape를 사용해 문자화 시켰고 그뒤의 a-z는 a부터 z까지 0-9 는 0에서 9까지 그리고 그뒤에 주소에 들어갈만한 특수문자들 까지 해당되게 해줬다. 그리고 replace라는 메소드가 실행될때 urlPattern해당되는 텍스트를 찾을때마다 두번째인자로 전달된 함수가 replace라는 메소드 내부로 호출된다. 호출될때 javascript는 호출된 시점에서 검색된 문자열을 첫번째 인자(url)로 전달되게 약속되어있다. 그리고 그 텍스트를 가공을하고 리턴을 해주면 우리가 변경하고싶은 내용으로 변경되게 된다.var urlPattern = /\\b(?:https?):\\/\\/[a-z0-9-+&amp;@#\\/%?=~_|!:,.;]*/gim;var content = '생활코딩 : http://opentutorials.org/course/1 입니다. 네이버 : http://naver.com 입니다. ';var result = content.replace(urlPattern, function(url){    return '&lt;a href=\"'+url+'\"&gt;'+url+'&lt;/a&gt;';});console.log(result);//생활코딩 : &lt;a href=\"http://opentutorials.org/course/1\"&gt;http://opentutorials.org/course/1&lt;/a&gt; 입니다. 네이버 : &lt;a href=\"http://naver.com\"&gt;http://naver.com&lt;/a&gt; 입니다.",
        "url": "/javascript-basic11"
    }
    ,
    
    "javascript-basic10": {
        "title": "Javascript - JavaScript UI와 API",
            "author": "AhnSang0915",
            "category": "",
            "content": "Javascript    JavaScript 기본     JavaScript 숫자와 문자     JavaScript 변수, 비교    JavaScript 조건문    JavaScript 반복문    JavaScript 함수    JavaScript 배열    JavaScript 객체(Object)    JavaScript 모듈    JavaScript UI와 API    JavaScript 정규표현식    JavaScript 함수지향 - 유효범위    JavaScript 함수지향 - 값으로서의 함수와 콜백    JavaScript 함수지향 - 클로저    JavaScript 함수지향 - arguments    함수지향 - 함수의 호출    객체지향 - 객체지향 프로그래밍 소개    객체지향 - 생성자와 new    객체지향 - 전역객체    객체지향 - this    객체지향 - 상속    객체지향-표준 내장객체의 확장    JavaScript 객체지향-ObjectJavaScript UI와 API1. UI란?UI(User Interface)는 컴퓨터의 시스템과 사용자의 접점에 존재하며 중개자에 해당하는 것을 UI라고 한다. 사용자를 대면하는 접점을 하는 지점을 UI라고하고 물리적, 하드웨어적 UI가 있고 소프트웨어적 UI가 있다. 노트북이나 키보드에 있는 버튼이 하드웨어적 UI라 할수있고 브라우저의 각종 버튼이 소프트웨어적 UI라 할수 있겠다.2. API란?API란 Application Programming Interface의 약자로 프로그램이 동작하는 환경을 제어하기 위해서 환경에서 제공되는 조작 장치이다. 이 조작 장치는 프로그래밍 언어를 통해서 조작할 수 있다. 일반 사용자는 UI를 사용해 원하는 결과를 얻고 개발자는 API를 이용해 자신이 하고자하는 프로그래밍을 하게된다.Javascript의 APIJavascript의 API는 크게 Javascript 자체의 API와 Javascript가 동작하는 호스트 환경의 API로 구분된다. 현재 우리가 공부하는건 Javascript자체의 API이고 앞으로 나아가 더 공부를 하게되면 호스트 환경에서의 API도 공부해야한다.Javascript API 문서Javascript가 제공하는 기본적인 API를 볼수있는 사이트이다. 여기서 필요한 API를 찾아 사용하면 된다.  ECMAScript.  Javascript사전.  Javascript 레퍼런스 MDN.  jscript 레퍼런스.호스트 환경의 API 문서호스트 환경에서의 API를 볼수있는 사이트이다. 지금 우리는 기본적인 Javascript의 API를 공부하고 있어 당장은 필요하지 않지만 앞으로 심화과정에 들어가면 사용할 일이 있을것이다.  웹브라우저 API.  Node.js API.  Google Apps Script API.",
        "url": "/javascript-basic10"
    }
    ,
    
    "javascript-basic9": {
        "title": "Javascript - JavaScript 모듈",
            "author": "AhnSang0915",
            "category": "",
            "content": "Javascript    JavaScript 기본     JavaScript 숫자와 문자     JavaScript 변수, 비교    JavaScript 조건문    JavaScript 반복문    JavaScript 함수    JavaScript 배열    JavaScript 객체(Object)    JavaScript 모듈    JavaScript UI와 API    JavaScript 정규표현식    JavaScript 함수지향 - 유효범위    JavaScript 함수지향 - 값으로서의 함수와 콜백    JavaScript 함수지향 - 클로저    JavaScript 함수지향 - arguments    함수지향 - 함수의 호출    객체지향 - 객체지향 프로그래밍 소개    객체지향 - 생성자와 new    객체지향 - 전역객체    객체지향 - this    객체지향 - 상속    객체지향-표준 내장객체의 확장    JavaScript 객체지향-ObjectJavaScript 모듈1. 모듈이란?프로그램은 작고 단순한 것에서 크고 복잡한 것으로 진화한다. 이과정에 필요한 것은 코드의 재활용성, 유지보수의 편의성등이 있다. 어떤 프로그램을 구성하고 있는 수만은 로직들을 재사용 할 수 있는 단위로 조각조각 나누어 구획화를 시켜 별도의 모듈이라는 형태로 떼어내 이것을 또다른 프로그램의 부품으로 사용하는 기법, 그런 부품들을 모듈이라 하고 이러한 기법을 모듈화 라고 한다. 아래는 모듈화를 통해 얻을 수 있는 효과이다.  자주 사용되는 코드를 별도의 파일로 만들어서 필요할 때마다 재활용할 수 있다.  코드를 개선하면 이를 사용하고 있는 모든 애플리케이션의 동작이 개선된다.  코드 수정 시에 필요한 로직을 빠르게 찾을 수 있다.  필요한 로직만을 로드해서 메모리의 낭비를 줄일 수 있다.  한번 다운로드된 모듈은 웹브라우저에 의해서 저장되기 때문에 동일한 로직을 로드 할 때 시간과 네트워크 트래픽을 절약 할 수 있다. (브라우저에서만 해당)Javascript에서는 모듈이라는 개념이 분명하게 존재하지 않는다. Javascript에서는 모듈이라는 기능 자체를 제공하지 않는다. 구동 환경(호스트 환경)에 따라서 Javascript로직 구성을 모듈형식으로 구성해 사용한다.2.모듈화모듈화를 알기 전에 모듈이 없다는 가정을 해보자. 그리고 funcion함수가 엄청 복잡하다고 가정하고, 함수 호출도 여러번하며 html파일이 아래 welcome이라는 함수를 여러 html에서 호출한다고 생각해보자. 그렇다면 welcome이라는 함수를 해당 페이지에 두는것은 덩치가 엄청 커질것이다. 이런경우 내가 필요한 코드와 그렇지 않은 코드를 분류하는게 힘들어 질 것이다. welcome이라는 함수를 별도의 파일로 빼고 그 별도의 파일을 읽어 오는것을 통해 welcome이라는 함수를 사용할 수 있다면 복잡한 코드가 한줄로 바뀔 수 있다.&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;    &lt;meta charset=\"utf-8\"/&gt;&lt;/head&gt;&lt;body&gt;    &lt;script&gt;        function welcome(){            return 'Hello world'        }        alert(welcome());    &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;아래 예제에서 별도의 파일로 js를 불러오는 형식을 알아보자. 아래 내용을 코드를 에디터를 활용해 실행해보자. greeting.js 라는 파일에 위 예제에서 사용한 function함수를 저장하고 불러오는 형식이다.&lt;script type=”text/javascript” src=”greeting.js”&gt;&lt;/script&gt; 그다음 welcom함수를 호출하면 greeting.js파일에서 불러오게 된다. 다른 html파일에서도 마찬가지로 위 코드로 불러와 함수를 사용할 수 있다.&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;    &lt;meta charset=\"utf-8\"/&gt;    &lt;script type=\"text/javascript\" src=\"greeting.js\"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;    &lt;script&gt;        alert(welcome());    &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;3.node.js의 모듈화모듈을 로드하는 방법은 호스트 환경에 따라서 달라진다. Node.js에서는 아래와 같은 방법으로 모듈을 로드한다.var PI = Math.PI;  exports.area = function (r) {return PI * r * r;};  exports.circumference = function (r) {return 2 * PI * r;};var circle = require('./node.circle.js');console.log( 'The area of a circle of radius 4 is '           + circle.area(4));4.라이브러리라이브러리는 자주 사용되는 로직을 재사용되기 편리하도록 잘 정리한 일련의 코드들의 집힘을 의미한다고 할 수 있다. 오픈 소스를 통해 만들어진 수많은 라이브러리가 있기 때문에 우리가 만들고자 하는 프로그래밍의 핵심적인 부분이 아니라면 공개되어있는 좋은 라이브러리를 선택하고 잘 사용하는 것은 프로그래밍의 핵심이라고 할 수 있다. Javascript로 웹 브라우저를 제어하는 방법은 기본적으로 웹 브라우저가 제공하는 기능, Javascript가 제공하는 기능을 이용해 모든 것을 다 할 수 있다. 다르게 말하면 웹 브라우저와 Javascript가 제공하지 않는 기능은 전혀 사용할 수 없다. 왜냐하면, 브라우저가 허용하는 기능만을 쓸 수 있기 때문이다. 브라우저의 기능이 너무 다양하고 파편화되어 있기 때문에 라이브러리를 사용한다. 라이브러리는 어떤 목적을 정해놓고 목적을 쉽게 달성할 수 있게 만들어놓은 프로그래밍의 집합이기 때문이다. 우리가 사용해볼 라이브러리는 query다.5. 라이브러리 사용하기jQuery를 이용한 예제와 사용방법을 알아볼 것이다. 하지만 jQuery에 대한 공부를 하는것 보다 어떻게 사용하는지에 대한 예제 이기 때문에 jQuery강의를 보고 공부를 해야한다. 아래 코드list에있는 empty를 한번에 coding paratice gym으로 바꾸는 예제이다. 아래의 상태에서&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt;    &lt;meta charset=\"UTF-8\"&gt;    &lt;meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\"&gt;    &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt;    &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt;    &lt;ul id=\"list\"&gt;        &lt;li&gt;empty&lt;/li&gt;        &lt;li&gt;empty&lt;/li&gt;        &lt;li&gt;empty&lt;/li&gt;        &lt;li&gt;empty&lt;/li&gt;    &lt;/ul&gt;&lt;/body&gt;&lt;/html&gt;아래 예제 처럼 변경해준다. 아래 jQuery를 사용한 3줄의 코드로 작업을 수행하게 되었다.&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt;    &lt;meta charset=\"UTF-8\"&gt;    &lt;meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\"&gt;    &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt;    &lt;title&gt;Document&lt;/title&gt;    &lt;script type=\"text/javascript\" src=\"./jquery.js\" &gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;    &lt;ul id=\"list\"&gt;        &lt;li&gt;empty&lt;/li&gt;        &lt;li&gt;empty&lt;/li&gt;        &lt;li&gt;empty&lt;/li&gt;        &lt;li&gt;empty&lt;/li&gt;    &lt;/ul&gt;    &lt;input type=\"button\" value=\"execute\" id=\"execute_btn\"/&gt;    &lt;script type=\"text/javascript\"&gt;        $('#execute_btn').click(function(){            $('#list li').text('coding practice gym');        });    &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;하지만 jQuery를 사용하지 않으면 아래 예제처럼 쉽지않은 프로그래밍을 해야한다.&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;body&gt;    &lt;ul id=\"list\"&gt;        &lt;li&gt;empty&lt;/li&gt;        &lt;li&gt;empty&lt;/li&gt;        &lt;li&gt;empty&lt;/li&gt;        &lt;li&gt;empty&lt;/li&gt;    &lt;/ul&gt;    &lt;input id=\"execute_btn\" type=\"button\" value=\"execute\" /&gt;    &lt;script type=\"text/javascript\"&gt;    function addEvent(target, eventType,eventHandler, useCapture) {        if (target.addEventListener) { // W3C DOM            target.addEventListener(eventType,eventHandler,useCapture?useCapture:false);        } else if (target.attachEvent) {  // IE DOM            var r = target.attachEvent(\"on\"+eventType, eventHandler);        }    }    function clickHandler(event) {        var nav = document.getElementById('list');        for(var i = 0; i &lt; nav.childNodes.length; i++) {            var child = nav.childNodes[i];            if(child.nodeType==3)                continue;            child.innerText = 'Coding everybody';        }    }    addEvent(document.getElementById('execute_btn'), 'click', clickHandler);    &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;이번 강의에선 라이브러리가 중요하다는 것을 알아야 한다. 세세하게 어떻게 하는지 알려고 하는 것보단 라이브러리의 장점과 편의성에 초점을 맞추고 이후 나오는 내용에서 자세히 알아볼 시간이 있을 것이다.",
        "url": "/javascript-basic9"
    }
    ,
    
    "javascript-basic8": {
        "title": "Javascript - JavaScript 객체(Object)",
            "author": "AhnSang0915",
            "category": "",
            "content": "Javascript    JavaScript 기본     JavaScript 숫자와 문자     JavaScript 변수, 비교    JavaScript 조건문    JavaScript 반복문    JavaScript 함수    JavaScript 배열    JavaScript 객체(Object)    JavaScript 모듈    JavaScript UI와 API    JavaScript 정규표현식    JavaScript 함수지향 - 유효범위    JavaScript 함수지향 - 값으로서의 함수와 콜백    JavaScript 함수지향 - 클로저    JavaScript 함수지향 - arguments    함수지향 - 함수의 호출    객체지향 - 객체지향 프로그래밍 소개    객체지향 - 생성자와 new    객체지향 - 전역객체    객체지향 - this    객체지향 - 상속    객체지향-표준 내장객체의 확장    JavaScript 객체지향-ObjectJavaScript 객체(Object)1. 객체의 소개와 문법배열은 연관되어 있는 데이터들을 담아내기 위한 그릇이다. 마찬가지로 객체도 연관된 데이터를 담아내는 것에 있어서 유사하다. 하지만 똑같은 그릇이 있다고 쳤을 때 객체도 그릇에 담아내는 것은 같지만 index의 값으로 숫자나 문자를 쓸 수도 있고, 인덱스로 우리가 원하는 데이터를 지정할 수 있다는 것이 둘의 차이점이라고 할 수 있다. 다른 언어에서는 연관배열(associative array) 또는 맵(map), 딕셔너리(Dictionary)라는 데이터 타입이 객체에 해당한다.객체의 생성객체를 만드는 법을 알아보자. 배열은 대괄호로 시작해 대괄호로 끝나지만,객체는 중괄호로 시작해 중괄호로 끝나게 된다. 아래는 데이터값으로 숫자를 썻지만 문자나 다른 데이터를 할당하는 것도 가능하다. 아래 예제에서 ansang은 key(index)가 되고 10은 value(데이터 값)가 된다.var grades = {'ansang': 10, 'sanghyun': 6, 'ansanghyun': 80};            // key : value  key : value  key : value 위의 상태에서 객체를 대표하는 변수를 grades로 지정하고 grades를 호출하면 아래와 같은 값이 나오게 된다.gradesodject {ansang: 10, sanghyun: 6, ansanghyun: 80}아래는 객체를 만드는 다른 방법이다.var grades = {};grades['ansang'] = 10; //key는 ansang value는 10grades['sanghyun'] = 6; //key는 sanghyun value는 6grades['ansanghyun'] = 80; //key는 ansanghyun value는 80위에서 객체를 호출하는 방법은 아래와 같다. 아무래도 garade.ansang가 간편하지만, 프로그래밍 적인 기재가 불가능하다 이 경우 garade.’an’+’sang’로 호출하게 되면 SyntaxError가 나오게 된다. 즉 . 뒤의 내용을 프로그래밍 적으로 만들 수 없다. []안에 들어가는 값은 프로그래밍 적으로 생성이 가능하기 때문에 필요에 따라 대괄호 안에 작성하는 게 편리하거나 써야만 하는 상황이 있을 수 있다.grades['ansang'] //value 10garade.ansang //value 10grades['an'+'sang'] //value 102.객체와 반복문 for in객체에 저장된 데이터를 기준으로 반복하는 작업을 알아보자. 배열은 저장된 데이터들이 순서를 가지고 있다. 그래서 배열에선 순서 자체가 중요한 정보이다. 하지만 객체엔 순서가 없고, key와 value로 이루어져 있기 때문에 저장된 순서는 없기 때문에 저장된 값이 순서에 따라서 나오지 않을 것 이라는 걸 인지해야 한다.var grades = {'ansang' : 10, 'sanghyun' : 6, 'ansanghynu' : 80}for(key in grandes) {    document.write(\"key : \"+key+\" value : \" + grades[key] + \"&lt;br /&gt;\");}/*출력key : ansang value : 10key : snaghyun value : 6key : ansanghyun value : 80*/또는 key부분을 변수로 바꿔도 된다. 아래는 var name으로 바꿔보았다.var grades = {'ansang' : 10, 'sanghyun' : 6, 'ansanghynu' : 80}for(var name in grandes) {    document.write(\"key : \"+name+\" value : \" + grades[name] + \"&lt;br /&gt;\");}/*출력key : ansang value : 10key : snaghyun value : 6key : ansanghyun value : 80*/더 보기 편하게 리스트 형태로 만들어보자. html에서의 ul태그와 li태그를 사용해본다.  &lt;ul&gt;    &lt;script type=\"text/javascript\"&gt;        var grades = {'ansang': 10, 'sanghyun': 6, 'ansanghynu': 80};            for(var name in grades) {            document.write(\"&lt;li&gt;key : \"+name+\" value : \"+grades[name]+\"&lt;/li&gt;\");            }        &lt;/script&gt;  &lt;/ul&gt;        /* 출력        -key : ansang value : 10        -key : snaghyun value : 6        -key : ansanghyun value : 80        */배열도 for in문으로 사용할수 있다. 배열에선 var name으로 지정한 값이 index가 됨으로 console.log(name)에서 012라는 index가 추출되고 console.log(arr[name])에선 abc라는 데이터가 출력된다.var arr = ['a', 'b', 'c']for(var name in arr) {    console.log(name);}//출력 //0//1//2for(var name in arr) {    console.olg(arr[name]);}3. 객체 지향 프로그래밍객체 지향 프로그래밍이란 서로 연관되어있는 데이터와 처리형식을 하나의 그릇안에 그룹핑 해놓은 프로그래밍을 객체 지향 프로그래밍 이라한다.객체에 담길 수 있는 값이 무엇지에 대해 알아보자. 아래 예제는 객체 안에 객체와 함수를 담았다. list라는 key 값에 {‘ansang’ : 10, ‘sanghyun’ : 8, ‘ansanghyun’ : 80}라는 value를 넣었고 이 value는 객체이다. show라는 key값에 function(){ alert(‘Hello World’)}; 라는 value를 담았다. javascript에서는 함수도 일종의 값이고 함수도 변수에 저장될 수 있기 때문에 마찬가지로 값으로서의 함수도 객체 안에 저장될 수 있다(고하는데 아직 뭔 소린지 모르겠음).grades에 담긴var grades = {    'list' : {'ansang' : 10, 'sanghyun' : 8, 'ansanghyun' : 80},    'show' : function(){        alert('Hello World');    }}alert(grades['list']['ansang']); //ansang이라는 key가 갖고있는 10이라는 value에 접근alert(grades['show']); // 함수에 접근this라는 키워드를 알아보자. this라는 것은 javascript에서 약속되어있는 변수이다. this 변수는 함수가 속해있는 객체를 가르치는 변수이다. 함수가 소속되어있는 객체를 가르친다는 말이다.아래 예제는 grades라는 객체가 갖고있는 key 값 중 show를 호출해 show 함수가 가진 this변수로 list객체{‘ansang’ : 10, ‘sanghyun’ : 8, ‘ansanghyun’ : 80}를 출력하게 된다.var grades = {    'list' : {'ansang' : 10, 'sanghyun' : 8, 'ansanghyun' : 80},    'show' : function(){        alert(this.list);    }}grades['show']();이번엔 개발자 도구에서 console.log(name, this.list[name]);를 사용해 key와 value를 호출해보자. value를 호출하는 방법은 위에서 배웠듯,  grades[‘ansang’] , garade.ansang 두가지가 있다. for in 문을 사용했기 때문에 list[name]을 사용하면 value 값을 불러올 수 있다.var grades = {    'list' : {'ansang' : 10, 'sanghyun' : 8, 'ansanghyun' : 80},    'show' : function(){        for(var name in this.list){            console.log(name, this.list[name]); // ,를 쓰게되면 여러 값을 출력할 수 있다.        }    }}grades.show();",
        "url": "/javascript-basic8"
    }
    ,
    
    "javascript-basic7": {
        "title": "Javascript - JavaScript 배열",
            "author": "AhnSang0915",
            "category": "",
            "content": "Javascript    JavaScript 기본     JavaScript 숫자와 문자     JavaScript 변수, 비교    JavaScript 조건문    JavaScript 반복문    JavaScript 함수    JavaScript 배열    JavaScript 객체(Object)    JavaScript 모듈    JavaScript UI와 API    JavaScript 정규표현식    JavaScript 함수지향 - 유효범위    JavaScript 함수지향 - 값으로서의 함수와 콜백    JavaScript 함수지향 - 클로저    JavaScript 함수지향 - arguments    함수지향 - 함수의 호출    객체지향 - 객체지향 프로그래밍 소개    객체지향 - 생성자와 new    객체지향 - 전역객체    객체지향 - this    객체지향 - 상속    객체지향-표준 내장객체의 확장    JavaScript 객체지향-ObjectJavaScript 배열1. 배열의 문법배열배열(array)이란 연관된 데이터를 모아서 통으로 관리하기 위해 사용하는 데이터의 형식이다. 변수는 하나의 데이터를 저장하기 위한 것이라면 배열은 여러 개의 데이터를 하나의 변수에 저장하기 위해 사용한다. 아래 코드는 name이라는 변수에 ‘Ahnsang’이라는 데이터를 할당한 것이다.var name = 'Ahnsang'alert(name);배열의 생성위에선 변수에 하나의 데이터를 할당 했다. 이제 배열로 여러개의 데이터를 변수에 할당하는 방법을 공부해 보자.여러개의 데이터를 할당 하려면 변수명 = 뒤에 [] 대괄호를 사용해 여러개의 데이터를 작성할 수 있다.var member = ['Ahnsang', 'SangHyun', 'AhnSangHyun']이 각각의 데이터를 요소,또는 원소(Element)라고 부르고 이제 이 원소들을 호출할것이다. 요소는 순서대로 0,1,2의 고유한 값,식별자를 가지게 된다. 색인 이라고도 하고 index라고도한다.var member = ['Ahnsang', 'SangHyun', 'AhnSangHyun']alert(member[0]);alert(member[1]);alert(member[2]);코드를 실행하면 차례대로 ‘Ahnsang’, ‘SangHyun’, ‘AhnSangHyun’ 세개의 데이터를 차례로 경고창에 출력해준다.2. 배열의 효용성배열이 없다면 변수에 하나의 데이터만 할당할수 있기 때문에 불편할 것이다. 아래의 예제를 보자.함수는 여러개의 입력값을 받을 수 있지만, 하나의 출력만 할 수 있다.function get_member1(){    return 'Ahnsang';}document.write(get_member1()); function get_member2(){    return 'SangHyun';}document.write(get_member2());  function get_member3(){    return 'AhnSangHyun';}위 코드처럼 배열을 사용하지 않으면 각각의 회원정보를 반환하는 함수로 표한해야한다. 배열을 사용해 코드를 만들어 보자. return 안에 배열을 사용해 각각의 색인으로 원하는 정보를 호출할 수 있다.function get_members() {    return ['Ahnsang', 'SangHyun', 'AhnSangHyun']}var members = get_members();document.write(members[0]);document.write(members[1]);document.write(members[2]);3. 배열의 사용 - 배열과 반복문우리가 배열을 사용해 index값을 호출할때 그 값을 일일히 기억해서 호출한다는것은 불가능하다. 배열이 몇백 몇천개가 사용될수도 있기 때문이다. 그렇기 때문에 배열이란 결국 배열에 담겨있는 값을 하나하나 꺼내서 그꺼내진 값을 가공하는게 배열의 핵심적인 요소라고 할수있다.아래 예제에서 출력값을 대문자로 출력하려고 .toUpperCase();라는 javascript내장함수를 사용해 출력했다.‘AHNSANG’,’SANGHYUN’,’AHNSANGHYUN’을 출력하게 될것이다.function get_members() {    return ['Ahnsang', 'SangHyun', 'AhnSangHyun']}var members = get_members();document.write(members[0].toUpperCase()+\"&lt;br /&gt;\");document.write(members[1].toUpperCase()+\"&lt;br /&gt;\");document.write(members[2].toUpperCase()+\"&lt;br /&gt;\");위 예제 처럼 우리가 직접 손으로 배열을 호출을 하기엔 무리가 있다. 이때 사용할 수 있는 방법이 배열과 반복문을 결합하는 것이다. 그전에 한가지 예제를 더 보자. 아래 예제는 배열의 값이 몇개인지 나타내 주는 함수이다. 경고창 내용은 3을 출력하게 된다.var a = ['Ahnsang', 'SangHyun', 'AhnSangHyun']alert (a.length);이제 배열과 반복문을 결합한 예제를 보자. i란변수를 지정하고 시작은 0에서 1씩 증가해 2로 끝나게 된다. 이렇게 나온 0, 1, 2는 index 값으로 사용하고, members[index값]에 i의 값이 어가게 되어 차례로 출력할 수 있게 된다.’AHNSANG’,’SANGHYUN’,’AHNSANGHYUN’을 출력하게 될것이다.function get_members() {    return ['Ahnsang', 'SangHyun', 'AhnSangHyun']}var members = get_members();for(var i = 0; i &lt; 3; i++) {    document.write(members[i].toUpperCase()+\"&lt;br /&gt;\");}그런데 여기서 배열의 갯수가 늘어난다면 우리는 반복문의 조건을 수정해야한다. 이것도 함수를 사용해 더 편리하게 만들어 보면, 우리는 members라는 변수에 get_members라는 함수를 호출했다. 그 함수안에 return의 배열이 들어있기 때문에 members.length함수를 사용하면 배열안의 요소의 갯수를 호출해 사용할 수 있다.function get_members() {    return ['Ahnsang', 'SangHyun', 'AhnSangHyun']}var members = get_members();for(var i = 0; i &lt; members.length; i++) {    document.write(members[i].toUpperCase()+\"&lt;br /&gt;\");}4. 배열의 제어배열은 복수의 데이터를 효율적으로 관리, 전달하기 위한 목적으로 고안된 데이터 타입이다. 따라서 데이터의 추가/수정/삭제와 같은 일을 편리하게 할 수 있도록 돕는 다양한 기능을 가지고 있다. 몇가지 중요한 기능들만 살펴보자.배열의 조작 - 추가 push배열의 끝에 원소를 추가하는 방법을 알아보자. push는 인자로 전달된 값을 배열에 추가하는 javascript 내장함수 이다. 아래 코드를 실행하면 “f”가 추가된 배열이 출력된다.var li = ['a', 'b', 'c', 'd', 'e'];li.push('f');alert(li);아래의 함수와 위의 함수는 같다.function numbering() {    var i = 0;    while(1 &lt; 10) {        document.write(i);        i += i;    }}아래 함수는 이름을 정하지도 않고 변수도 붙이지 않았다. 함수를 정의하고 함수를 괄호로 묶었다. 그다음에 호출할때 사용하는 기호 ();로 호출하게 되면 정의와 호출을 하나의 문장으로 같이하는 함수로 익명함수라고 한다. 일회 성으로 호출할때 이런 함수를 사용한다.(function(){    i = 0;    while(i &lt; 10){        document.write(i);        i += 1;    }   }) ();배열의 추가 concatconcat(concatenate)은 복수의 원소를 배열에 추가하는 방법이다. 추가한 출력은 [‘a’, ‘b’, ‘c’, ‘d’, ‘e’,’f’, ‘g’] 가된다.var li = ['a', 'b', 'c', 'd', 'e'];li = li.concat(['f', 'g']);alert(li);배열의 추가 unshiftunshift는 배열의 시작점에 원소를 추가하는 방법이다. 출력은 [‘z’,’a’, ‘b’, ‘c’, ‘d’, ‘e’] 가되고 index도 0~5로 변경된다.var li = ['a', 'b', 'c', 'd', 'e'];li.unshift('z');alert(li);배열의 추가 splicesplice는 배열의 특정구간을 추출하거나, 특정구간에 특정 배열을 추가하는 방법이다. 문법은 아래와 같고,array.splice(index, howmany, element1, ...., elementN);아래 표를 보면서 이해해보자.            인자명      데이터형      필수/옵션      설명                  index      number      필수      배열에 추가할 특정 배열의 위치를 가르키는 index              howmany      number      필수      index에서부터 제거될 원소들의 수. index부터 index+howmany에 해당하는 원소들은 삭제된다. 이 값이 0이면 어떠한 원소도 삭제되지 않는다.              element1,…,elementN      number      옵션      index와 index+howmany 사이에 추가될 값      아래와 같이 splice를 이용해 배열에 ‘x’,’y’를 추가하는 코드가 있다. splice뒤에 오는 1은 [a,b,c] 배열에서 ‘b’를 가르키고 0은 ‘b’를 제거하지 않고 index 1번 위치에 ‘x’,’y’를 추가하겠다는 말이다.이러면 배열은 [‘a’,’x’,’y’,’b’,’c’] 가된다.var a = ['a','b','c']a.splice(1,0,['x','y'])이번엔 기존 배열을 삭제하고 추가하는 예제를 보자. index 1번자리에 있는 ‘b’의 자리에서 2개의 원소를 삭제하고 [‘x’,’y’]를 순서대로 넣어주겠다는 말이다. 변경된 배열은 [‘a’ , ‘x’, ‘y’]가 된다.var a = ['a','b','c']a.splice(1,2,['x','y'])몇가지 예제를 더보자.var numbers = [1,2,3,4,5,6,7,8,9,10];alert(numbers.splice(2)); //2번 index를 포함 이후의 모든 요소를 제거한다.alert(numbers); // [1,2] var numbers = [1,2,3,4,5,6,7,8,9,10];alert(numbers.splice(2, 4)); // array, [3,4,5,6] var numbers = [1,2,3,4,5,6,7,8,9,10];alert(numbers.splice(2, 4, 'three', 'four', 'five', 'six')); // array, [3,4,5,6]alert(numbers); // array, [1,2,three,four,five,six,7,8,9,10]5. 배열의 조작 - 제거, 정렬제거 shiftshift는 배열의 첫번째 원소를 제거하는 방법이다. index 0번에 위치한 원소를 제거하고 나머지 값들을 한칸씩 앞으로 당겨온다. 만약 배열의 length가 0이면 undefined을 리턴한다. 아래 예제의 결과는 b, c, d, e다.var li = ['a', 'b', 'c', 'd', 'e'];li.shift();alert(li);제거 poppop은 배열의 마지막 원소를 제거하는 방법이다. 마지막 index에 위치한 원소를 제거하고 마찬가지로 빈 배열이라면 undefined을 리턴한다.var li = ['a', 'b', 'c', 'd', 'e'];li.pop();alert(li);정렬 sort배열을 이용하는 중요한 이유중 하나가 정렬이다. sort는 배열의 정렬을 하고싶을때 사용한다.var li = ['c', 'e', 'a', 'b', 'd'];li.sort();alert(li);하지만 만약 배열이 [‘1’, ‘10’, ‘6’] 인경우엔 정렬이 1, 10, 6이 된다. 데이터를 문자로 보기때문에 앞에 1이 온 10을더 작다고 보는것이다. 이것을 올바르게 정렬하려면 아래와 같은 예제를 사용한다.function sortNumber(a,b){    return a-b; //역순을 구한다면 b-a를 활용한다.}var numbers = [20, 10, 9,8,7,6,5,4,3,2,1];alert(numbers.sort(sortNumber)); // array, [1,2,3,4,5,6,7,8,9,10,20]위 함수 a-b; 부분을 이해하려 찾아보았다. 정확하게 javascript에서 어떤 알고리즘으로 작동하는지 모르지만 이런 식으로 작동할 것이라는 글을 보게 되었다.만약 5,4,6,1,3,2 라는 배열이 있다고 가정하자.a-b에서 양수면 위치를 바꾸고 음수면 유지한다.5-4는 양수로 위치를바꾼다.4,5,6,1,3,24-6은 음수로 유지.4,5,6,1,3,24-1은 양수로 변경.1,5,6,4,3,21-3,1-2도 음수로 자리를 유지하고 index0번위치에 1이 오게된다.이제 1,5,6,4,3,2에서 두번째 자리를 찾는다.5-6은 음수로 유지.1,5,6,4,3,25-4는 양수로 변경.1,4,6,5,3,24-3은 양수로 변경.1,3,6,5,4,23-2는 양수로 변경.1,2,6,5,4,3 두번째 자리를 찾았다.….…이런 식으로 반복해서 찾는다는 글을 봤는데 맞는진 모르겠지만 이렇게 이해하면 좋을 것 같다.정렬 reversereverse는 역순으로 정렬하고 싶을때 사용한다.var li = ['c', 'e', 'a', 'b', 'd'];li.reverse();alert(li);",
        "url": "/javascript-basic7"
    }
    ,
    
    "javascript-basic6": {
        "title": "Javascript - JavaScript 함수",
            "author": "AhnSang0915",
            "category": "",
            "content": "Javascript    JavaScript 기본     JavaScript 숫자와 문자     JavaScript 변수, 비교    JavaScript 조건문    JavaScript 반복문    JavaScript 함수    JavaScript 배열    JavaScript 객체(Object)    JavaScript 모듈    JavaScript UI와 API    JavaScript 정규표현식    JavaScript 함수지향 - 유효범위    JavaScript 함수지향 - 값으로서의 함수와 콜백    JavaScript 함수지향 - 클로저    JavaScript 함수지향 - arguments    함수지향 - 함수의 호출    객체지향 - 객체지향 프로그래밍 소개    객체지향 - 생성자와 new    객체지향 - 전역객체    객체지향 - this    객체지향 - 상속    객체지향-표준 내장객체의 확장    JavaScript 객체지향-ObjectJavaScript 함수1. 함수란?함수(function)란 javascript에서 기본적인 구성 블록중 하나로, 작업을 수행하거나 값을 계산하는 문장 집합같은 절차이다. 함수는 하나의 로직을 재실행 할 수 있도록 하는것으로 코드의 재사용성을 높여준다.함수의 형식함수(function)의 형식은 아래와같다.function 함수명( [인자...[,인자]] ){   코드 내용   return 반환값}함수의 정의와 호출함수(function) 뒤에 함수의 이름이 오고, 소괄호가 따라온다. 우리가 변수를 호출하려면 변수를 정의하고 값을할당한후 그 변수를 호출해야한다. 함수도 마찬가지로 함수를 정의했으면 정의한 함수를 호출해야한다. 변수는 변수 이름만으로 호출하지만 함수는 함수명 뒤 (); 를 붙여줘야한다. ();를 붙이지 않으면 javascript는 변수로 인식하기 때문에 꼭 써줘야한다.function numbering() {    document.write(1);}numbering();다음 예제를 보자. 이 함수의 이름은 numbering이고, 내용은 0부터 9까지를 화면에 출력한다.function numbering(){    i = 0;    while(i &lt; 10){        document.write(i);        i += 1; // i = i + 1; 과 같다    }   }numbering();2. 함수의 효용성만약 함수가 없이 0~9까지의 코드를 출력하려고 하려고 하면 아래와 같이 하면 될것이다.var i = 0while(i &lt; 10&gt;){    document.write(i);    i +=1;}var i = 0while(i &lt; 10&gt;){    document.write(i);    i +=1;}var i = 0while(i &lt; 10&gt;){    document.write(i);    i +=1;}var i = 0while(i &lt; 10&gt;){    document.write(i);    i +=1;}var i = 0while(i &lt; 10&gt;){    document.write(i);    i +=1;}그런데 위의 코드를 0에서19까지로 바꿔야한다면 while(i &lt; 10&gt;) 부분을 while(i &lt; 20&gt;)으로 바꿔줘야 한다. 5번만 호출한다면 어렵지 않겠지만 많은 횟수를 호출하는 상황에선 어려운 작업이 될것이다. 이럴때 함수를 쓰면 1에서19까지를 1000번을 호출해도 아래와 같이 간단히 바꿀수 있다.funtion numbering() {    while(i &lt; 20&gt;){    document.write(i);    i +=1;}for(var i = 1; i &lt; 1000; i++){    numbering();}물론 함수를 사용하지 않고 for문과 while로도 호출이 가능하다.for(var i = 1; i &lt; 1000; i++){    var i = 0;    while(i &lt; 20&gt;){        document.write(i);        i +=1;    }}위의 두코드의 차이점은 반복문은 반복문 안에서만 실행이 되고 함수는 다른 여러곳에서도 호출하여 사용할 수 있다는 점이다. 핵심은 재사용성이고 이말은 이 함수를 사용하고 있는 여러곳 에서 이함수의 내용을 변경, 개선한다고 하면 함수만 변경하면 사용하는 여러곳 에서 변경이되기 때문에 유지보수가 용이하게 된다.3. 함수의 입력과 출력함수의 핵심은 입력과 출력이다. 입력된 값을 연산해서 출력하는 것이 함수의 기본적인 역할이다. 다음은 함수에서 입력과 출력의 역할을 하는 구문들에 대한 설명이다.함수의 출력return함수 내에서 사용한 return은 return 뒤에 따라오는 값을 함수의 결과로 반환한다. 동시에 함수를 종료시킨다. 아래 내용을 보자. 결과는 egoing과 k8805다.function get_member1(){    return 'egoing';} function get_member2(){    return 'k8805';} alert(get_member1());alert(get_member2());아래 함수를 실행시켜보면 ‘egoing’만 출력하고 함수가 종료된다. return뒤의 내용은 출력하지 않는다.function get_member(){    return 'egoing';    return 'k8805';    return 'sorialgi';}alert(get_member());인자인자(argument)는 함수로 유입되는 입력 값을 의미하는데, 어떤 값을 인자로 전달하느냐에 따라서 함수가 반환하는 값이나 메소드의 동작방법을 다르게 할 수 있다. 다음 예를보자.앞에서본 함수와는 다르게 함수명 뒤에 1과 2가 들어가있다. 이말은 get_argument라는 함수를 호출할때 숫자 1과2를 넣어준다는 말이 된다. 숫자가 들어가는 arg는 변수가된다. arg=1, arg=2라는 뜻이 되는것이다. return이지만 2번을 호출했기 떄문에 1000,2000 의 값이 출력 된다.function get_argument(arg){ //arg는 매개변수 또는 parameter라고 부른다.    return arg*1000;} alert(get_argument(1)); // 1과 2를 인자 argument라고 한다.alert(get_argument(2));복수의 인자인자를 여러개의 사용할수도 있다. 첫번째 두번째 인자가 차례로 arg1와 arg2로 들어가게 되고 30 , 50의 값이 출력 되게 된다.function get_arguments(arg1, arg2){    return arg1 + arg2} alert(get_arguments(10, 20));alert(get_arguments(20, 30));4. 다양한 함수 정의 방법함수를 정의하는 다른 방법을 알아보자.우리가 위에서 작성한 함수와는 조금 다르다. function내의 함수 내용이 numbering이라는 변수에 대입되어 변수가 함수를 가지게 된것이다.var numbering = function (){    i = 0;    while(i &lt; 10){        document.write(i);        i += 1;    }   }numbering();아래의 함수와 위의 함수는 같다.function numbering() {    var i = 0;    while(1 &lt; 10) {        document.write(i);        i += i;    }}아래 함수는 이름을 정하지도 않고 변수도 붙이지 않았다. 함수를 정의하고 함수를 괄호로 묶었다. 그다음에 호출할때 사용하는 기호 ();로 호출하게 되면 정의와 호출을 하나의 문장으로 같이하는 함수로 익명함수라고 한다. 일회 성으로 호출할때 이런 함수를 사용한다.(function(){    i = 0;    while(i &lt; 10){        document.write(i);        i += 1;    }   }) ();",
        "url": "/javascript-basic6"
    }
    ,
    
    "javascript-basic5": {
        "title": "Javascript - JavaScript 반복문",
            "author": "AhnSang0915",
            "category": "",
            "content": "Javascript    JavaScript 기본     JavaScript 숫자와 문자     JavaScript 변수, 비교    JavaScript 조건문    JavaScript 반복문    JavaScript 함수    JavaScript 배열    JavaScript 객체(Object)    JavaScript 모듈    JavaScript UI와 API    JavaScript 정규표현식    JavaScript 함수지향 - 유효범위    JavaScript 함수지향 - 값으로서의 함수와 콜백    JavaScript 함수지향 - 클로저    JavaScript 함수지향 - arguments    함수지향 - 함수의 호출    객체지향 - 객체지향 프로그래밍 소개    객체지향 - 생성자와 new    객체지향 - 전역객체    객체지향 - this    객체지향 - 상속    객체지향-표준 내장객체의 확장    JavaScript 객체지향-ObjectJavaScript 반복문1. 반복문 기본문법-while반복문(Loop iterate)은 사람이 하기힘든 반복 작업을 하기위해 사용하고, 몇가지 문법이 있다.whilewhile의 형식은 아래와같다. 조건이 true인 동안에 { } 안의 데이터를 반복하게 된다.while (조건){    반복해서 실행할 코드}2. 반복조건반복조건이 없다면 반복문이 무한대로 실행이되게된다. 반복조건을 설정해 적당한 시기에 반복이 정지하도록 해줘야한다.아래 예제는 i의 시작값을 0으로 정했고 한번씩 반복 할때마다 ‘coding everybody ‘문장이 실행되고 i가 1씩 늘어나게 된다. i의 값이 9가되면 반복을 멈추게 된다.var i = 0;while(i &lt; 10){    document.write('coding everybody &lt;br /&gt;');    i++}3. for문for문의 형식은 아래와 같다. while 과 for문은 둘다 반복문이고 대체가능하다.for(초기화; 반복조건; 반복이 될 때마다 실행되는 코드){    반복해서 실행될 코드}for(var i = 0; i &lt; 10; i++){   // i = i + 1 과 i ++는 같다.    document.write('coding everybody'+i+'&lt;br /&gt;');}i++는 해당 구문을 실행할때마다 i값을 1씩 증가시킨다는 말이다. i=0이라고 시작하면 0부터 시작하게 된다.++i는 해당 구문을 실행할때부터 1을 증가시킨채 실행한다. i=0이라고하면 시작부터 1로 시작한다.4. 반복문의 효용성반복문이 없다면 코드를 복사해서 붙여넣기 하면 된다. 하지만 반복 횟수가 많아지면 많아질수록 힘들어질 것이다. 아래 예제의 두 코드는 같은 내용이다. 어떤 작업이 더 편할까?document.write('coding everybody');document.write('coding everybody');document.write('coding everybody');document.write('coding everybody');document.write('coding everybody');document.write('coding everybody');document.write('coding everybody');document.write('coding everybody');document.write('coding everybody');document.write('coding everybody');document.write('coding everybody');var i = 0;while(i &lt; 10){    document.write('coding everybody &lt;br /&gt;');    i++;}그런데 ‘coding everybody’뒤에 순서를 써야하고 그 양이 많다면 불가능해 질것이다. 반복문으로 코드를 작성하면 간단하다.var i = 0;while(i &lt; 10) {    document.write('coding everybody' + i + &lt;br/&gt;);}5. 반복문의 제어반복문을 강제 정지시키거나 정지후 재시작 하기위한 명령어를 알아보자.breakbreak는 반복문을 중간에 중단시키게 해준다. 아래 예제는 0~4까지 출력하고 중단하게 된다.for(var i = 0; i &lt; 10; i++){    if(i === 5) {        break;    }    document.write('coding everybody'+i+'&lt;br /&gt;');}continuecontinue는 지정된 부분에선 반복을 중단하고 반복을 재시작할 수 있게 해준다. 아래의 코드를 실행해보자.for(var i = 0; i &lt; 10; i++){    if(i === 5) {        continue;    }    document.write('coding everybody'+i+'&lt;br /&gt;');}i===5에서 continue를 하겠다고 했기때문에 i의 값이 5가되었을 때는 실행을 중단하고 다음 i값부터 다시 반복하게 된다.coding everybody 0coding everybody 1coding everybody 2coding everybody 3coding everybody 4coding everybody 6coding everybody 7coding everybody 8coding everybody 96. 반복문의 중첩사용과 디버거반복문안에 반복문을 중첩해 사용할수 있다. 아래 예제에선 i와j를 0~9까지 반복하고 그i와j는 숫자이고 숫자끼리 더해지게 되는데 아래 처럼 문자열과 숫자의 결합하는 경우 javascript는 숫자인 부분을 문자로 변환해 준다.for(var i = 0; i &lt; 10; i++){    for(var j = 0; j &lt; 10; j++ ) {    document.write('coding everybody' + i + j + '&lt;br /&gt;');    }}위코드를 실행해 보면 00~99까지의 i와j가 출력된다.디버거우리가 만든 코드의 버그를 확인하고 코드 실행 순서를 볼 수 있는 기능을 알아보자. F12키를 눌러 개발자도구를 열고 console로 들어가 보고자 하는 줄의 코드를 선택하고 F5를 눌러 새로고침한다.그리고 버튼을 활용해 실행 순서를 확인해 보자.",
        "url": "/javascript-basic5"
    }
    ,
    
    "javascript-basic4": {
        "title": "Javascript - JavaScript 조건문",
            "author": "AhnSang0915",
            "category": "",
            "content": "Javascript    JavaScript 기본     JavaScript 숫자와 문자     JavaScript 변수, 비교    JavaScript 조건문    JavaScript 반복문    JavaScript 함수    JavaScript 배열    JavaScript 객체(Object)    JavaScript 모듈    JavaScript UI와 API    JavaScript 정규표현식    JavaScript 함수지향 - 유효범위    JavaScript 함수지향 - 값으로서의 함수와 콜백    JavaScript 함수지향 - 클로저    JavaScript 함수지향 - arguments    함수지향 - 함수의 호출    객체지향 - 객체지향 프로그래밍 소개    객체지향 - 생성자와 new    객체지향 - 전역객체    객체지향 - this    객체지향 - 상속    객체지향-표준 내장객체의 확장    JavaScript 객체지향-ObjectJavaScript 조건문1. 조건문이란?조건문(Conditional statement)은 if로 시작한다.if뒤에는 반드시 true나 false로 두개의 값중에 하나가 온다. 그뒤 중괄호안에 조건이 들어오게 된다.아래의 예제는 true를 출력할것이다. if뒤가로에 true가 오게되면 중괄호 안의 내용이 실행된다.if(true){    alert('result : true');이번엔 아무것도 출력하지 않는다. if뒤에 false가오면 중괄호 안의 내용을 실행하지 않는다.if(false){    alert('result : true');12345를 출력 할것이다.if(true){    alert(1);    alert(2);    alert(3);    alert(4);}alert(5);5만 출력한다. false기 때문에 중괄호 안의 내용은 실행하지 않는다.if(false){    alert(1);    alert(2);    alert(3);    alert(4);}alert(5);2. else, else ifif만으로는 조건문을 사용하는데에 제약이 있다. else와 else if는 더 다양하게 조건문을 응용할 수 있게 해준다.elseif뒤 true가 있다면 중괄호 안의 내용이 실행이 되고, else는 실행이 되지 않는다. 만약에 참 이라면 if중괄호가 실행후 else는 무시하고 결과는 1이된다.if(true){    alert(1);} else {    alert(2);}if뒤에 false가 있다면 중괄호 안의 내용이 실행이 안되고, 만약에 거짓이라면 else가 실행이 된고 결과는 2다.if(false){    alert(1);} else {    alert(2);}else if아래 코드에 대한 해석을 해보자. 1번에서 if뒤의 false로 2번alert(1)이 실행되지 않고 다음으로 넘어간다. 3번코드 else에선 1번에서 if가 false기 때문에 실행이 되고 else뒤의 if가 true이기 때문에 2라는 값이 출력된다. 4번이 실행 되었기 때문에 5와 7의 else가 실행될수 없다. 그대로 2만 출력 할 것이다.if(false){       //1    alert(1);    //2} else if(true){ //3    alert(2);    //4} else if(true){ //5    alert(3);    //6} else {         //7    alert(4);    //8}아래 코드도 해석해보면 3이 출력된다는 걸 알 수 있다.if(false){    alert(1);} else if(false){    alert(2);} else if(true){    alert(3);} else {    alert(4);}아래 코드도 해석해보면 4가 출력된다는 걸 알 수 있다.if(false){    alert(1);} else if(false){    alert(2);} else if(false){    alert(3);} else {    alert(4);}3. 조건문의 응용변수와 비교연산자if(true) {    alert(1);}위와 같은 코드는 javascript에서 쓸일이 없다. 무조건 1이 출력이 되기 때문이다. 조건문과 변수가 만나 상황에 따라 가변적인 요소가 되어야 조건문이라 할수 있다. prompt라는 구문을 사용해야 하는데 prompt는 사용자가 입력한 값을 가져와서 변수의 값으로 대입해준다. 예제를 통해 더 알아보자.&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;    &lt;meta charset=\"utf-8\"/&gt;&lt;/head&gt;&lt;body&gt;    &lt;script&gt;        id = prompt('아이디를 입력해주세요.') //prompt를 통해 사용자가 입력한 값을 id라는 변수에 적용        if(id=='Ahnsang'){            alert('아이디가 일치 합니다.')        } else {            alert('아이디가 일치하지 않습니다.')        }    &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;위의 예제를 응용해 아이디와 비밀번호 모두 사용하게 해보자. 아이디가 일치하면 비밀번호를 물어볼 필요가 없다. id 변수에 입력한 값이 if id의 조건문에서 아이디가 일치한다면 if password에서 prompt를 통해 비밀번호를 요구한다. 그렇게 되면 입력한 비밀번호가 password라는 변수에 담겨서 입력 값과 111111라는 password와 일치하면 로그인 하셨습니다. 다르다면 비밀번호가 다릅니다라는 메세지가 나오게 된다.&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;    &lt;meta charset=\"utf-8\"/&gt;&lt;/head&gt;&lt;body&gt;    &lt;script&gt;        id = prompt('아이디를 입력해주세요.');        if(id=='Ahnsang'){            password = prompt('비밀번호를 입력해주세요.');            if(password==='111111'){                alert('로그인 했습니다.');            } else {                alert('비밀번호를 확인해 주세요.');            }        } else {            alert('아이디를 확인해 주세요.');        }    &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;4. 논리 연산자논리 연산자는 조건문을 더 간결하고 다양하게 사용할수 있다.&amp;&amp;&amp;&amp;는 좌항과 우항이 모두 참(true)일때 참이된다. 아래 예제에선 1이라는 값이 출력된다. 이러한 연산자를 and연산자라고 한다.if(true &amp;&amp; true){    alert(1);}if(true &amp;&amp; false){    alert(2);}if(false &amp;&amp; true){    alert(3);}if(false &amp;&amp; false){    alert(4);}아래 예제에선 논리연산자 중 and연산자를 활용한 것 이다. 두 변수를 동시에 호출하기 위해 id와 password를 prompt로 호출해주고 &amp;&amp; 연산자로 둘의 값이 모두 참일때만 ‘인증했습니다.’라는 메세지를 출력 하게되고 하나라도 다르다면 ‘인증에 실패 했습니다.’ 라는 값을 출력하게 된다. and연산자는 2개 이상도 사용할 수 있다.&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;    &lt;meta charset=\"utf-8\"/&gt;&lt;/head&gt;&lt;body&gt;    &lt;script&gt;        id = prompt('아이디를 입력해주세요.');        password = prompt('비밀번호를 입력해주세요.');        if(id=='Ahnsang' &amp;&amp; password=='111111'){            alert('인증 했습니다.');        } else {            alert('인증에 실패 했습니다.');        }    &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;||||는 ||의 좌우항 하나라도 참이라면 참이 되고 둘다 거짓일때 거짓이 되는 연산자 이다. 예제는 1, 2, 3이 출력되고 ||는 or연산자 라고 한다.if(true || true){    alert(1);}if(true || false){    alert(2);}if(false || true){    alert(3);}if(false || false){ //둘다 false기 때문에 false    alert(4);}아래 예제는 Ahnsang, Ahnsang1, Ahnsang2 값중 하나라도 변수값에 들어오면 ‘인증 했습니다.’라는 값을 출력하게 될것이다.id = prompt('아이디를 입력해주세요.');if(id==='Ahnsang' || id==='Ahsang1' || id==='Ahnsang2'){    alert('인증 했습니다.');} else {    alert('인증에 실패 했습니다.');}다음예제는 or와 and를 사용하는 방법이다.id 비교를 할 때 괄호를 사용한 것은 사칙 연산을 할 때 괄호부터 계산하는 것과 같은 원리다. 세개의 id중 하나라도 맞고 password가 111111이면 로그인 했습니다 라는 값이 출력된다.id = prompt('아이디를 입력해 주세요')password = prompt('비밀번호를 입력해 주세요.')if(id === 'Ahnsang' || id === 'Ahnsang1' || id === 'Ahnsang2' &amp;&amp; password = '111111') {    alert('로그인 했습니다.')}   else {    alert('로그인 실패 했습니다.')}!!는 부정의 의미로 true나 false 앞에 !를 붙이면 값을 역전시킨다. not 연산자 라고 부른다. 아래 에제에서 !를 사용하면 어떻게 되는지 확인하자. 값은 4이다.if(!true &amp;&amp; !true){ //false false 이기 때문에 &amp;&amp;연산자 에선 실행되지 않는다.    alert(1);}if(!false &amp;&amp; !true){ //true false &amp;&amp;는 둘다 참이어야 실행한다.    alert(2);}if(!true &amp;&amp; !false){ //true false &amp;&amp;는 둘다 참이어야 실행한다.    alert(3);}if(!false &amp;&amp; !false){ //true true기 때문에 실행한다.    alert(4);}5.boolean의 대체제0과 1조건문에 사용될 수 있는 데이터 형이 꼭 불린만 되는 것은 아니다. 관습적인 이유로 0는 false 0이 아닌 값은 true로 간주된다. 아래의 예제는 2를 출력한다.if(0){    alert(1)}if(1){    alert(2)}그외의 false로 간주되는 데이터if(!''){    alert('빈 문자열')}if(!undefined){    alert('undefined');}var a;if(!a){    alert('값이 할당되지 않은 변수'); }if(!null){    alert('null');}if(!NaN){    alert('NaN');}",
        "url": "/javascript-basic4"
    }
    ,
    
    "javascript-basic3": {
        "title": "Javascript - JavaScript 변수, 비교",
            "author": "AhnSang0915",
            "category": "",
            "content": "Javascript    JavaScript 기본     JavaScript 숫자와 문자     JavaScript 변수, 비교    JavaScript 조건문    JavaScript 반복문    JavaScript 함수    JavaScript 배열    JavaScript 객체(Object)    JavaScript 모듈    JavaScript UI와 API    JavaScript 정규표현식    JavaScript 함수지향 - 유효범위    JavaScript 함수지향 - 값으로서의 함수와 콜백    JavaScript 함수지향 - 클로저    JavaScript 함수지향 - arguments    함수지향 - 함수의 호출    객체지향 - 객체지향 프로그래밍 소개    객체지향 - 생성자와 new    객체지향 - 전역객체    객체지향 - this    객체지향 - 상속    객체지향-표준 내장객체의 확장    JavaScript 객체지향-ObjectJavaScript 변수, 비교변수1. 변수의 사용법변수(Variable)는 문자나 숫자같은 값을 담는 컨테이너로 값을 유지할 필요가 있을때 사용한다. 담겨진 값은 다른 값으로 바꿀수 있고 var로 변수를 선언할수 있다. 생략도 가능하지만 var의 의미를 명확하게 이해하기 전에는 var를 사용하는 것이 좋겠다. 예제를 보자.var a = 1;alert(a+1);  //2 var a = 2;alert(a+1);  //3var first = \"coding\";alert(first+\" everybody\"); //coding everyday//변수 a에 coding ,변수 b에 everybody를 활당하는 방법은 아래와 같다.var a = 'coding', b = 'everybody';alert(a);alert(b);2. 변수의 효용변수는 코드의 재활용성을 높여준다. 반복해서 100에서 10을 빼고 더하고 나누는 계산을 해야하는 코드가 있다고 가정해보고 변수가 없다면 100에관한 숫자 데이터를 모두 수정해야 할것이다. 여기서 변수를 적용하면 변수 값만 바꿔주면 된다.//변수를 쓰기 전alert(100+10);alert((100+10)/10);alert(((100+10)/10)-10);alert((((100+10)/10)-10)*10);// 변수 사용 후a = 100; //변할수 있는a = a + 10; //변하지 않는alert(a);a = a / 10;alert(a);a = a - 10;alert(a);a = a * 10;      alert(a);변수를 쓰지 않은 코드보다 쓴 코드가 더 길기때문에 비효율 적으로 보일수 있으나 코드가 천줄 만줄이라고 생각하면 변수를 쓰는게 좋을것이다.코딩을 할때 위의 주석처럼 구획을 나누어 놓는게 좋다. 변할수 있는 부분이 군데군데 들어가 있다면 그것을 찾아서 수정해야한다. 그럴경우 유지보수가 힘들어진다.비교1.연산자비교는 조건문을 쓸때 꼭 필요하다. 비교 기능 자체는 효용이 크지 않지만 조건문을 사용하기 위해 꼭 필요하다.연산자란 간단하게 말해 = 이다. 변수에 값을 대입할때 사용한다.a=1 //변수 대입연산자 값2. 비교 연산자 (==과===)비교 연산자는 말그대로 비교하고 판별할때 사용한다. 좌항과 우항중 뭐가 작고 큰지 또는 같은지 등을 판별한다. 비교연산자의 결과는 true나 false둘중 하나다. true와 false형식을 블린 데이터라고 부르고 역시 조건문에서 중요하게 사용한다.== ==는 동등연산자로 좌항과 우항의 값이 같다면 true 다르다면 false가 된다.=와 ==는 전혀 다르기 때문에 주의해야한다.alert(A==B)             //falsealert(A==A)             //truealert(\"one\"==\"two\")     //false alert(\"one\"==\"one\")     //true=== === 일치 연산자라고 하고 좌항과 우항이 정확하게 같을때 같다면 true 다르다면 false가 된다. 여기서 정확하게는 아래 코드처럼 형식까지 일치해야 한다는 말이다. 1과 ‘1’은 숫자와 숫자를 문자화시킨 데이터이다. 결론은 ==보다 ===를 쓰는것이 좋겠다.alert(1=='1');              //truealert(1==='1');             //false3.===를 사용하자null과 undefined는 값이 없다는 의미의 데이터 형이다. var a; 라는 코드를 쓰고 alert(a); 를 하면 undefined라는 경고창이 나온다. 값이 정의되지 않았다는 뜻이다. 그리고 var a=null; alert(a);를 하면null이라는 경고창이 나온다. 이말은 작성한사람이 의도적으로 값이 없다는것을 지정한것이다.이말은 프로그래밍에서 의도한것과 의도하지 않은것은 전혀 다른것이다.alert(null == undefined);       //truealert(null === undefined);      //falsealert(true == 1);               //truealert(true === 1);              //falsealert(true == '1');             //truealert(true === '1');            //false alert(0 === -0);                //truealert(NaN === NaN);             //false NaN(Not-a-Number)은 이값은 숫자가 아님을 의미한다.                   //그래서 NaN생성의 가능성이 있는 코드는 비교 연산을 실행하면 안되겠다.4.부정과 부등호!=!는 부정을 의미한다. 1==2는 false다 하지만 1!=2는 true가 된다. 같지 않은게 사실이기 때문이다.alert(1!=2);            //truealert(1!=1);            //falsealert(\"one\"!=\"two\");    //truealert(\"one\"!=\"one\");    //false!==!==는 ===에 부정을 부여한 것으로 정확하게 같지 않다는 의미이다.&gt;좌항과 우항을 비교해주는 연산자로 좌항이 더 크다는것을 의미한다. 더크면 true 작으면 false이다.&lt;는 반대의 의미이다.alert(10&gt;20);   //falsealert(10&gt;1);    //truealert(10&gt;10);   //false&gt;=좌항이 우항보다 크거나 같다는 의미이다. &lt;=는 반대의 의미이고 =&gt;, =&lt;식의 표현은 불가하다.alert(10&gt;=20);      //falsealert(10&gt;=1);       //truealert(10&gt;=10);      //true",
        "url": "/javascript-basic3"
    }
    ,
    
    "javascript-basic2": {
        "title": "Javascript - JavaScript 숫자와 문자",
            "author": "AhnSang0915",
            "category": "",
            "content": "Javascript    JavaScript 기본     JavaScript 숫자와 문자     JavaScript 변수, 비교    JavaScript 조건문    JavaScript 반복문    JavaScript 함수    JavaScript 배열    JavaScript 객체(Object)    JavaScript 모듈    JavaScript UI와 API    JavaScript 정규표현식    JavaScript 함수지향 - 유효범위    JavaScript 함수지향 - 값으로서의 함수와 콜백    JavaScript 함수지향 - 클로저    JavaScript 함수지향 - arguments    함수지향 - 함수의 호출    객체지향 - 객체지향 프로그래밍 소개    객체지향 - 생성자와 new    객체지향 - 전역객체    객체지향 - this    객체지향 - 상속    객체지향-표준 내장객체의 확장    JavaScript 객체지향-ObjectJavaScript 숫자와 문자1. 수의 표현 javascript는 큰따옴표나 작은 따옴표가 붙지 않은 숫자는 숫자로 인식한다.정수, 자연수, 실수 모두 사용가능하고 모두 숫자로 인식한다.javascript에선 포괄적으로 number라고 부르고 다른 프로그래밍 언어들 보다 덜 엄격한 편이다.수식으로는 더하기는 + 빼기는 - 나누기는 / 곱셈은 * 으로 표현한다.2. 수의 연산javascript는 계산 기능이 있는데 우리가 흔히 쓰는 수식과는 조금 다르기 때문에 그 방법을 알아두는게 좋겠다.아래 코드에 아직 배우지 않은 부분이 있는데 뒤에서 자세히 배워볼 예정이다.Math.pow(3,2);       // 9,   3의 2승 Math.round(10.6);    // 11,  10.6을 반올림Math.ceil(10.2);     // 11,  10.2를 올림Math.floor(10.6);    // 10,  10.6을 내림Math.sqrt(9);        // 3,   3의 제곱근Math.random();       // 0부터 1.0 사이의 랜덤한 숫자3. 문자””,’‘내에 들어가는 내용은 javascript가 문자로 인식한다.데이터를 입력하면 javascript는 문자와 숫자를 인식하게 된다.숫자를 “A”나 ‘A’로 감싸면 문자로 인식하게 된다.우리가 작성한 데이터 값은 typeof 라는 명령을 사용하면 데이터의 형식을 알수있다.문자는 string 숫자는 number라는 결과가 나온다.alert(typeof \"1\") //결과 : string \"내용' 이런식의 기입은 할수 없음을 알아두자.여러줄로 표시하기 위해서는 \\n을 사용할 수 있다.alert(\"왔냐.\\n 코딩 연습장이다\")또한 데이터를 입력하다 보면 ‘이나 “ ex)alert(‘egoing’s coding everyday’) 등을 사용 해야할 때가 이있는데 이럴땐 \\뒤에 해당 기호를 넣어 문자로 인식하게 할수 있다.alert(\"egoing's coding everyday\") // \"\"사이에 '가 들어 있기 때문에 사용 가능하다.arlert('egoing\\'s coding everyday')// 역슬래쉬 \\뒤의 어떠한 기호는 문자로 해석된다. escape라고 한다.4. 문자의 연산1+1은 2이다 하지만 “1”+”1”은 “11”이된다. 숫자와 문자의 연산은 전혀 다르다.문자를 더하는 표현은 아래와 같다.alert(\"Ahns\"+\" Coding Gym\") //결과 : Ahns Coding Gym문자의 길이를 구할때는 문자 뒤에 .length를 붙여준다.alert(\"Ahns Coding Gym\".length) //결과 : 15 ",
        "url": "/javascript-basic2"
    }
    ,
    
    "javascript-basic": {
        "title": "Javascript - JavaScript 기본",
            "author": "AhnSang0915",
            "category": "",
            "content": "Javascript    JavaScript 기본     JavaScript 숫자와 문자     JavaScript 변수, 비교    JavaScript 조건문    JavaScript 반복문    JavaScript 함수    JavaScript 배열    JavaScript 객체(Object)    JavaScript 모듈    JavaScript UI와 API    JavaScript 정규표현식    JavaScript 함수지향 - 유효범위    JavaScript 함수지향 - 값으로서의 함수와 콜백    JavaScript 함수지향 - 클로저    JavaScript 함수지향 - arguments    함수지향 - 함수의 호출    객체지향 - 객체지향 프로그래밍 소개    객체지향 - 생성자와 new    객체지향 - 전역객체    객체지향 - this    객체지향 - 상속    객체지향-표준 내장객체의 확장    JavaScript 객체지향-ObjectJavaScript 기본1. 주석 (Comment)주석은 JavaScript Code외의 우리가 쓰는 문자로 사용되는 내용을 말한다.코드 내용에대한 부연설명이나 함수에 대한 기능을 작성할수 있고 불필요한 코드의 실행을 막을수 있다.JavaScript주석의 코드 사용 방법한줄 주석의 경우 - // 내용여러 줄의 경우 - /* 내용 */ 로 사용한다// 한줄 주석 사용시/*     여러줄     주석     사용시*/2. 줄바꿈과 여백JavaScript의 경우 명령이 끝났다는걸 알려주기 위해 ;를 표시해준다 줄바꿈을 할 경우엔 JavaScript에서 자동으로 명령이 끝났다고 판단하지만 한줄에 여러 명령을 쓸 경우가 있어 명령어 뒤엔 ;를 붙여주는게 좋다.    &lt;script type=\"text/javascript\"&gt;        var a = 1; //;을 안넣어도 줄이 바뀌면 명령이 끝났다고 인식한다        alert(a);    &lt;/script&gt;위 코드에서 ;기호를 없애도 줄바꿈을 했기 때문에 명령이 끝났다고 인식할 것 이다.하지만    &lt;script type=\"text/javascript\"&gt;        var a = 1; alert(a); //;가 없다면 var a = 1alert(a) 가 될것이다.            &lt;/script&gt;이런 경우엔 ;가 없다면 하나의 명령이 될 것이다.( var 뒤 띄어쓰기를 해야 하고 =양쪽엔 하지 않아도 된다.)그리고 코드를 썼는데 코드가 다닥다닥 붙어 있다면 코드를 보기 힘들 것이다. 가독성이 좋지 않다는 말이다. Tap키를 명령어와 함수 사이에 적절히 사용해 좀 더 보기 좋게 하는 게 좋을 것이다.",
        "url": "/javascript-basic"
    }
    ,
    
    "gettysburg-address": {
        "title": "Gettysburg Address",
            "author": "abraham",
            "category": "",
            "content": "Fourscore and seven years ago our fathers brought forth on this continent, a new nation, conceived in Liberty, and dedicated to the proposition that all men are created equal.Now we are engaged in a great civil war, testing whether that nation, or any nation so conceived and so dedicated, can long endure. We are met on a great battle-field of that war. We have come to dedicate a portion of that field, as a final resting place for those who here gave their lives that that nation might live. It is altogether fitting and proper that we should do this.But, in a larger sense, we can not dedicate-we can not consecrate-we can not hallow-this ground. The brave men, living and dead, who struggled here, have consecrated it, far above our poor power to add or detract. The world will little note, nor long remember what we say here, but it can never forget what they did here. It is for us the living, rather, to be dedicated here to the unfinished work which they who fought here have thus far so nobly advanced. It is rather for us to be here dedicated to the great task remaining before us-that from these honored dead we take increased devotion to that cause for which they gave the last full measure of devotion-that we here highly resolve that these dead shall not have died in vain-that this nation, under God, shall have a new birth of freedom-and that government of the people, by the people, for the people shall not perish from the earth.",
        "url": "/gettysburg-address"
    }
    
    
    };
</script>
<script src="assets/js/lunr.js"></script>
<script src="assets/js/search.js"></script>
            </section>

        </article>

    </div>
</main>

<!-- /post -->

<!-- The #contentFor helper here will send everything inside it up to the matching #block helper found in default.hbs -->
<script>
$(function() {
    var $postContent = $(".post-full-content");
    $postContent.fitVids();
});
</script>



        <!-- Previous/next page links - displayed on every page -->
        

        <!-- The footer at the very bottom of the screen -->
        <footer class="site-footer outer">
            <div class="site-footer-content inner">
                <section class="copyright"><a href="https://AhnSang0915.github.io/">My Coding Practice Gym</a> &copy; 2022</section>
                <section class="poweredby">Proudly published with <a href="https://jekyllrb.com/">Jekyll</a> &
                    <a href="https://pages.github.com/" target="_blank" rel="noopener">GitHub Pages</a> using
                    <a href="https://github.com/jekyllt/jasper2" target="_blank" rel="noopener">Jasper2</a></section>
                <nav class="site-footer-nav">
                    <a href="/">Latest Posts</a>
                    
                    
                    <a href="https://ghost.org" target="_blank" rel="noopener">Ghost</a>
                </nav>
            </div>
        </footer>

    </div>

    <!-- The big email subscribe modal content -->
    
    <div id="subscribe" class="subscribe-overlay">
        <a class="subscribe-overlay-close" href="#"></a>
            <div class="subscribe-overlay-content">
                
                <h1 class="subscribe-overlay-title">Search My Coding Practice Gym</h1>
                <p class="subscribe-overlay-description">
                블로그 포스팅 검색 </p>
                <span id="searchform" method="post" action="/subscribe/" class="">
    <input class="confirm" type="hidden" name="confirm"  />
    <input class="location" type="hidden" name="location"  />
    <input class="referrer" type="hidden" name="referrer"  />

    <div class="form-group">
        <input class="subscribe-email" onkeyup="myFunc()" 
               id="searchtext" type="text" name="searchtext"  
               placeholder="Search..." />
    </div>
    <script type="text/javascript">
        function myFunc() {
            if(event.keyCode == 13) {
                var url = encodeURIComponent($("#searchtext").val());
                location.href = "/search.html?query=" + url;
            }
        }
    </script>
</span>
            </div>
    </div>
    

    <!-- highlight.js -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.10.0/components/prism-abap.min.js"></script>
    <script>$(document).ready(function() {
      $('pre code').each(function(i, block) {
        hljs.highlightBlock(block);
      });
    });</script>

    <!-- jQuery + Fitvids, which makes all video embeds responsive -->
    <script
        src="https://code.jquery.com/jquery-3.2.1.min.js"
        integrity="sha256-hwg4gsxgFZhOsEEamdOYGBf13FyQuiTwlAQgxVSNgt4="
        crossorigin="anonymous">
    </script>
    <script type="text/javascript" src="/assets/js/jquery.fitvids.js"></script>
    <script type="text/javascript" src="https://demo.ghost.io/assets/js/jquery.fitvids.js?v=724281a32e"></script>


    <!-- Paginator increased to "infinit" in _config.yml -->
    <!-- if paginator.posts  -->
    <!-- <script>
        var maxPages = parseInt('');
    </script>
    <script src="/assets/js/infinitescroll.js"></script> -->
    <!-- /endif -->

    


    <!-- Add Google Analytics  -->
    <!-- Google Analytics Tracking code -->
 <script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-xxxxxxxx-x', 'auto');
  ga('send', 'pageview');

 </script>


    <!-- The #block helper will pull in data from the #contentFor other template files. In this case, there's some JavaScript which we only want to use in post.hbs, but it needs to be included down here, after jQuery has already loaded. -->
    
        <script>
$(function() {
    var $postContent = $(".post-full-content");
    $postContent.fitVids();
});
</script>

    

    <!-- Ghost outputs important scripts and data with this tag - it should always be the very last thing before the closing body tag -->
    <!-- ghost_foot -->

</body>
</html>
